









# html+css 

**万国码**：`<meta charset="utf-8">`

**外部样式链接**：`<link href="文件路径" rel="stylesheet">`

**列表类型**：

- 无序列表：`<ul></ul>`
- 有序列表：`<ol></ol>`
- 定义列表：`<dl><dt><dd></dl>`

**列表样式**：

- 设置项目图像：`list-style-image: url(...)`
- 符号位置：`list-style-position: inside / outside`
- 样式去除符号：`list-style: none`

**盒子模式：**`box-sizing = border-box;` 

------

## HTML5新增语义化标签

```html
<header>   <!-- 网页顶部内容 -->
<nav>      <!-- 页面导航 -->
<aside>    <!-- 侧边栏 -->
<main>     <!-- 网页主要内容 (仅一个) -->
<article>  <!-- 独立内容块，如博客文章 -->
<section>  <!-- 内容分组，主题相关 -->
<footer>   <!-- 网页底部，如版权声明 -->
```

------

## CSS选择器：

**并集选择器**：`h1, h2 { ... }` （同时选择多个标签）

**子代选择器**：`div > li { ... }` （仅选择直接子代）

**相邻兄弟选择器**：`ul li ~ li { ... }` （选择`ul li`后相邻的`li`标签）

**平级选择器**：`div + div { ... }` （选择紧跟的兄弟元素）

------

### 属性选择器:

**选择类名完全相同的元素**：`[class="box"] { ... }`

**选择包含指定类名的元素**：`.box [class="box"] { ... }`

**选择类名以"box"开头的元素**：`[class^="box"] { ... }`

**选择类名中包含"box"的元素**：`[class*="box"] { ... }`

------

## 常见实体字符:

| 实体字符 | 描述           | 实体字符 | 描述           |
| -------- | -------------- | -------- | -------------- |
| `<`      | 小于号 (`<`)   | `>`      | 大于号 (`>`)   |
| `©`      | 版权符号 (`©`) | `®`      | 注册商标 (`®`) |
| `&`      | 与符号 (`&`)   | `×`      | 乘号 (`×`)     |
| `"`      | 双引号 (`"`)   | ` `      | 空格           |

------

## 文本属性：

**字体设置**：

- `font-family: "微软雅黑", "宋体";`
- **字体大小**：`font-size: px;`
- **字体粗细**：`font-weight: 400;`
- **行高**：`line-height: px;`
- **首行缩进**：`text-indent: em;`
- **字体颜色**：`color: #000;`
- **字体间距**：`letter-spacing: px;`
- **大写/小写转换**：`text-transform: uppercase / lowercase;`

**文本修饰**：

- **下划线**：`text-decoration: underline;`
- **删除线**：`text-decoration: line-through;`
- **顶线**：`text-decoration: overline;`
- **取消链接下划线**：`a { text-decoration: none; }`

**鼠标悬停样式**：`cursor: pointer;`

**禁止文本复制**：`user-select: none;`

**字体渐变**：

```css
background-image: -webkit-linear-gradient(left, #25D38B, #1FB682, #1DAC7F);
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
```

**文本对齐与溢出处理**：

- **两端对齐**：`text-align-last: justify;`

  **文本溢出显示省略号**：`text-overflow: ellipsis;`

  **强制一行显示**：`white-space: nowrap;`

  **换行与隐藏**：

  ```css
  word-break: break-all;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* 限制行数 */
  -webkit-box-orient: vertical;
  overflow: hidden;
  ```

------



## 盒子属性：

**定位属性**：`position: relative | absolute | fixed | sticky | static;`

**盒子阴影**：

```css
box-shadow: 水平偏移, 垂直偏移, 模糊半径, 扩散半径, 颜色, inset(内阴影);
```

**视口单位**：

- **宽度单位**：`1vw = 1% viewport width;`
- **高度单位**：`1vh = 1% viewport height;`

**清除浮动**：

1. 新建一个清除浮动的盒子：`clear: both;`
2. 大盒子设置：`overflow: hidden;`

**滚动条隐藏**：

```css
::-webkit-scrollbar {
    width: 0px;
    height: 0px;
    background-color: #F5F5F5;
}
```

### 	弹性盒子 (Flexbox)

**弹性容器**：`display: flex;`

**水平居中**：`justify-content: center;`（主轴）

**垂直居中**：`align-items: center;`（侧轴）

**设置子元素方向**：`flex-direction: row | row-reverse | column | column-reverse;`

**是否换行**：`flex-wrap: nowrap | wrap | wrap-reverse;`

**不拉伸子元素**：`flex-shrink: 0;`

**`row`**：主轴水平方向，起点在左。

**`row-reverse`**：主轴水平方向，起点在右。

**`column`**：主轴垂直方向，起点在上。

**`column-reverse`**：主轴垂直方向，起点在下。

- **元素对齐方式**：
  - **空间分布**：
    - `space-around`：元素之间的间距相等，左右边距为元素间距的一半。
    - `space-evenly`：元素之间和两边的间距相等。
    - `space-between`：元素之间的间距相等，左右两端对齐。
- **单独控制元素对齐**：
  - `align-self`：用于单个元素的对齐方式，覆盖容器的`align-items`设置。
- **元素排列顺序**：
  - `order`：定义元素的顺序，值越小，排列越靠前，默认值为 `0`。
- **Flex子元素占比**：
  1. **扩展比例**：`flex-grow: number;` （值越大，元素扩展越大）
  2. **收缩比例**：`flex-shrink: number;` （值越大，元素收缩越多）
  3. **基础大小**：`flex-basis: 基准值;` （设置元素初始大小）

**图片背景居中**：

```html
:style="{ backgroundImage: 'url(' + getImgSrc(ig.xwzx) + ')' }"
```

```css
/* 图片背景居中 */
background-size: cover;         /* 背景图像完全覆盖元素 */
background-repeat: no-repeat;   /* 不重复显示背景图像 */
background-position: 50% 50%;   /* 背景图片居中对齐 */
```



## 表单以及控件：

- ### 表单元素

  - **表单**：`<form></form>` 用于提交用户输入信息。

  - **文本输入框**：

    ```html
    <input type="text" placeholder="提示" value="初始值"/>
    ```

    - **取消`input`点击效果**：`outline: none;`
    - **取消`input`默认样式**：`-webkit-appearance: none;`

  ### 按钮类型

  - **提交按钮**：`<input type="submit" value="提交">`

  - **重置按钮**：`<input type="reset" value="重置">`

  - **普通按钮**：`<input type="button" value="按钮">`

  - **禁用按钮**：

    ```js
    btn.setAttribute("disabled", true);  // 禁用按钮
    ```

  - ### 表格标签

    - **表格标签**：`<table></table>`
    - **行**：`<tr></tr>` 用于定义表格的行。
    - **单元格**：
      - 标题单元格：`<th></th>`（表头）
      - 数据单元格：`<td></td>`（表内容）
    - **合并单元格**：
      - **向下合并**：`rowspan` 属性，用于纵向合并单元格。
      - **向右合并**：`colspan` 属性，用于横向合并单元格。

------

## 背景：

> `background：position`		**精灵图**

> `linear-gradient（to left，××，××）`		**线性渐变**

> `background-repeat：no-repeat`		**图片不重复**

------

## 类型转换：

`display`：		**行内元素**：`inline`		**块元素**：`block`		**行内块元素**：`inline-block`		**不显示**：`none`

------

## 伪类选择器：

**链接相关伪类**：

- `:link`：未访问的链接
- `:visited`：已访问的链接
- `:active`：选中的链接

**结构伪类**：

- `:first-of-type`：父级元素的首个指定类型子元素
- `:last-of-type`：父级元素的最后一个指定类型子元素
- `:nth-child(n)`：匹配父元素的第 `n` 个子元素，支持 `odd`（奇数）和 `even`（偶数）
- `:nth-last-child(n)`：从后往前数的第 `n` 个子元素
- `:first-child`：父元素的第一个子元素
- `:last-child`：父元素的最后一个子元素
- **公式** `(an+b)`：如 `nth-child(2n+1)` 匹配奇数位置元素，`nth-child(-n+3)` 匹配前三个元素

**状态伪类**：

- `:enabled`：启用状态的元素
- `:disabled`：禁用状态的元素
- `:checked`：被选中的 `input` 元素
- `:focus`：元素获取焦点时的样式，常用于表单控件，取消默认样式：`outline: none;`

**其他伪类**：

- `:not(selector)`：匹配所有不符合 `selector` 的元素
- `:target`：选取当前激活的目标元素，如锚点链接 `#anchor:target`

## 伪元素选择器

**`:first-letter`**：向块级元素的首个字符添加样式。

**`:first-line`**：向块级元素的首行文本添加样式。

**`:before`**：在元素内部开头插入内容，常用于修饰：

```css
element::before {
    content: "前置内容";
}
```

**`:after`**：在元素内部结尾插入内容：

```css
element::after {
    content: "后置内容";
}
```



# css3

## 瀑布流

```
column-count: 3;

column-gap: 10px;

break-inside: avoid;

栅格化
```



## @media 查询

响应式页面

```css
@media scre en and (max-width: 300px) {

}
@media screen and (min-width: 769px) and (max-width: 992px) {
    /* 大于768px 小于992px  小屏幕 */
}
```

## calc计算

```css
calc(100% - 50px)
```

## transition 过度属性

```css
transition: background-color 0.2s linear 0s; /* 背景颜色的过渡效果，持续0.2秒，线性过渡 */
```

### 常用过渡效果

- **linear**：匀速过渡，速度不变，等价于 `cubic-bezier(0, 0, 1, 1)`。
- **ease**：慢速开始，中间加速，最后慢速结束，等价于 `cubic-bezier(0.25, 0.1, 0.25, 1)`。
- **ease-in**：缓慢开始，后续加速，等价于 `cubic-bezier(0.42, 0, 1, 1)`。
- **ease-out**：快速开始，缓慢结束，等价于 `cubic-bezier(0, 0, 0.58, 1)`。
- **ease-in-out**：缓慢开始和结束，中间加速，等价于 `cubic-bezier(0.42, 0, 0.58, 1)`。

### 自定义过渡曲线

- **cubic-bezier(\*n\*, \*n\*, \*n\*, \*n\*)**：自定义过渡曲线，值在 `0` 到 `1` 之间。例如：

- ```css
  transition-timing-function: cubic-bezier(0.5, 0, 0.5, 1);
  ```

### 过渡属性参数解释

- **属性名**：如 `background-color`，定义要过渡的CSS属性。
- **持续时间**：过渡效果的持续时间（如 `0.2s`）。
- **过渡函数**：定义过渡效果的速度曲线，如 `linear`、`ease`。
- **延迟时间**：定义过渡效果何时开始（如 `0s` 为无延迟）。

## transform 旋转属性

### 常用 `transform` 转换属性

- **无转换**：`none` – 无任何转换。
- **2D 转换**：
  - `matrix(n, n, n, n, n, n)`：2D 矩阵转换（6个值）。
  - `translate(x, y)`：2D 平移转换。
  - `scale(x, y)`：2D 缩放转换。
  - `rotate(angle)`：2D 旋转转换，按指定角度旋转。
  - `skew(x-angle, y-angle)`：2D 倾斜转换。
- **3D 转换**：
  - `matrix3d(n, n, ..., n)`：3D 矩阵转换（16个值）。
  - `translate3d(x, y, z)`：3D 平移转换。
  - `scale3d(x, y, z)`：3D 缩放转换。
  - `rotate3d(x, y, z, angle)`：3D 旋转转换，指定 x、y、z 轴和角度。
  - `perspective(n)`：设置 3D 透视视图。

### 单轴转换

- **平移**：
  - `translateX(x)`：仅沿 X 轴平移。
  - `translateY(y)`：仅沿 Y 轴平移。
  - `translateZ(z)`：仅沿 Z 轴进行 3D 平移。
- **缩放**：
  - `scaleX(x)`：沿 X 轴缩放。
  - `scaleY(y)`：沿 Y 轴缩放。
  - `scaleZ(z)`：沿 Z 轴进行 3D 缩放。
- **旋转**：
  - `rotateX(angle)`：沿 X 轴旋转（3D）。
  - `rotateY(angle)`：沿 Y 轴旋转（3D）。
  - `rotateZ(angle)`：沿 Z 轴旋转（3D）。
- **倾斜**：
  - `skewX(angle)`：沿 X 轴倾斜。
  - `skewY(angle)`：沿 Y 轴倾斜。

```css
/* 2D 旋转 */
transform: rotate(45deg);
/* 3D 旋转 */
transform: rotate3d(1, 1, 0, 45deg);
/* 缩放 */
transform: scale(1.5, 1.5);
/* 平移 */
transform: translate(50px, 100px);
```



## 音频audio

```html
<audio src="音频资源路径" controls autoplay loop muted></audio>
```

```js
// 播放事件
audioElement.onplay = () => console.log('音频开始播放');
// 暂停事件
audioElement.onpause = () => console.log('音频已暂停');
// 播放时间变化
audioElement.ontimeupdate = () => console.log(`当前时间: ${audioElement.currentTime}s`);
// 可以播放时
audioElement.oncanplay = () => console.log('音频可播放');
// 播放结束
audioElement.onended = () => console.log('音频播放结束');
// 拖动进度条完成
audioElement.onseeked = () => console.log('拖动完成');
// 正在拖动进度条
audioElement.onseeking = () => console.log('正在拖动');
// 音量改变事件
audioElement.onvolumechange = () => console.log('音量已改变');
```

```js
audioElement.play();    // 播放音频
audioElement.pause();   // 暂停音频
audioElement.load();    // 重新加载音频

audioElement.loop = true;                     // 设置音频循环
console.log(audioElement.currentTime);        // 当前播放时间
console.log(audioElement.duration);           // 音频总时长
audioElement.volume = 0.5;                    // 设置音量
audioElement.playbackRate = 1.5;              // 设置播放速度
```

## 拖放拖拽

```css
<div id="box" class="box" draggable="true"></div>  <!-- 设置可拖拽属性 draggable="true" -->
<div id="target" class="target"></div>  <!-- 拖拽的目标区域 -->
```

```js
// 获取元素
const box = document.getElementById('box');
const target = document.getElementById('target');

// 开始拖拽事件，作用于被拖拽元素
box.ondragstart = function () {
    console.log('开始拖拽');
};

// 结束拖拽事件，作用于被拖拽元素
box.ondragend = function () {
    console.log('结束拖拽');
};

// 被拖拽元素进入目标区域事件，作用于目标元素
target.ondragenter = function () {
    console.log('被拖拽元素进入目标元素');
};

// 在目标元素内拖拽，作用于目标元素
target.ondragover = function(e) {
    // 阻止默认行为，使得 ondrop 可以触发
    e.preventDefault();
    console.log('被拖拽元素在目标元素里面');
};

// 拖放事件，作用于目标元素
target.ondrop = function () {
    console.log('拖放完成');
    this.appendChild(box);  // 将被拖拽元素添加到目标元素中
};
```

## 本地储存

### localStorage（本地存储）

- **设置本地存储**：

  ```js
  localStorage.setItem('name', 'kevin');
  ```

  **存储引用数据类型（序列化）**

  ```js
  const books = [{name: 'HTML'}, {name: 'CSS'}, {name: 'JS'}];
  localStorage.setItem('books', JSON.stringify(books));  // 序列化
  ```

  **获取本地存储**：

  ```js
  const storedBooks = localStorage.getItem('books');
  const booksArray = JSON.parse(storedBooks);  // 反序列化
  ```

  **删除单个存储项**：

  ```js
  localStorage.removeItem('name');
  ```

  **清空所有本地存储**：

  ```js
  localStorage.clear();
  ```

  

### sessionStorage（会话存储）

- **设置会话存储**：

  ```js
  sessionStorage.setItem('name', 'kevin');
  ```

  **获取会话存储**：

  ```js
  const storedApple = sessionStorage.getItem('apple');
  const appleObject = JSON.parse(storedApple);  // 反序列化
  ```

  

### Cookie 操作

- **设置 Cookie（有效时间 30 分钟）**：

  ```js
  const time = new Date().getTime() + 30 * 60 * 1000;
  const date = new Date(time).toUTCString();
  document.cookie = `cookieKey=cookieValue;expires=${date}`;
  ```

  **获取所有 Cookie**：

  ```js
  const cookieData = document.cookie;
  const cookies = cookieData.split('; ');
  const cookieObject = {};
  
  cookies.forEach(cookie => {
    const [key, value] = cookie.split('=');
    cookieObject[key] = value;
  });
  ```

  **删除 Cookie（设置过期时间）**：

  ```js
  const expires = new Date('1970-01-01 00:00:00').toUTCString();
  document.cookie = `fruit=;expires=${expires}`;
  ```

  

## woker

**主线程（创建和使用 Worker）**

```js
// 创建一个新的 Web Worker
var worker = new Worker('./myworker.js');

// 向 Worker 发送数据
worker.postMessage('Some data');

// 接收 Worker 线程返回的数据
worker.onmessage = function(e) {
    var data = e.data;
    console.log('接收到的数据：', data);
};

// 终止 Worker 线程
worker.terminate();
```

**Worker 线程**（`myworker.js`）

```js
// 监听主线程发来的消息
onmessage = function(e) {
    var content = e.data;
    console.log('收到主线程的数据：', content);
    
    // 处理并返回结果给主线程
    var result = `Processed: ${content}`;
    postMessage(result);  // 发送结果回主线程
};
```

# ES6

## 箭头函数

```js
let gn1 = () => {};
let gn2 = a => {};
let gn3 = (a, b) => {};
let gn5 = (a, b) => a + b + 16;
let gn6 = (name, age) => ({name, age});  // 简化属性名
```

## 解构赋值

```js
let { height: studentHeight, technology: tech, name: studentName, weight, address: { city: ci } } = {
    name: '小明',
    height: 170,
    weight: 130,
    technology: ['编程', '打篮球'],
    address: { city: '广州' }
};
```

## 拓展运算符

```js
// 复制对象并添加/合并属性
let student = { name: '小明', height: 170, weight: 120, color: '黄色' };
let obj = { book: 'HTML' };
let person = { ...student, price: 100, address: '广州', ...obj };

// 复制数组
let arr3 = ['电动车', '自行车', '泥头车'];
let arr4 = [...arr3];
arr3.push('水泥车');  // arr4 不受影响
console.log('arr3 ==> ', arr3);
console.log('arr4 ==> ', arr4);

// 扩展运算符在函数参数中的使用
function sum1(...params) {
    return params.reduce((total, v) => total + v, 0);
}
let t1 = sum1(100, 52, 60);
let t2 = sum1(10, 24);
```

## 	String拓展

```JS
let t = 'this is an apple';
//includes(char[,index]): 查找是否包含指定字符串, 返回一个布尔值, char: 查找的字符串, index: 开始查找位置, 默认为0
let isHas3 = t.includes('is', 4);

//startsWith(char[, index]): 匹配开头的字符串, 返回一个布尔值, char: 查找的字符串, index: 开始查找位置, 默认为0
let isHas4 = t.startsWith('is', 2);

//endsWith(char[, n]): 匹配结尾的字符串, 返回一个布尔值, char: 查找的字符串, n: 前n个字符(n不是下标)
let isHas5 = t.endsWith('i', 6);
```

## 数组拓展

```js
//Array.from(): 将类数组对象转换为数组
//Array.of(): 将一组值转化为数组
let myBook = book.map(function (value, index, arr) {
      //value: 数组的元素
      //index: 数组的元素下标
      //arr: 原数组
      console.log('this ==> ', this);
      return `<li data-index="${index}">${value}</li>`;
}, o1)

//Array.prototype.find(fn[, fn的this指向]): 查找数组元素, 如果return true, 返回当前元素, 找不到返回undefined
let animal = ['老鹰', '白兔', '老虎', '青龙'];
let isHas = animal.find(function (a, b, c) {
      console.log('find a ==> ', a);
      console.log('b ==> ', b);
      console.log('c ==> ', c);

      console.log('this ==> ', this);

      return a === '老鹰';
}, {aa: 1});
```

## 对象拓展

### 简写

```js
// 简写
let animalName = '鸭子';
let k = 'a';
let fnName = 'getAnimalName';
let animal = {
    animalName,
    color: '淡黄色',
    [k]: '10km/h',
    swim() { console.log(this.animalName + '会游泳'); },
    getColor() { console.log('this.color ==> ', this.color); },
    [fnName]() { console.log('this.animalName ==> ', this.animalName); }
};
```

### defineProperty( )方法

```js
// 定义不可写、不可删除、不可枚举的属性
Object.defineProperty(data, 'height', {
    writable: false,
    configurable: false,
    enumerable: false
});
```

## set数据结构

```js
// 创建Set去重
let book = ['html', 'css', 'js', 'css', 'js', 'es6'];
let myBook = new Set(book);
let bookData = [...myBook];  // 将Set转换为数组
console.log('bookData ==> ', bookData);

// Set基础操作
let fruit = new Set();

// 1. 添加元素
fruit.add('黑布林');

// 2. 获取keys迭代器并遍历
for (let key of fruit.keys()) {
    console.log('key ==> ', key);
}

// 3. 获取values迭代器并遍历
for (let value of fruit.values()) {
    console.log('value ==> ', value);
}

// 4. 获取entries迭代器并遍历，返回[key, value]对
for (let [key, value] of fruit.entries()) {
    console.log(`[key, value] ==> ${key}, ${value}`);
}

// 5. 判断是否存在指定元素
let isHas = fruit.has('葡萄1');

// 6. 删除元素或清空
fruit.delete('黑布林'); // 删除一个元素
fruit.clear();           // 清空Set

// 7. 获取Set大小
console.log('Set size ==> ', fruit.size);
```

## 类

### 类的继承与重写

```js
// 父类
class Person {
    constructor(name, height) {
        this.name = name;
        this.height = height;
    }
    run() {
        console.log(this.name + '会跑步');
    }
}

// 子类继承父类
class DancerPerson extends Person {
    dancer() {
        console.log(this.name + '会跳舞');
    }
}

// 子类重写父类方法
class SwimPerson extends Person {
    constructor(name, height, speed) {
        super(name, height);  // 调用父类的构造函数
        this.speed = speed;   // 扩展子类属性
    }
    
    run() {
        console.log(`${this.name}的跑步速度为${this.speed}`);
    }
}

// 创建实例对象
let mark = new SwimPerson('mark', 172, '5km/h');
mark.run();  // 输出：mark的跑步速度为5km/h
```

### 类的三大状态

```js
let o = { name: 'kevin', age: 20 };

// 1. 防扩展：不能添加新属性，但可修改或删除已有属性
Object.preventExtensions(o);
console.log(Object.isExtensible(o));  // 检查对象是否可扩展

// 2. 密封对象：不能添加或删除属性，但可修改现有属性
Object.seal(o);
console.log(Object.isSealed(o));  // 检查对象是否密封

// 3. 冻结对象：不能添加、删除或修改属性（完全不可变）
Object.freeze(o);
console.log(Object.isFrozen(o));  // 检查对象是否被冻结
```

### Reflect 和 Object 的扩展功能

```js
// Reflect 使用示例
let arr = [1, 2, 3];
let maxVal = Reflect.apply(Math.max, Math, arr);  // 使用Reflect调用函数
console.log(maxVal);  // 输出：3

// 使用 Reflect.construct 构造实例
class Animal {
    constructor(name, color) {
        this.name = name;
        this.color = color;
    }
}
let yellowDuck = Reflect.construct(Animal, ['小黄鸭', '黄色']);

// 删除对象属性
Reflect.deleteProperty(yellowDuck, 'color');

// 定义对象属性
Object.defineProperty(yellowDuck, 'author', {
    value: 'kevin',
    writable: true,
    configurable: true,
    enumerable: true
});

// 获取对象的键名
let keys = Reflect.ownKeys(yellowDuck);
console.log(keys);  // 输出属性键名数组
```



# JavaScript

## 数据类型

```js
string 
number 
boolean 
null 
undefined 
symbol
object
array
function
```

## **原型对象（prototype）**

JavaScript 是一种基于原型的编程语言，所有的对象都是通过**原型链**进行继承的。`prototype` 是每个构造函数都自带的一个属性，允许其实例对象共享属性和方法。

### 原型与构造函数

- **构造函数**：在 JavaScript 中，构造函数用于创建对象，其名称通常首字母大写（如 `String`、`Array`）。
- **原型对象**：构造函数的 `prototype` 属性是一个对象，包含该构造函数实例对象可以共享的方法和属性。

**内置构造函数**

```js
// 常见内置构造函数
console.log(String.prototype);  // 字符串构造函数的原型对象
console.log(Number.prototype);  // 数字构造函数的原型对象
console.log(Array.prototype);   // 数组构造函数的原型对象
```

**使用构造函数创建实例**

```js
// 使用 String 构造函数创建字符串实例
var o1 = new String("hello");
console.log(o1);  // 输出 String 对象 {"hello"}

// 直接声明字符串（隐式创建String实例）
var str = "hello";
console.log(str.split(""));  // 通过 String 的原型方法 split 分割字符串
```

#### 原型的作用

1. **属性和方法共享**：挂载在 `prototype` 上的属性和方法可以被该构造函数的所有实例共享。
2. **减少内存占用**：由于所有实例共享 `prototype` 上的方法，避免每个实例都创建重复的函数。

#### 常见原型对象

- **`String.prototype`**：存放字符串实例可以调用的所有方法，如 `split()`、`slice()` 等。
- **`Array.prototype`**：存放数组实例可以调用的所有方法，如 `push()`、`forEach()` 等。
- **`Object.prototype`**：所有对象的原型，包含 `toString()`、`hasOwnProperty()` 等常用方法。

#### 总结

- **构造函数**可以创建对象，并通过 `this` 赋予新对象属性。
- **构造函数的原型对象（`prototype`）**可以存放方法，供所有通过该构造函数创建的实例使用。
- **属性**通常用于记录数据，**方法**用于处理业务逻辑，并挂载在 `prototype` 上供实例共享。

### 隐式原型 `__proto__`

- **`__proto__`** 是每个实例对象都有的属性，它指向实例的原型对象（即构造函数的 `prototype`）。
- **`prototype`** 是构造函数的属性，而 **`__proto__`** 是实例对象的属性。

```js
function People() {}
var xiaoming = new People();

console.log(People.prototype);   // 构造函数的原型对象
console.log(xiaoming.__proto__); // 实例对象的隐式原型 (__proto__)

xiaoming.__proto__.sayHello = function() {
    console.log("hello world!");
};

People.prototype.sayHello2 = function() {
    console.log("hello world! 222");
};

console.log(People.prototype === xiaoming.__proto__); // true

xiaoming.sayHello();   // 输出: hello world!
xiaoming.sayHello2();  // 输出: hello world! 222
```

### **构造属性   constructor**

- **`constructor`** 属性用于指向构造函数。它可以通过原型找到构造函数，并帮助我们理解对象是由哪个构造函数创建的。

```js
function People() {}
var xiaoming = new People();

console.log(People.prototype.constructor);          // 指向构造函数 People
console.log(People.prototype.constructor === People); // true

// 通过实例对象的 __proto__ 访问 constructor
console.log(xiaoming.__proto__.constructor === People); // true
```

### **原型链**

- **原型链**是由构造函数的 `prototype` 和实例对象的 `__proto__` 组成的链式结构，构成了 JavaScript 中的继承机制。
- 如果某个属性或方法不存在于当前对象，它会沿着原型链向上查找，直到找到或达到原型链的终点 `null`。

```js
function App() {
    this.width = "100px";
}

// 在 App 的原型对象上添加方法
App.prototype.getRandom = function(min, max) {
    return Math.round(Math.random() * (max - min) + min);
};

// 在 Object 的原型对象上添加方法
Object.prototype.getPos = function() {
    return { x: 100, y: 200 };
};

var a1 = new App();
console.log(a1.width);             // 100px
console.log(a1.getRandom(50, 200)); // 随机整数
console.log(a1.getPos());          // { x: 100, y: 200 }

// 打印原型链
console.log(a1.__proto__);           // App.prototype
console.log(a1.__proto__.__proto__); // Object.prototype
console.log(a1.__proto__.__proto__.__proto__); // null
```

## arguments对象 

```js
// 1.0 加法函数
function add() {
// console.log(arguments);
    var x = arguments[0];// 代表实参 2
    var y = arguments[1];// 代表实参 98
    var total = x + y;
    console.log(total);
}
add(2,98)

// 2.0 调用函数
// add(2, 98);
// arguments 具有数组的特征和length属性,但是不能调用数组的API.
// arguments 是个伪数组,可以通过索引值取值
// arguments 仅仅可以在函数作用域中使用
// console.log(arguments);// 报错

// 1.0 定义函数
var foo = function() {
    console.log(arguments);
    // arguments.length 等于 0 ,说明没有实参
    // arguments.callee 代表函数本身
    console.log( foo === arguments.callee);// true 
}

// 2.0 调用函数
// foo("red");
```



## 浅拷贝

浅拷贝只复制对象或数组的第一层数据，任何一方的数据修改不会影响原始数据，但嵌套对象的引用仍指向原对象。适用于复制简单数据结构。

```js
function simpleCopy(elements) {
    var newData = Array.isArray(elements) ? [] : {};  // 判断是数组还是对象
    for (var key in elements) {
        newData[key] = elements[key];  // 复制第一层数据
    }
    return newData;
}

// 浅拷贝数组
var arr = ["red", "green", "blue"];
var res = simpleCopy(arr);
res[0] = "红色";
console.log(res);  // ["红色", "green", "blue"]
console.log(arr);  // ["red", "green", "blue"]

// 浅拷贝对象
var point = { x: 100, y: 200, color: "pink" };
var obj = simpleCopy(point);
obj.x = 888;
console.log(obj);  // {x: 888, y: 200, color: "pink"}
console.log(point);  // {x: 100, y: 200, color: "pink"}
```



## 深拷贝

深拷贝可以递归地复制所有层的数据，即使嵌套对象或数组，也能复制整个结构，确保复制的新数据与原数据没有任何引用关系。

```js
function deepCopy(elements) {
    var newData = Array.isArray(elements) ? [] : {};  // 判断是数组还是对象
    for (var key in elements) {
        if (typeof elements[key] === "object" && elements[key] !== null) {
            newData[key] = deepCopy(elements[key]);  // 递归深拷贝
        } else {
            newData[key] = elements[key];  // 复制基本数据类型
        }
    }
    return newData;
}

// 深拷贝对象
var point = {
    msg: "中心坐标",
    result: [100, 200, "pink", ["内容"]]
};
var obj2 = deepCopy(point);
obj2.result[2] = "粉色";
console.log(point);  // 原数据：{msg: "中心坐标", result: [100, 200, "pink", ["内容"]]}
console.log(obj2);  // 新数据：{msg: "中心坐标", result: [100, 200, "粉色", ["内容"]]}
```



## **显式转换**

JavaScript 提供了多种全局函数用于显式地将值转换为其他数据类型。常见的转换函数包括 `String()`、`Number()`、`Boolean()` 和 `Symbol()`。

#### 1. **`String()` - 转换为字符串**

```js
console.log(String(true));        // "true"
console.log(String(100));         // "100"
console.log(String(null));        // "null"
console.log(typeof String(100));  // "string"
```

#### 2. **`Number()` - 转换为数字**

```js
console.log(Number("100"));        // 100
console.log(Number("100xxx"));     // NaN
console.log(Number(true));         // 1
console.log(Number(false));        // 0
```

#### 3. **`Boolean()` - 转换为布尔值**

```js
console.log(Boolean("hello"));    // true
console.log(Boolean(1000));       // true
console.log(Boolean(""));         // false
console.log(Boolean(0));          // false
```

### **`parseFloat()` 和 `parseInt()`**

#### 1. **`parseFloat()` - 转换为浮点数**

```js
console.log(parseFloat("99.99$"));      // 99.99
console.log(parseFloat("100.11xxx"));   // 100.11
console.log(parseFloat("abc100"));      // NaN
```

#### 2. **`parseInt()` - 转换为整数**

```js
console.log(parseInt("100px"));         // 100
console.log(parseInt("100.66xxx"));     // 100
console.log(parseInt("f", 16));         // 15 (将16进制的'f'转换为10进制)
```

------

## **隐式转换**

隐式转换发生在运算过程中，JavaScript 会根据需要自动将值转换为合适的类型。

### 1. **`==` 运算符的隐式转换**

```js
console.log("" == false);               // true
console.log(0 == false);                // true
console.log(null == undefined);         // true
```

### 2. **字符串拼接 (`+`)**

```js
console.log("11" + 22);                 // "1122" (拼接字符串)
console.log("11" + true);               // "11true"
console.log(11 + 22);                   // 33 (数字相加)
```

### 3. **减法 (`-`)**

```js
console.log("100" - 0);                 // 100 (字符串转换为数字)
console.log("abc" - 0);                 // NaN (非数字字符串不能转换为数字)
```

------

## 字符串的操作【相关API】

#### 1. **`length` - 字符串长度**

获取字符串的长度，可以用来判断输入框是否有值。

```js
var str = "Today is sunny day!";
console.log(str.length);  // 输出: 18
```

#### 2. **`indexOf` - 查找首次出现的字符位置**

查找字符串中首次出现指定字符的位置，找不到返回 `-1`。

```js
console.log(str.indexOf("sunny"));  // 输出: 9
console.log(str.indexOf("z"));      // 输出: -1 (字符不存在)
```

#### 3. **`lastIndexOf` - 查找最后一次出现的字符位置**

查找字符串中最后一次出现指定字符的位置。

```js
console.log(str.lastIndexOf("o"));  // 输出: 1
```

#### 4. **`split` - 分割字符串**

将字符串按指定分隔符分割成数组。

```js
console.log(str.split());       // ["Today is sunny day!"]
console.log(str.split(""));     // ["T", "o", "d", "a", "y", " ", "i", "s", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y", "!"]
console.log(str.split(" "));    // ["Today", "is", "sunny", "day!"]
```

#### 5. **`charAt` - 获取指定位置的字符**

返回字符串中指定位置的字符。

```js
console.log(str.charAt(0));  // 输出: T
console.log(str.charAt(6));  // 输出: i
```

#### 6. **`charCodeAt` - 获取指定字符的 Unicode 编码**

返回字符串中指定位置字符的 Unicode 编码值。

```js
var demo = "abcA";
console.log(demo.charCodeAt(0));  // 输出: 97 (字符 'a')
console.log(demo.charCodeAt(3));  // 输出: 65 (字符 'A')
```

#### 7. **`replace` - 替换字符串中的内容**

替换字符串中的某个子字符串。

```js
console.log(str.replace("Today", "*****"));  // 输出: ***** is sunny day!
```

#### 8. **`slice` - 提取字符串的部分**

返回字符串中指定部分的新字符串，不修改原始字符串。

```js
console.log(str.slice(6, 13));  // 输出: is sunn
```

#### 9. **`substr` - 提取指定长度的子字符串**

从指定位置开始，提取指定长度的子字符串。

```js
console.log(str.substr(2, 3));  // 输出: day
```

#### 10. **`substring` - 提取字符串的部分**

返回两个指定索引之间的子字符串。

```js
console.log(str.substring(6, 13));  // 输出: is sunn
```



## **数组操作【API】**

#### 1. **添加数据**

- **`push()`**：向数组末端添加数据，返回数组的新长度。

```js
var arr = ["red", "green"];
arr.push("blue");
console.log(arr);  // ["red", "green", "blue"]
```

- **`unshift()`**：向数组首位添加数据，返回数组的新长度。

```js
arr.unshift("orange");
console.log(arr);  // ["orange", "red", "green", "blue"]
```

#### 2. **删除数据**

- **`pop()`**：删除数组的最后一个元素，返回被删除的元素。

```js
var lastElement = arr.pop();
console.log(lastElement);  // "blue"
console.log(arr);  // ["orange", "red", "green"]
```

- **`shift()`**：删除数组的第一个元素，返回被删除的元素。

```js
var firstElement = arr.shift();
console.log(firstElement);  // "orange"
console.log(arr);  // ["red", "green"]
```

#### 3. **修改数组**

- `splice()`

  ：删除或替换数组的元素。

  - 参数1：起始索引。
  - 参数2：删除的数量。
  - 参数3：可选，插入的数据。

```js
var arr = ["red", "green", "blue", "yellow"];
var removed = arr.splice(2, 2, "purple");  // 从索引2删除2个元素，并插入"purple"
console.log(removed);  // ["blue", "yellow"]
console.log(arr);  // ["red", "green", "purple"]
```

#### 4. **截取数组**

- `slice()`

  ：返回数组指定部分的新数组，不修改原数组。

  - 参数1：开始索引。
  - 参数2：可选，结束索引（不包括该索引）。

```js
var arr = ["red", "green", "blue", "yellow"];
console.log(arr.slice(1, 3));  // ["green", "blue"]
```

#### 5. **合并、拼接数组**

- **`concat()`**：合并多个数组，返回合并后的新数组。

```js
var arr1 = ["red"];
var arr2 = ["green"];
var merged = arr1.concat(arr2);
console.log(merged);  // ["red", "green"]
```

- `join()`

  ：将数组的所有元素拼接成一个字符串。

  - 参数：可选，指定分隔符。

```js
var str = arr.join(", ");
console.log(str);  // "red, green, blue, yellow"
```

#### 6. **排序数组**

- **`sort()`**：对数组进行排序（默认按字符编码顺序）。可以通过传递比较函数自定义排序规则。

```js
var arr = [80, 40, 70, 60];
arr.sort();  // 默认升序
console.log(arr);  // [40, 60, 70, 80]

// 自定义升序排序
arr.sort(function(a, b) {
  return a - b;  // 升序
});
console.log(arr);  // [40, 60, 70, 80]

// 自定义降序排序
arr.sort(function(a, b) {
  return b - a;  // 降序
});
console.log(arr);  // [80, 70, 60, 40]
```

#### 7. **过滤数组**

- **`filter()`**：根据回调函数的条件过滤数组，返回符合条件的元素组成的新数组。

```js
var arr = [1, 2, 3, 4];
var evenNumbers = arr.filter(function(num) {
  return num % 2 === 0;
});
console.log(evenNumbers);  // [2, 4]
```

#### 8. **伪数组转换为数组**

- 使用 `Array.prototype.slice.call()` 将伪数组转换为真正的数组。

```js
function test() {
  var args = Array.prototype.slice.call(arguments);
  console.log(args);
}
test(1, 2, 3);  // [1, 2, 3]
```

**增删元素**：`push()`、`pop()`、`unshift()`、`shift()`。

**修改数组**：`splice()`、`slice()`。

**合并和拼接**：`concat()`、`join()`。

**排序和过滤**：`sort()`、`filter()`。

**伪数组转数组**：`Array.prototype.slice.call()`。



## **数学对象Math (内置对象)**

#### 1. **圆周率 `PI`**

```js
console.log(Math.PI);  // 3.141592653589793
```

#### 2. **向上取整 `ceil()`**

```js
console.log(Math.ceil(99.1));  // 100
console.log(Math.ceil(-1.2));  // -1
```

#### 3. **向下取整 `floor()`**

```js
console.log(Math.floor(1.9));  // 1
console.log(Math.floor(-1.1)); // -2
```

#### 4. **四舍五入 `round()`**

```js
console.log(Math.round(4.4));  // 4
console.log(Math.round(4.5));  // 5
```

#### 5. **随机数 `random()`**

生成一个 `0` 到 `1` 之间的随机小数。

```js
console.log(Math.random());  // 0.xxxx

// 生成 0 ~ 10 之间的随机数
console.log(Math.random() * 10);

// 生成 50 ~ 81 之间的随机整数
var randomNum = Math.floor(Math.random() * 31 + 50);
console.log(randomNum);  // 50 ~ 81 之间的整数
```

#### 6. **三角函数**

计算一个角度对应的水平和垂直坐标。

```js
var angle = 30 * Math.PI / 180;  // 将角度转换为弧度
var radius = 150;
var x = Math.cos(angle) * radius;
var y = Math.sin(angle) * radius;
console.log(x, y);  // 计算水平和垂直坐标
```

### 数字操作

#### 1. **数字转换为不同进制的字符串**

将数字转换为指定进制的字符串（如二进制、十六进制等）。

```js
var num = 15;
console.log(num.toString(2));  // 二进制: 1111
console.log(num.toString(16)); // 十六进制: f
```

#### 2. **保留小数 `toFixed()`**

保留指定位数的小数（四舍五入）。

```js
var pi = 3.1415926;
console.log(pi.toFixed(2));  // 3.14
console.log(pi.toFixed(1));  // 3.1
```

#### 3. **处理浮点数精度丢失问题**

由于浮点数运算时精度丢失，常见问题如 `0.1 + 0.2` 不等于 `0.3`。解决方法是将浮点数转换为整数再进行运算。

```js
var x = 0.2;
var y = 0.7;
var result = x + y;
console.log(result);  // 0.8999999999999999

// 解决方法：先转换为整数再进行运算
var accurateResult = (x * 100 + y * 100) / 100;
console.log(accurateResult);  // 0.9
```

------

## **日期对象Date** 

#### 1. **创建 Date 实例**

- **当前时间**：

```js
var dt = new Date();  // 创建当前时间的日期对象
console.log(dt);  // 输出当前日期和时间
```

- **指定时间**：

```js
var dt = new Date("1999-01-01");  // 创建指定时间的日期对象
console.log(dt);  // 输出：Fri Jan 01 1999 00:00:00
```

#### 2. **获取日期和时间信息**

- **年份**：

```js
console.log(dt.getFullYear());  // 输出：当前年份，例如 2021
```

- **月份**（返回 0-11 表示 1-12 月份）：

```js
console.log(dt.getMonth());  // 输出：当前月份（0 表示 1 月，1 表示 2 月）
```

- **日期**：

```js
console.log(dt.getDate());  // 输出：当前日期（1-31）
```

- **星期**（返回 0 表示星期日，1 表示星期一，依次类推）：

```js
console.log(dt.getDay());  // 输出：当前星期几（0-6）
```

- **小时、分钟、秒、毫秒**：

```js
console.log(dt.getHours());  // 输出当前小时
console.log(dt.getMinutes());  // 输出当前分钟
console.log(dt.getSeconds());  // 输出当前秒
console.log(dt.getMilliseconds());  // 输出当前毫秒
```

### 时间戳

- **获取当前时间戳**（自 1970 年 1 月 1 日以来的毫秒数）：

```js
var time = new Date().getTime();
console.log(time);  // 输出时间戳
```

时间戳可以用于计算两个事件之间的时间差，常用于事件触发、长按检测等。

### **设置日期和时间**

你可以使用 `set` 系列方法来更改日期和时间。

- **设置年份、月份、日期、小时、分钟、秒、毫秒**：

```js
var dt = new Date();
dt.setFullYear(1999);    // 设置年份为 1999
dt.setMonth(1);          // 设置为 2 月（0 表示 1 月）
dt.setDate(12);          // 设置日期为 12 日
dt.setHours(13);         // 设置小时为 13
dt.setMinutes(15);       // 设置分钟为 15
dt.setSeconds(50);       // 设置秒为 50
dt.setMilliseconds(500); // 设置毫秒为 500
console.log(dt);
```

- **设置时间戳**：

```js
var futureTime = new Date().getTime() + (2 * 60 * 60 * 1000);  // 2小时后
dt.setTime(futureTime);  // 设置为未来时间
console.log(dt);
```

------

## 排序

#### 1. **插入排序（Insertion Sort）**

插入排序是一种简单的排序算法，类似于我们平常排序扑克牌的方式。每次从未排序的部分中取出一个元素，然后将其插入到已排序部分的正确位置。

**算法实现**：

```js
var mySort = function(array) {
    // 外循环遍历未排序部分
    for (var i = 0; i < array.length; i++) {
        var j = i - 1;
        var temp = array[i];  // 保存当前元素
        
        // 内循环将当前元素与已排序部分进行比较
        while (j >= 0 && temp < array[j]) {
            array[j + 1] = array[j];  // 将较大的元素向后移动
            j--;
        }
        
        // 插入当前元素到正确的位置
        array[j + 1] = temp;
    }
    return array;  // 返回已排序的数组
};

// 调用函数
var res = mySort([80, 20, 50, 60, 30]);
console.log(res);  // 输出: [20, 30, 50, 60, 80]
```

### 其他常见的排序算法

#### 2. **冒泡排序（Bubble Sort）**

冒泡排序通过多次遍历数组，每次将相邻的两个元素进行比较并交换，确保较大的元素逐步向数组末端移动。

```js
var bubbleSort = function(array) {
    for (var i = 0; i < array.length; i++) {
        for (var j = 0; j < array.length - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                // 交换相邻元素
                var temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
    return array;
};

console.log(bubbleSort([80, 20, 50, 60, 30]));  // [20, 30, 50, 60, 80]
```

#### 3. **快速排序（Quick Sort）**

快速排序是一种分治算法，通过选择一个“基准”元素，将数组分为小于基准和大于基准的两部分，递归地对这两部分进行排序。

```js
var quickSort = function(array) {
    if (array.length <= 1) return array;
    
    var pivot = array[0];
    var left = [];
    var right = [];
    
    // 将元素按大小分成两部分
    for (var i = 1; i < array.length; i++) {
        if (array[i] < pivot) {
            left.push(array[i]);
        } else {
            right.push(array[i]);
        }
    }
    
    // 递归排序并合并
    return quickSort(left).concat(pivot, quickSort(right));
};

console.log(quickSort([80, 20, 50, 60, 30]));  // [20, 30, 50, 60, 80]
```

#### 4. **使用 `Array.sort()`**

JavaScript 的内置 `Array.sort()` 方法使用的是基于快速排序的算法。默认情况下，它按字符编码顺序对元素进行排序。

```js
var arr = [80, 20, 50, 60, 30];
arr.sort(function(a, b) {
    return a - b;  // 升序排列
});
console.log(arr);  // [20, 30, 50, 60, 80]
```





## JavaScript 正则表达式

### 什么是正则表达式？

正则表达式是用于匹配字符串的模式，广泛应用于字符串搜索和替换操作。它可以用于检测某些模式的文本，或对文本进行复杂的处理。

### 语法

```js
/正则表达式主体/修饰符(可选)
```

```js
var patt = /twle/i
```

1. **/twle/i** 是一个正则表达式
2. **twle** 是一个 **正则表达式主体** (用于检索)
3. **i** 是一个 **修饰符** (搜索不区分大小写)。

### 常用字符串方法

正则表达式可以与字符串的内置方法 `search()` 和 `replace()` 结合使用：

1. **`search()`**：用于查找字符串中与正则表达式匹配的部分，返回匹配的起始位置。

```js
var str = "The best things in life are free";
var pos = str.search(/free/i);
console.log(pos);  // 输出：27
```

1. **`replace()`**：用于替换字符串中与正则表达式匹配的部分。

```js
var str = "The sky is blue";
var newStr = str.replace(/blue/i, "green");
console.log(newStr);  // 输出："The sky is green"
```

### 正则表达式修饰符

- **`i`**：忽略大小写。
- **`g`**：全局匹配，即查找所有匹配项，而不仅是第一个。
- **`m`**：多行匹配。

### 常用的正则表达式模式

- **方括号**：用于查找某个范围内的字符。
  - `[abc]`：匹配方括号中的任意字符。
  - `[0-9]`：匹配任意数字字符。
- **元字符**：特殊的字符，具有特定含义。
  - `\d`：匹配一个数字。
  - `\s`：匹配空白符（空格、制表符等）。
  - `\b`：匹配单词边界。
  - `.`：匹配除换行符外的任何字符。
- **量词**：
  - `n+`：匹配包含至少一个 `n` 的字符串。
  - `n*`：匹配零个或多个 `n`。
  - `n?`：匹配零个或一个 `n`。

### 使用 `test()`

`test()` 方法用于检测字符串是否匹配某个模式，返回 `true` 或 `false`。

```js
var patt = /e/;
console.log(patt.test("The best things in life are free!"));  // 输出：true
```

可以直接使用正则表达式而无需先定义变量：

```js
console.log(/e/.test("The best things in life are free!"));  // 输出：true
```

### 捕获异常：`throw` 语句

`throw` 语句允许抛出自定义错误，并结合 `try...catch` 捕获和处理错误。

```js
function myFunction() {
    var message, x;
    message = document.getElementById("message");
    message.innerHTML = "";
    x = document.getElementById("demo").value;
    try { 
        if(x == "")  throw "值为空";
        if(isNaN(x)) throw "不是数字";
        x = Number(x);
        if(x < 5)    throw "太小";
        if(x > 10)   throw "太大";
    }
    catch(err) {
        message.innerHTML = "错误: " + err;
    }
}
```



## JavaScript 计时事件

JavaScript 提供了两种常用的计时器方法，用于延时或定时执行代码：

| 方法            | 描述                         |
| --------------- | ---------------------------- |
| `setInterval()` | 按指定的时间间隔重复执行代码 |
| `setTimeout()`  | 在指定时间后执行一次代码     |

### 1. **`setInterval()` 方法**

`setInterval()` 方法用于在指定的时间间隔内重复执行某段代码，直到被取消。常用于轮询、动画等需要定时更新的场景。

#### 语法

```js
setInterval(function, milliseconds);
```

- **function**：要执行的代码或函数。
- **milliseconds**：每次执行的时间间隔（以毫秒为单位）。

#### 示例

以下代码每隔 3 秒弹出一次 `Hello`：

```js
setInterval(function() {
  alert("Hello");
}, 3000);
```

### 2. **`setTimeout()` 方法**

`setTimeout()` 方法用于在指定时间后执行一次代码。常用于延时执行某个操作。

#### 语法

```js
setTimeout(function, milliseconds);
```

- **function**：要执行的代码或函数。
- **milliseconds**：延迟的时间（以毫秒为单位）。

#### 示例

以下代码在 5 秒后弹出 `Hello`：

```js
setTimeout(function() {
  alert("Hello");
}, 5000);
```

### 3. **停止计时**

#### 取消 `setTimeout()`：**`clearTimeout()`**

`clearTimeout()` 方法用于取消通过 `setTimeout()` 创建的计时器。如果指定的时间尚未到达，`clearTimeout()` 可以阻止定时器执行。

#### 示例

```js
var timeoutID = setTimeout(function() {
  alert("This will never happen!");
}, 5000);

// 取消计时器
clearTimeout(timeoutID);
```

#### 取消 `setInterval()`：**`clearInterval()`**

`clearInterval()` 用于取消通过 `setInterval()` 设置的定时器。

#### 示例

```js
var intervalID = setInterval(function() {
  console.log("This will repeat every 2 seconds.");
}, 2000);

// 5 秒后停止重复执行
setTimeout(function() {
  clearInterval(intervalID);
}, 5000);
```

### **防抖思想**

在使用 `setInterval()` 时，有时我们会遇到不需要继续执行计时器的情况，这时候需要通过 `clearInterval()` 清除计时器。通常我们会在使用定时器之前先确保清除上一个未结束的计时器，以避免多次重复执行（防抖思想）。

#### 示例：确保只执行一个定时器

```js
var intervalID;

function startInterval() {
  // 如果已经存在计时器，先清除
  if (intervalID) {
    clearInterval(intervalID);
  }

  intervalID = setInterval(function() {
    console.log("Running...");
  }, 1000);
}

// 开始定时器
startInterval();
```



------

# HTML DOM对象

## 获取dom对象的样式方法：

通过使用 getComputedStyle 读取样式，通过 element.style 修改样式；

## 获取页面元素的常见方法：

**1、通过标签获取元素，返回一个数组**

```js
var li = document.getElementsByTagName('li');*//标签获取元素*`
li.getElementsByTagName('p');//获取所有li元素里的p标签
li[0].innerHTML;// 查看获取元素的内容
li[0].innerHTML = "content";//修改获取到标签中的内容
```

**2、通过id获取页面元素**

```js
var header = document.getElementById("header");//id获取元素
```

**3、通过class名字获取页面元素**

```js
var list = document.getElementsByClassName('list');//返回一个数组，通过下标访问文本
```

**4、通过CSS选择符方式获取页面元素**

```js
var str = document.querySelector('li');//querySelector：返回符合条件的第一个
var str1 = document.querySelectorAll('li');//全部返回，每个li都是一个对象
```

```js
document.body.lastElementChild	//最后一个元素
var ele = document.body.firstElementChild	//第一个元素
//获取当前标签的父元素
console.log(ele.parentElement);
//获取ele的子元素
var elements = ele.children;
//获取当前标签的上一个元素
var prev_ele = prev_ele.previousElementSibling;
//获取当前标签的下一个元素
var prev_ele = prev_ele.nextElementSibling;
// 以下方法可通过选择器获取元素
// H5提供的方法(比较便捷)
var ele_1 = document.querySelector(".box-1");
console.log(ele_1);// 标签 <div class="box box-1" id="demo1">1</div>
var ele_arr = document.querySelectorAll(".box-1");
console.log(ele_arr);// 标签数组 NodeList [div#demo1.box.box-1]
```

**往父元素添加子元素**

```js
// 往body标签添加元素
document.body.appendChild(divCreate);

// 往container标签添加元素(追加元素) [img1,img2]
var container = document.querySelector(".container");
container.appendChild(img1);
container.appendChild(img2);
```

```js
在指定标签之前插入元素
// 获取.container标签
var container = document.querySelector(".container");
// 获取.box-2标签
var box2 = document.querySelector(".box-2");
// 在.box-2标签之前插入一个div
var div = document.createElement("div");
div.className = "box";
// insertBefore
// 调用者: 父元素
// 参数: 1. 创建的元素  2.目标元素
// 返回值: 忽略
// 功能: 在指定标签之前插入一个相邻关系的元素
container.insertBefore(div, box2);
//删除元素
父元素.remveChild(指定s)
```

**在指定标签之后插入元素**

```js
<div class="container">
    <div class="box-1">1</div>
    <div class="box-2">2</div>
    <div class="box-3">3</div>
</div>

<script>
    // 获取.container标签(父元素)
    var container = document.querySelector(".container");
    // 获取.box-2标签
    var box2 = document.querySelector(".box-2");
    
    // 封装一个myInserAfter方法
    // 作用: 在指定标签之后插入一个相邻关系的元素
    function myInserAfter(parent,element,target){
        // 判断目标元素(target)是否为父元素(parent)的最后一个子元素
        if(target == parent.lastElementChild){
            // 往父元素追加一个元素
            parent.appendChild(element);
        }else {
            // 找到目标元素的下一个标签
            var nextEl = target.nextElementSibling;
            // 在nextEl之前插入一个元素
            parent.insertBefore(element,nextEl);
        }
    }

    // 创建一个div标签
    var demo = document.createElement("div");
    demo.className = "box";
    // 在2号盒子后插入一个标签
    myInserAfter(container,demo,box2);

</script>
```

## DOM事件对象

### 鼠标事件：

|                             属性                             |                  描述                  | DOM  |
| :----------------------------------------------------------: | :------------------------------------: | :--: |
|  [onclick](https://www.runoob.com/jsref/event-onclick.html)  |  当用户点击某个对象时调用的事件句柄。  |  2   |
| [oncontextmenu](https://www.runoob.com/jsref/event-oncontextmenu.html) | 在用户点击鼠标右键打开上下文菜单时触发 |      |
| [ondblclick](https://www.runoob.com/jsref/event-ondblclick.html) |  当用户双击某个对象时调用的事件句柄。  |  2   |
| [onmousedown](https://www.runoob.com/jsref/event-onmousedown.html) |            鼠标按钮被按下。            |  2   |
| [onmouseenter](https://www.runoob.com/jsref/event-onmouseenter.html) |     当鼠标指针移动到元素上时触发。     |  2   |
| [onmouseleave](https://www.runoob.com/jsref/event-onmouseleave.html) |        当鼠标指针移出元素时触发        |  2   |
| [onmousemove](https://www.runoob.com/jsref/event-onmousemove.html) |              鼠标被移动。              |  2   |
| [onmouseover](https://www.runoob.com/jsref/event-onmouseover.html) |          鼠标移到某元素之上。          |  2   |
| [onmouseout](https://www.runoob.com/jsref/event-onmouseout.html) |           鼠标从某元素移开。           |  2   |
| [onmouseup](https://www.runoob.com/jsref/event-onmouseup.html) |            鼠标按键被松开。            |  2   |

### 键盘事件：

|                             属性                             |            描述            | DOM  |
| :----------------------------------------------------------: | :------------------------: | :--: |
| [onkeydown](https://www.runoob.com/jsref/event-onkeydown.html) |    某个键盘按键被按下。    |  2   |
| [onkeypress](https://www.runoob.com/jsref/event-onkeypress.html) | 某个键盘按键被按下并松开。 |  2   |
|  [onkeyup](https://www.runoob.com/jsref/event-onkeyup.html)  |    某个键盘按键被松开。    |  2   |

### **表单事件**

```js
onfocus      //输入框获取焦点
onblur       //输入框失去焦点
onchange     //value属性值发生变化(触发1次)
oninput      //value属性值发生变化(触发N次)
```

### **滚动事件**

```js
onscroll  //滚动事件
onmousewheel  //鼠标滚轮滚动事件
```

### **窗口事件**

**调用者:window** 

```js
onresize  //窗口尺寸发生变化
onload    //页面加载事件
```

### 获取元素css属性：

**getComputedStyle**

```js
var div = document.querySelector("div");
// 调用获取元素样式对象的方法
// 调用者： window
// 参数： 参数1：dom对象 ,参数2：可选参数（伪类）
// 返回值： css样式对象
// 功能： 可以获取元素的css属性数据
var obj = getComputedStyle(div);
// 取值
console.log(obj.width);
console.log(obj.height);
console.log(obj.backgroundColor);
// 取值
var w = getComputedStyle(div)["width"];
console.log(w);// "100px"
console.log(parseInt(w));// 100
```

### **offset(偏移)** page(页面偏移)：

```js
// 获取.child标签
var child = document.querySelector(".child");
// 尺寸
console.log("实际宽度：",child.offsetWidth);// 112
console.log("实际高度：",child.offsetHeight);// 112
// 位置(父元素没有定位的情况)
console.log("距离浏览器左边间距：",child.offsetLeft);// 120
console.log("距离浏览器顶部间距：",child.offsetTop);// 70
// 偏移父元素
console.log(child.offsetParent);// body标签
// 位置(父元素有定位的情况)
// console.log("距离浏览器左边间距：",child.offsetLeft);// 30
// console.log("距离浏览器顶部间距：",child.offsetTop); // 20
// console.log(child.offsetParent);//  div.parent标签
console.log("页面:",evt.pageX);
console.log("页面:",evt.pageY);
```

### **client（可视区）**

```js
// 获取.box标签
var box = document.querySelector(".box");
// 尺寸（忽略了边框）
console.log("宽度：",box.clientWidth);// 104
console.log("高度：",box.clientHeight);// 64
// 边框(左/上)
console.log("上边框：",box.clientTop);// 20
console.log("左边框：",box.clientLeft);// 50
```

### **scroll（滚动）**

```js
// 获取相关的元素
var box = document.querySelector(".box");
// 尺寸 (计算时包含内容的大小)
console.log("宽度：",box.scrollWidth);// 220
console.log("高度：",box.scrollHeight);// 456
// 位置
console.log("滚动超出部分Y:",box.scrollTop);// 重点
console.log("滚动超出部分X:",box.scrollLeft);
// 绑定滚动事件(滚动行为发生就触发事件)
box.onscroll = function(){
    // console.log("test");
    console.log("滚动超出部分:",box.scrollTop);
}
```

### 页面可见区域

```
网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
scrollTop=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;其实document.documentElement.scrollTop
```

## Event**事件监听**

###  target事件属性            

获取触发特定事件的元素：

```js
alert(event.target);
```

**事件监听**

```js
dom.addEventListener(参数1，参数2，参数3)          
```

```js
// 事件源
var btn = document.querySelector(".btn");
// 事件监听
// btn.addEventListener(参数1，参数2，参数3)
// 参数1： 事件类型 参数2：匿名函数  参数3：可选参数（布尔值）
```

### **移除事件监听**

```js
// 获取按钮标签
var btn = document.querySelector(".btn");
var count = 0;
// 定义函数（代码块）
var foo = function(){
    count ++;
    console.log("test:"+count);

    if(count >= 5){
        // 当count大于等于5时，就移除事件监听
        btn.removeEventListener("click",foo);
    }
}
// 事件监听 
// btn.addEventListener("click" , function(){})
btn.addEventListener("click" , foo);
// 移除事件监听
// btn.removeEventListener("click",foo);
removeEventListener
```

事件绑定 ：

​       仅仅可以看见事件冒泡。

事件监听 ：

​        可以看见事件捕获，也可以看见事件冒泡。

阻止事件冒泡

```js
//阻止事件冒泡
event.stopPropagation();
```

阻止事件捕获

```js
// 阻止事件捕获
event.stopImmediatePropagation();
```

事件源

在哪个元素发生的事件

```js
event.target              
```

## **location 对象**

```JS
// 该对象关于浏览器地址栏信息
// console.log(location)
// 获取页面地址
var url = location.href; console.log(url);
// 设置指定的页面地址
// location.href = "./detail.html";
// 获取协议
console.log(location.protocol);// http
// 获取端口
console.log(location.port);// 5500
// 获取服务器地址
console.log(location.host);// 127.0.0.1:5500
// 获取主机地址
console.log(location.hostname);// 127.0.0.1 (本地IP) // 14.215.177.38
// 获取地址栏的参数
console.log(location.search);// ?username=admin&userpass=123123  如果想获取 admin 和 123123 这些数据,那么就需要结合字符串的API (split)
// 获取锚点标记
console.log(location.hash);//#login

// 刷新页面的方法   location.href="/"
// location.reload();

// 跳转页面的方法
// location.href="https://www.baidu.com"
// location="https://www.baidu.com"
// 替换当前地址栏路径
// location.replace("https://www.baidu.com");
```

## **naigator 对象**

**判断浏览器所在终端**

```JS
// 该对象关于浏览器信息
// console.log(navigator);
// 获取设备信息(终端) 
// PC 端           关键字  Windows
// IOS 端(移动端)   关键字 iPhone
// 安卓端(移动端)   关键字  Android
var _userAgent = navigator.userAgent;
// console.log(_userAgent); // Mozilla/5.0 (Windows NT 10.0; Win64; x64) 
// console.log(_userAgent); // Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X)
// console.log(_userAgent); //Mozilla/5.0 (Linux; Android 6.0.1; Moto G (4)) 
if(_userAgent.indexOf("Windows") >-1){
    console.log("这是PC端");
}else if(_userAgent.indexOf("iPhone") >-1){
    console.log("这是苹果手机端");
}else if(_userAgent.indexOf("Android") >-1){
    console.log("这是安卓手机端");
}
```

## **history** 对象

```js
// 返回上一页
btnBack.onclick = function(){
    // 调用history的API
    history.back();
}
// 下一页
btnNext.onclick = function(){
    // 调用history的API
    history.forward();
}
// 返回上一页
btnBack.onclick = function(){
     // 调用history的API
     history.go(-1);
}
```

## **screen**对象

关于设配屏幕

```js
// 屏幕的尺寸 (除了任务栏)
var w = screen.availWidth;
var h = screen.availHeight;
// 打印数据
// console.log({w:w,h:h});
console.log({w,h});// {w: 1920, h: 1040}

// 屏幕的尺寸 (包含任务栏)
var w2 = screen.width;
var h2 = screen.height;
 // 打印数据
console.log({w2,h2});//{w2: 1920, h2: 1080}
```



# jQuery 

入口函数

```js
$(function(){
  // jQuery代码在此处执行
});
```

弹窗效果 (如使用 SweetAlert)

```js
// 示例：SweetAlert 弹窗
swal("Hello world!");
```

## `$`符号

`$` 是 jQuery 的简写，可以用于选择元素和调用 jQuery 的各种方法。

## jQuery 选择元素的基本方法

```js
// 选择 .nav 标签并设置样式
$(".nav").css("background", "deepskyblue");

// 选择 .nav 标签的父元素
$(".nav").parent().css("height", "120px");

// 选择 .nav 标签的子元素 ul
$(".nav").children("ul").css("background", "#ccc");

// 选择 .nav 标签下所有的 li 元素
$(".nav").find("li").css("borderRadius", "20px");

// 选择 .active 标签的上一个元素
$(".active").prev().css("background", "blue");

// 选择 .active 标签前的所有同级元素
$(".active").prevAll().css("background", "blue");

// 选择 .active 标签的下一个元素
$(".active").next().css("background", "purple");

// 选择 .active 标签的所有兄弟元素
$(".active").siblings("li").css("background", "#fff");

// 选择 ul 列表中的第一个 li
$("ul li").first().css("background", "red");

// 选择 ul 列表中的最后一个 li
$("ul li").last().css("background", "yellowgreen");

// 通过索引选择元素
$("ul li").eq(1).css("background", "green");
$("ul li").eq(2).css("background", "blue");

// 选择倒数第二个 li
var len = $("ul li").length;
$("ul li").eq(len - 2).css("background", "lightblue");
$("ul li").eq(len - 3).css("background", "pink");

// 选择偶数下标的 li
$("li:even").css("background", "#ddd");

// 显示和隐藏元素
$("element").hide();
$("element").show();
```

## jQuery 控制元素的类名

```js
// 添加类名
$("div").eq(0).addClass("bg-red");

// 移除类名
$("div").eq(1).removeClass("bg-red");

// 切换类名（有则移除，无则添加）
$("div").eq(2).toggleClass("bg-blue");

// 判断是否包含某类名
if ($("div").eq(0).hasClass("bg-red")) {
  console.log("包含 bg-red 类名");
}
```

## jQuery 控制元素的文本内容

```js
// 获取元素的 HTML 内容
var htmlContent = $(".text-1").html();
console.log(htmlContent);

// 获取元素的纯文本内容
var textContent = $(".text-1").text();
console.log(textContent);

// 设置元素的 HTML 内容
$(".text-1").html("<b>天空突然下了点雨</b>");

// 设置元素的纯文本内容
$(".text-1").text("纯文本内容");

// 获取输入框的值
var inputValue = $(".form-1 input").val();
console.log(inputValue);

// 设置输入框的值
$(".form-1 input").val("输入内容...");
```

## jQuery 控制元素的标签属性

```js
// 设置元素的属性
$("div").eq(0).attr("class", "box");
$("img").attr("src", "https://www.baidu.com/img.png");

// 获取元素的属性值
var classValue = $("div").eq(0).attr("class");
console.log(classValue);

// 删除属性
$("img").removeAttr("src");

// 修改样式
$("div").css({ backgroundColor: "#f00", fontSize: "40px" });
```

## jQuery 控制表单元素的属性

```js
// 获取按钮的禁用状态
var isDisabled = $("input[type='button']").eq(0).prop("disabled");
console.log(isDisabled); // true or false

// 获取复选框的勾选状态
var isChecked = $("input[type='checkbox']").eq(0).prop("checked");
console.log(isChecked); // true or false

// 设置复选框的勾选状态
$("input[type='checkbox']").eq(0).prop("checked", true);

// 设置按钮的禁用状态
$("input[type='button']").eq(0).prop("disabled", false);
```

## jQuery 元素操作与事件绑定

### **添加元素**

```js
// 通过 append() 方法向元素末尾添加新元素
$("#container").append("<div class='box'>1</div>");
$("#container").append("<div class='box'>2</div>");
$("#container").append("<div class='box'>3</div>");

// 通过 prepend() 方法向元素开头添加新元素
$("#container").prepend("<div class='box'>4</div>");
$("#container").prepend("<div class='box'>5</div>");
$("#container").prepend("<div class='box'>6</div>");
```

### **移动元素**

```js
$(function(){
    // 获取目标元素
    var $el = $(".box-2");

    // 使用 appendTo() 将元素移动到指定容器
    $(".box-1 > div").appendTo($el);
});
```

### **常见事件类型**

```js
click       // 点击行为
mousedown   // 鼠标按下行为
mouseup     // 鼠标松开行为
mousemove   // 鼠标移动行为
mouseenter  // 鼠标移入行为
mouseleave  // 鼠标离开行为
mouseover   // 鼠标悬停行为
mouseout    // 鼠标移出行为
keydown     // 按下键盘按键行为
keypress    // 长按键盘按键行为
keyup       // 松开键盘按键行为
focus       // 获取焦点的行为
blur        // 失去焦点的行为
change      // 值改变后触发（一次）
oninput     // 值改变后多次触发（jQuery不能直接使用）
resize      // 窗口尺寸发生变化时触发
scroll      // 窗口发生滚动时触发
```

### **jQuery 事件绑定方法**

#### **bind() 方法**

```js
var count = 0;
$(".btn").bind("click mouseenter mouseleave", function(event){
    var origType = event.handleObj.origType;  // 获取事件类型

    if(origType == "click"){
        count++;
        console.log("click", count);
        if(count == 5){
            $(".btn").unbind(); // 解绑所有事件
        }
    } else if(origType == "mouseleave"){
        console.log("mouseleave");
    }
});
```

#### **on() 方法**

```js
function clickHandler1() {
    console.log('点击事件1的处理程序');
}

function clickHandler2() {
    console.log('点击事件2的处理程序');
}

// 绑定多个事件处理程序
$('#btn').on('click', clickHandler1);
$('#btn').on('click', clickHandler2);

// 取消特定事件处理程序
$('#cancelBtn').click(function () {
    $('#btn').off('click', clickHandler1);  // 取消特定的事件处理程序
});

// 绑定一次性事件
$('#btn').one('click', clickHandler1);

// 自动触发事件
setTimeout(function () {
    $('#btn').trigger('click');  // 自动触发事件
}, 3000);
```

## jQuery 动画效果

```js
// 淡入效果
$(".element").fadeIn(1000);

// 淡出效果
$(".element").fadeOut(1000);

// 切换淡入淡出效果
$(".element").fadeToggle(1000);

// 自定义动画效果
$("div").eq(0).animate({ opacity: 1, height: '200px' }, 2000, function(){
    console.log("动画完成");
});
```

# Git

Git 是一个分布式版本控制系统，常用于代码管理和团队协作开发。

### 1. **初始化仓库并配置远程仓库**

1. **初始化本地仓库**：

   ```bash
   git init
   ```

2. **添加远程仓库地址**：

   ```bash
   git remote add origin git@github.com:your-username/your-repo.git
   ```

3. **验证远程仓库地址**：

   ```bash
   git remote -v
   ```

4. **从远程仓库拉取分支**：

   ```bash
   git fetch
   git branch -a  # 查看所有分支
   ```

------

### 2. **本地提交代码并推送到远程仓库**

1. **添加文件到暂存区**：

   ```bash
   git add .
   ```

2. **提交到本地仓库**：

   ```bash
   git commit -m "提交说明"
   ```

3. **合并远程与本地代码**：

   ```bash
   git pull --rebase origin master
   ```

4. **推送代码到远程仓库**：

   ```bash
   git push origin master
   ```

------

### 3. **配置用户信息**

1. **配置全局用户信息**：

   ```bash
   git config --global user.name "你的名字"
   git config --global user.email "你的邮箱"
   ```

2. **查看用户信息**：

   ```bash
   git config user.name
   git config user.email
   ```

------

### 4. **常用 Git 操作命令**

- **查看仓库状态**：

  ```bash
  git status
  ```

- **保留工作区未提交的更改**：

  ```bash
  git stash
  ```

- **继续 `rebase` 操作**：

  ```bash
  git rebase --continue
  ```

- **强制推送**：

  ```bash
  git push --force origin <branch-name>
  ```

------

### 5. **分支操作**

1. **查看分支**：

   ```bash
   git branch -a
   ```

2. **切换分支**：

   ```bash
   git checkout <branch-name>
   ```

3. **合并分支**： 当前在 `master` 分支上，合并 `dev` 分支：

   ```bash
   git merge dev
   ```

4. **删除本地分支**：

   ```bash
   git branch -d <branch-name>
   ```

5. **删除远程分支**：

   ```bash
   git push origin :<branch-name>
   ```

------

### 6. **Git Bash 基础命令**

- **查看当前目录文件**：

  ```bash
  ls
  ```

- **进入指定路径**：

  ```bash
  cd ./文件夹路径
  ```

- **创建文件**：

  ```bash
  touch 文件名
  ```

- **删除文件**：

  ```bash
  rm 文件名
  ```

- **删除文件夹**：

  ```bash
  rm -rf 文件夹名
  ```

- **编辑文件**：

  ```bash
  vim 文件名
  ```

  - 按 `i` 进入编辑模式。
  - 编辑完后按 `ESC`，输入 `:wq` 保存并退出，或 `:q!` 强制退出不保存。

------

### 7. **`.gitignore` 文件**

`.gitignore` 文件用于指定哪些文件不应被 Git 跟踪。

- 示例 `.gitignore`：

  ```bash
  # 忽略 node_modules 文件夹
  node_modules/
  
  # 忽略所有的日志文件
  *.log
  
  # 忽略环境配置文件
  .env
  ```

------

### 8. **Git 分布式版本控制系统**

- **Git** 是分布式的，每个用户都有一个完整的版本库，适合多人分布式协作开发。
- **SVN** 是集中式的，所有用户共享一个中央版本库。

------

# webpack

**Webpack** 是一种现代 JavaScript 应用的静态模块打包工具。通过它，可以将项目中的资源（JavaScript、CSS、图片等）打包成适合在浏览器中运行的文件。

### 1. **创建 Webpack 项目**

1. **创建项目目录**：

   ```bash
   mkdir wp
   cd wp
   ```

2. **初始化 `package.json`**：

   ```bash
   npm init -y
   ```

### 2. **安装 Webpack 和 Webpack CLI**

1. **本地安装 Webpack**：

   ```bash
   npm install webpack --save-dev
   npm install webpack-cli --save-dev
   ```

2. **全局安装 Webpack**（可选）：

   ```bash
   npm install webpack -g
   npm install webpack-cli -g
   ```

### 3. **配置 Webpack**

1. **创建 Webpack 配置文件**： 在项目根目录创建 `webpack.config.js` 文件：

   ```bash
   touch webpack.config.js
   ```

2. **基础 Webpack 配置**：

```bash
const path = require('path');

module.exports = {
  entry: './src/index.js',  // 项目入口文件
  output: {
    filename: 'bundle.js',  // 打包后的文件名
    path: path.resolve(__dirname, 'dist')  // 打包文件存放路径
  },
  module: {
    rules: [
      {
        test: /\.css$/,  // 处理 CSS 文件
        use: ['style-loader', 'css-loader']
      }
    ]
  }
};
```

1. **创建入口文件**： 在根目录下创建 `src/index.js`，并在其中编写一些示例代码。

2. **执行打包命令**：

   ```bash
   webpack --config webpack.config.js
   ```

------

### 4. **处理 CSS 和预处理器**

1. **处理 CSS 文件**： 安装 `css-loader` 和 `style-loader`：

   ```bash
   npm install css-loader style-loader --save-dev
   ```

2. **处理 Less 文件**： 安装 `less-loader` 和依赖：

   ```bash
   npm install css-loader style-loader less less-loader --save-dev
   ```

3. **处理 Sass 文件**： 安装 `sass-loader` 和依赖：

   ```bash
   npm install css-loader style-loader sass sass-loader node-sass --save-dev
   ```

------

### 5. **分离 CSS**

使用 `mini-css-extract-plugin` 将 CSS 文件从 JS 中分离出来：

1. **安装插件**：

   ```bash
   npm install mini-css-extract-plugin --save-dev
   ```

2. **修改 Webpack 配置**：

```bash
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  // 其他配置项
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader']  // 使用插件分离 CSS
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'styles.css',  // 分离后的 CSS 文件
    })
  ]
};
```

------

### 6. **处理图片**

1. **安装图片加载器**：

   ```bash
   npm install file-loader url-loader --save-dev
   ```

2. **修改 Webpack 配置**：

```json
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif)$/,  // 处理图片文件
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,  // 小于 8KB 的图片将被转为 base64
              name: '[name].[ext]',
              outputPath: 'images/',  // 输出路径
            },
          },
        ],
      },
    ],
  },
};
```

------

### 7. **Webpack Dev Server**

Webpack Dev Server 提供了一个本地开发服务器，支持实时重新加载（Live Reload）功能。

1. **安装 `webpack-dev-server`**：

   ```bash
   npm install webpack-dev-server --save-dev
   ```

2. **修改 `package.json`** 中的 `scripts`：

   ```json
   "scripts": {
     "start": "webpack serve --open"
   }
   ```

3. **运行开发服务器**：

   ```bash
   npm run start
   ```

服务器会自动打开浏览器并运行在 `localhost:8080` 上，支持自动刷新。

# Ajax

```javascript
$("#email").blur(function () {
        // 获取用户输入的信息
        let email = $(this).val().trim();
        // 2. 后台接受请求，然后接受传递过来的 用户名
        let xhr = new XMLHttpRequest(); // XML + Http + Request
        // 在地址栏的后面加上?key=value通过这种方式可以给服务器传递数据。这种请求方式我们叫做get传参
        // 如果有多个参数要传递，可以使用 ?key=value&key1=value1&key2=value2;
        let url = 'http://localhost/03/02.php?email=' + email; // 地址接受请求，去校验用户名是否可以使用
        
        xhr.open('get', url);
        // console.log(xhr.readyState==1);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                console.log('服务器返回的数据：===>', xhr.responseText);
                if (xhr.responseText == 1) {
                    // 记录在数据库存在，不可以注册
                    $(".error").show();
                    $(".success").hide();

                } else if (xhr.responseText == 0) {
                    // 记录在数据不存在，可以注册
                    $(".error").hide();
                    $(".success").show();
                }
            }
        }
        xhr.send();
    });

笔记：
let xhr = new XMLHttpRequest()
XMLHttpRequest() 对象是 AJAX 的关键。

ajax.open(1 :get post,2 :地址值,3 :boolear 异步/同步)

onreadystatechange Ajax-服务器响应 (xhr对象的状态在做一些改变时，这个事件会一直监视着它)
.readyState 属性存留 XMLHttpRequest 的状态。
0: 请求未初始化
1: 服务器连接已建立
2: 请求已接收
3: 正在处理请求
4: 请求已完成且响应已就绪
当status的值是200的时候，表示服务器已经正确的处理请求以及给出响应

Ajax.send()
作用：发送请求
语法：xhr.send(body)
body:请求主体
如果没有请求主体，body位置处为null(get)
如果有请求主体，则放请求主体数据到body位置(post)

.responseText  后台返回值
```

```php
<?php
    // 接受请求，然后校验用户名是否可以使用
    // 想办法接受到前端传递的参数
    // php里面存在一个特殊的变量 魔术变量
    $get = $_GET;// 里面包含了get请求传递的参数
    // echo $get
    // array(1) {
    //     ["email"]=>
    //     string(14) "gogery@163.com"
    //     }

    // var_dump($get['email']); 
    $email = $_GET['email'];
    // 这里应该根据邮箱去查询数据库，检测数据库里面是否 存在 gogery@163.com 这个邮箱的记录，如果存在，则不能注册 不存在才可以注册
    // 伪代码
    // 1. 链接数据库
    // mysql_connect();
    // 2. 发送查询语句
    // $sql = 'select * from users where email = ' . $email;
    // mysql_query($sql);
    // 3. 数据库返回查询的结果
    
    // 4. 根据结构做逻辑判断
    // echo '请求达到了，传递的参数是：' . $get['email'];
    echo 1; // 代表是存在，存在就不可以注册；    
    // echo 0; // 代表是不存在，不存在可以注册；
?>
```

## post 方法

```js
$(function () {
        $("#subBtn").click(function () {
            var username = $("#username").val().trim();
            var pwd = $("#pwd").val().trim();

            if (username == '' || pwd == '') {
                alert('信息不合法');
                return;
            }

            // 合法 完成ajax的提交
            var url = 'http://localhost/07/03-login.php';
            var xhr = new XMLHttpRequest();							创建对象
            xhr.open('post', url);									open post方法，url是php地址值
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {							判断交互结束
                    var obj = JSON.parse(xhr.responseText);			通过json方法转换获取到的数据//JSON.parse方法
                    // console.log(xhr.responseText);
                    if (obj.code == 0) {
                        // 合法注册
                        alert('登录成功！');
                        // 前往登录页面
                        location.href = 'http://localhost/07/04-profile.php';

                        return;
                    } else if (obj.code == 1001 || obj.code == 1002) {
                        alert('系统繁忙中！');
                        return;
                    } else if (obj.code == 1006 || obj.code == 1007) {
                        alert('用户名不存在或者是密码不正确');
                        return;
                    }

                }
            }

            // post提交，需要设置请求头信息
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');			设置请求头
            var postData = 'username=' + username + '&pwd=' + pwd;
            xhr.send(postData);										send传递值给后端
            return false;
        });
```

## json

```php
// json_encode($userInfo) --- 把对象序列化为 字符串，这种格式的字符串和js语境下的对象格式一致，我们叫做 json。
// 下面在整体：我们拿json去填充一个函数。这种称之为 jsonp技术。
echo $fn . '(' . json_encode($userInfo) . ')';

var obj = JSON.parse(xhr.responseText);
```

# SQL语句

## 增删改查

#### 1. **增加数据（CREATE）**

`INSERT INTO` 语句用于向数据库表中插入新记录。

**语法**：

```sql
INSERT INTO tableName (字段1, 字段2, ...) VALUES (值1, 值2, ...);
```

**示例**：

```sql
INSERT INTO goods VALUES (null, 'iPhoneX', 3400, 'https://api.cn/imgs/1.jpg', 4500, '手机还不错');
```

#### 2. **删除数据（DELETE）**

`DELETE` 语句用于删除表中的现有记录。

**语法**：

```sql
DELETE FROM tableName [WHERE 条件];
```

**示例**：

```sql
-- 删除表中所有记录
DELETE FROM goods;

-- 删除指定条件的记录
DELETE FROM goods WHERE id = 5;
DELETE FROM goods WHERE goodsName = 'iPhone';
```

#### 3. **修改数据（UPDATE）**

`UPDATE` 语句用于修改表中的现有记录。

**语法**：

```sql
UPDATE tableName SET 字段1 = 新值1, 字段2 = 新值2 [...] WHERE 条件;
```

**示例**：

```sql
-- 更新表中所有记录的 goodsName
UPDATE goods SET goodsName = '新手机';

-- 更新指定条件的记录
UPDATE goods SET price = 900, goodsNumber = 1000 WHERE id = 8;
```

#### 4. **查询数据（READ/SELECT）**

`SELECT` 语句用于从数据库中查询数据。

**语法**：

```sql
SELECT 列1, 列2, ... FROM tableName [WHERE 条件] [ORDER BY 列名 ASC|DESC];
```

**示例**：

```sql
-- 查询表中所有记录
SELECT * FROM goods;

-- 查询指定条件的记录
SELECT id, goodsName, price FROM goods WHERE goodsName = 'iPhoneX';

-- 按照 id 列升序排序查询
SELECT * FROM goods ORDER BY id ASC;

-- 查询表中的总记录数
SELECT COUNT(*) FROM goods;
```

# Animate.css   Wow.js

## 1. **安装 Animate.css 和 WOW.js**

首先，通过 npm 安装这两个库：

```bash
npm install animate.css --save
npm install wowjs --save
```

------

## 2. **在 Vue 项目中使用**

在 Vue 项目中，需要引入这两个库，并初始化 WOW.js。

### 引入 Animate.css 和 WOW.js

```js
import 'animate.css';
import WOW from 'wowjs';
```

### 在 Vue 中初始化 WOW.js

在 Vue 的 `mounted` 生命周期方法中初始化 WOW.js：

```js
mounted() {
  new WOW.WOW({
    boxClass: 'wow',  // 触发动画的元素 CSS 类名
    animateClass: 'animate__animated',  // 动画效果的类名
    offset: 0,  // 距离浏览器底部多少距离时触发动画
    mobile: true,  // 是否在移动设备上启用动画
    live: true  // 页面元素更新时是否重新检测
  }).init();
}
```

### 将 WOW.js 注册为 Vue 实例的全局变量

如果需要在多个组件中使用 WOW.js，可以将它注册为 Vue 的全局变量：

```js
import WOW from 'wowjs';
Vue.prototype.$wow = WOW;
```

在各个组件中可以使用 `this.$wow` 来初始化。

------

## 3. **使用 WOW.js 和 Animate.css**

在 HTML 元素上添加 `wow` 类和 `animate__` 系列的类名，即可使用 Animate.css 动画效果。

```html
<div class="wow animate__animated animate__bounce">
  我会随着页面滚动动画！
</div>
```

------

## 4. **自定义动画参数**

你可以通过 `data-wow-` 系列的自定义属性调整动画的行为。

- **`data-wow-duration`**：设置动画的持续时间（例如 `2s` 或 `500ms`）。
- **`data-wow-delay`**：设置动画开始前的延迟时间。
- **`data-wow-offset`**：触发动画的距离，基于元素距离浏览器底部的距离。
- **`data-wow-iteration`**：设置动画的重复次数。

### 示例：

```html
<div class="wow animate__animated animate__fadeIn" 
     data-wow-duration="2s" 
     data-wow-delay="1s" 
     data-wow-offset="100" 
     data-wow-iteration="infinite">
  这是一个带有自定义动画参数的元素。
</div>
```

------

## 5. **配置 ESLint 规则**

如果你在项目中遇到未使用的变量警告，可以通过以下方式在 `.eslintrc.js` 配置中关闭 `no-unused-vars` 规则：

```js
module.exports = {
  rules: {
    "no-unused-vars": "off"
  }
};
```

# Vue

## 新建vue项目

```
vue create 项目名
按空格选择取消
(*)Choose Vue version
(*)Babel
(*)Router
(*)CSS Pre-processors

2.x

Y

scss

In dedicated config files

N

$ winpty vue.cmd create test
```

### 使用vant

```js
自动按需引入组件 (推荐)
babel-plugin-import 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。
npm i babel-plugin-import -D    或者   cnpm i babel-plugin-import -D

在 babel.config.js 中配置
module.exports = {
    plugins: [
        ['import', {
        libraryName: 'vant',
        libraryDirectory: 'es',
        style: true
        }, 'vant']
    ]
};
//浏览器rem适配
按需引入
    在 main.js 导入vant的组件
    
    lib-flexible 用于设置 rem 基准值
    npm i lib-flexible -D   或者   cnpm i lib-flexible -D

在根目录下创建 postcss.config.js 文件
module.exports = {
    plugins: {
        'postcss-pxtorem': {
        rootValue: 37.5,
        propList: ['*'],
        },
    },
};
在main.js 导入 
import 'lib-flexible/flexible'

运行之后 报错 
Syntax Error: Error: PostCSS plugin postcss-pxtorem requires PostCSS 8.
需要降低版本
cnpm i postcss-pxtorem@5.1.1 -D
```

```
Vue 
el 挂载点
data 数据
methods 添加方法
computed 属性计算（值的计算）
watch 属性侦听（观察值的变化）
filters 过滤器（针对数据做匹配/过滤）
Vue.fiter("名称",函数)
```

## vue的生命周期

```js
1、beforeCreate: 在实例的data数据生成之前执行, 此时还没有获取vue编译范围的元素, 只在初始化执行一次
2、created: 在实例的data数据生成之后执行, 此时还没有获取vue编译范围的元素, 只在初始化执行一次, 可在这个钩子发起ajax请求
3、beforeMount: 在实例的data数据生成之后, 此时获取vue编译范围的元素, 但是视图没有绑定vue的data的数据, 只在初始化执行一次
4、mounted: 在实例的data数据生成之后, 此时获取vue编译范围的元素, 视图已经绑定vue的data的数据, 只在初始化执行一次
5、beforeUpdate: data的数据同步到视图之前执行
6、updated: data的数据同步到视图之后执行
7、beforeDestroy销毁之前, 侦听器, 事件监听都销毁了
8、destroyed, 销毁之后

vue的设计模式MVVM
      M: Model(模型) ==> 定义数据,
      V: View(视图) ==> 页面 ==> 显示数据
      VM: View Model(视图模型) ==> 将Model同步到View, 将View的输入数据同步到Model

```

## 自定义组件

```js
//全局自定义指令 
Vue.directive('focus', {
	// el：指令所绑定的元素，可以用来直接操作 DOM。
	//binding：一个对象，包含以下 property：
    inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用
       el.focus();
    }
});

//局部自定义指令
directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        },
        color: { // 为元素设置指定的字体颜色
          bind(el, binding) {
            el.style.color = binding.value;
          }
        }
	}

1、 输入框自动聚焦
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
<input v-focus>
```

## 指令

```vue
// vue  v-xxx  以 v- 这种命名的标记 就是vue指令

<!-- v-model 主要用于操作表单元素的值-->
<input type="text" v-model="message">

  v-bind:属性 简写为 :属性
  v-on:事件类型 简写为 @事件类型
  v-slot:插槽名称 简写为 #插槽名称
  v-for
  v-if
  v-else-if
  v-else
  v-show
  v-pre: 无需编译  <div v-pre>{{变量}}</div>
  v-cloak
  v-text <div v-text="变量"></div> 等价于 插值表达式 <div>{{变量}}</div>
  v-html <div v-html="变量"></div>
  v-once
  v-model
```

### v-cloak

```vue
<!-- 闪烁 -->
```

### v-bind控制元素属性：

```vue
<!-- v-bind 指令-->
<div id="app">
    <!-- v-bind="JS表达式" -->
    <!-- JS表达式：一行代码，甚至一个变量。 -->
    <!-- 绑定属性 -->
    <div v-bind:class="cName">3</div>
    <!-- 简写 -->
    <div :class="cName">4</div>
    <!-- 在标签属性中记录多个变量 -->
    <div v-bind:class="[cName,aaa]">5</div>
    <div v-bind:class="[cName,num==1?aaa:'']">6</div>
    <div v-bind:class="[cName,num==1?'active':'']">7</div>
</div>
```

### **v-on **控制事件：

```vue
<div id="app">
    <button v-on:click="myClick">按钮（点击）</button>
    <!-- 简写 -->
    <!-- @ 修饰符号取代 v-on:   -->
    <button @click="myClick('参数')">按钮（点击）</button>
    <button v-on:mouseenter="myEnter">按钮（移入）</button>
</div>

<script>
    new Vue({
        el: "#app", // 挂载点(容器)
        methods: { // 添加方法（当前对象用于添加程序的方法）
            foo() {console.log("test")},
            myClick(){console.log("click")},
            myEnter(){console.log("mouseenter")}
        }
    })
</script>
```

### v-for   列表渲染（循环）:

```vue
<!-- v-for="JS代码" -->
<!-- item 代表数组的每一项数据 -->
<!-- index 代表数组的索引值 -->
<ul>
    <li v-for="item,index in arr" v-bind:key="item">{{index}}-{{item}}</li>
</ul>
```

### v-if 添加

```vue
<!-- v-if:true ==> 添加节点，false ==> 移除节点-->
<div v-if='code==="a"'>a</div>
<div v-else-if='code===b'>b</div>
```

### v-show	隐藏

```vue
<!-- v-show:true ==> 显示节点，false ==> 隐藏节点-->
```

### v-model表单 双向数据绑定

```vue
<input v-model=''>
```

### v-html

```vue
<!--v-text  ==  {{}}
v-html-->
```

### v-once

```vue
<!--v-once:只会编译一次
```

### v-pre:

```vue
<!--无需编译
```

## 属性

### **属性计算 computed**

```vue
<div id="container">
    <h1>{{message}}</h1>
    <h1>{{mytitle}}</h1>
    <p>{{mycontent}}</p>
    <div>
        <input type="text" v-model="a">
        <span>+</span>
        <input type="text" v-model="b">
        <span>=</span>
        <input type="text" v-model="c">
    </div>
</div>

<script>
new Vue({
    el: "#container",
    data: {a: 100,b: 200},
    // prop 属性计算
    // 计算某个属性的结果时，会有函数作用域
    // 在函数作用域中，计算，处理逻辑....
    // 编写时，作用域需要有返回值，返回值就是需要渲染的结果
    
    computed: {
        message(){return 123},
        mytitle(){return "我的标题"},
        mycontent(){return "我的内容"},
        c() {// 此处是个函数（意味着可以编写很多实现功能的代码）
            this.a = this.a - 0 ;
            this.b = this.b - 0 ;
            return this.a + this.b;
        }
    }
})
</script>




```

### **属性侦听 watch** 

```vue
<div id="container">
    <h1>{{message}}</h1>
    <button 
        v-on:click="sub">点击按钮减掉一个字符</button>
    <h2>长度: <span> {{len}}</span>个</h2>
    <h1 style="color:red;">{{v1}}</h1>
    <p>{{res}}</p>
</div>
<script>
// 创建Vue实例
new Vue({
    el: "#container",
    data: {message:"这是一个坏消息",len: 7,v1:"",res:""},
    // 侦听器
    // 观察数据的变化
    // 此处的函数需要数据发生变化才会执行（可以说数据不变化函数不执行）
    watch: {
        message(){
            console.log("test");
            this.len = this.message.length;
        },
        // 属性侦听时 执行的这个函数，可以接收传递的参数
        v1(newV,oldV){
            // newV  这是新的值（赋值时）
            // oldV  这是旧的值 (原来的)
            console.log({newV,oldV});
            // 额外添加的属性 记录当前V1的变化
            // this.res = oldV + newV;
        }
    },
    // 添加方法
    methods: {
        sub(){
            if(this.message.length == 0){return false}   
            // 记录被减掉的字符
            this.v1 += this.message.slice(0,1);
            // 每次点击按钮 就会减掉一个字符
            this.message = this.message.slice(1);
        }
    }
})
</script>
```

### 过滤器（filters）

```vue
<div >
    <h1>{{ cloths | getSex }}</h1>
</div>

<script>
    new Vue({
    	el: "#container",
        data:{
            
        }
        filters:{
        	getSex(str){
        		let res ="";
        		if(str.includes("红色")){
                    res = "她可能是女生"
                }
                return res;
    		}
    	}
    })
</script>
```

### **事件修饰符号**

```vue
<!-- v-on:keydown.enter -->
<!-- @keydown.enter = "myKeyDown"  按回车按键-->
<!-- @keydown.a = "myKeyDown" -->
<!-- @keydown.alt = "myKeyDown" -->
<!-- @keydown.space = "myKeyDown"  空格按键-->
组合按键
   .ctrl.y
   .shift.y
   .alt.y
   .ctrl.shift.y
   .ctrl.alt.y
   .ctrl.shift.alt.y

事件处理
  修饰符
  .stop ==> 阻止事件冒泡
  .prevent ==> 阻止浏览器默认行为
  .capture ==> 捕获阶段触发事件
  .self ==> 触发自身事件
  .once ==> 一次性事件(事件只会触发一次)
  .passive ==> 不会等待onscroll停下再触发, 提高移动端的onscroll的流畅度
```

```vue
<!-- 嵌套关系的标签-->
<!-- 
    event.stopPropagation() JS原生
    @click.stop="myClick"  阻止事件冒泡  VUE
 -->
<!-- <div @click="myClick('div')"class="div">
        <ul @click.stop="myClick('ul')"class="ul"> 
               <li @click.stop="myClick('li')" class="li"></li>
        </ul>
</div> -->
```

```vue
<!-- @click.self="myClick('ul')"  点击触发事件源自身的事件（不影响其他元素的事件）-->
<!-- <div  @click.self="myClick('div')" class="div">
            <ul @click.self="myClick('ul')" class="ul"> 
                    <li @click.self="myClick('li')" class="li"></li>
            </ul>
 </div> -->
```

```vue
<!-- 
    监听事件捕获
    从外 div --- ul --- li 到内
    @click.capture="myClick('div')"
    监听事件捕获 仅仅在div标签上触发事件
    @click.capture.self="myClick('div')"
  -->
<div @click.capture="myClick('div')" class="div">
      <ul @click.capture="myClick('ul')" class="ul"> 
            <li @click.capture="myClick('li')" class="li"></li>
      </ul>
</div>
```

## 插槽

```js
父子组件通讯
data数据只能从父组件流向子组件
子组件触发自定义事件通知父组件更改数据

组件的props的对象写法
props: ['属性1', '属性2']
props: {
     属性1: {
     //String, Number, Boolean, Array, Object
     //type: String
     type: 属性的类型,
     default: 默认值
},
          
    <my-box>
      <template #c="mydata">
        <child :myuser="mydata.user"><child>
        <div>{{mydata.animal}}</div>
      </template>
      
      <template #default> 无名插槽, #default可写可不写
        <div></div>
      </template>
      
    </my-box>

    my-box的内部结构
    <div>
      <slot name="c" :user="数据" :animal="数据"><slot>
      <h1></h1>
      <slot></slot>
    </div>
```

## vue脚手架

```js
安装Node.js
安装vue脚手架
npm i @vue/cli -g
cnpm i @vue/cli -g

  创建vue项目
  vue create 项目名称

  分析vue脚手架创建的项目
  vr
  |- node_modules 保存第三方依赖包目录
  |- public 公共文件目录
    |- favicon.ico 浏览器的标签显示的图标
    |- index.html vue项目根页面(宿主页面)
  |- src 开发目录
    |- assets 静态文件目录(存在图片、视频、音频....)
    |- components 公共组件目录
    |- router 路由配置目录
    |- views 视图目录(配置路由的组件)
    |- App.vue 根组件
    |- main.js vue项目的入口文件
  |- .browserslistrc 浏览器配置
  |- .gitigonre git仓库的忽略文件配置
  |- babel.config.js 将es6转es5
  |- jsconfig.json vue配置, src路径的别名@, 输出目标js为es5...
  |- package.json 项目描述文件
  |- README.md 项目说明
  |- vue.config.js vue打包配置
  
   声明式导航
    <router-link to="路径"></router-link>

    编程式导航
      this.$router.push('路径')
      this.$router.push({path: '路径'})
      this.$router.push({name: '路由名称'})

    携带参数
      路由参数 定义路由参数 /home/:参数名1/:参数名2
        this.$router.push({name: '路由名称', params: {参数名1: 值, 参数名2: 值}})

      查询参数
        this.$router.push({name: '路由名称', query: {参数名1: 值, 参数名2: 值}})

返回上一级
this.$router.go(-1);
```

### axios: 基于promise封装的ajax

```js
安装axios
npm i axios --save

安装vue-axios
npm i vue-axios --save
  
this.axios({
      method: 'get',
      url: '',
      //get请求的参数
      params: {

      }
}).then().catch()

this.axios({
      method: 'post',
      url: '',
      //post请求的参数
      data: {

      }
}).then().catch()
```

### 路由守卫

```js
路由守卫
    两个全局守卫
      全局前置守卫 beforeEach
      全局后置守卫 afterEach

    路由独享守卫
      进入路由之前：beforeEnter

    组件内守卫
      进入组件之前: beforeRouteEnter
      组件离开之前: beforeRouteLeave
      组件路由参数发生改变之前: beforeRouteUpdate
      
    路由的元信息
    meta

完整的地址
    http:// ==> 协议
    www.kangliuyong.com ==> 域名
    10000 ==> 端口
    index ==> 文件夹
    home.html ===> 文件
    ?key=1&value=2&a=100 ==> 查询参数
    #abc ==> 哈希(散列, 信息片段)

vue的路由模式
    浏览器的历史模式
    hash(哈希)模式
    路由模式
    mode: 'history | hash'
```

### 缓存组件

```js
    keep-live: 缓存组件, 如果组件被访问过, 再次访问组件时, 不会重新实例化组件
    include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
    exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
    max - 数字。最多可以缓存多少组件实例。

    <keep-live include="a"></keep-live>
    <keep-live include="a,b"></keep-live>
    <keep-live :include="[a,b]"></keep-live>
    <keep-live :include="/a|b/"></keep-live>

    <keep-live exclude="a"></keep-live>
    <keep-live exclude="a,b"></keep-live>
    <keep-live :exclude="[a,b]"></keep-live>
    <keep-live :exclude="/a|b/"></keep-live>

    <keep-live :include="[a,b,c]" max="2"></keep-live>
```

### 动画

```js
动画
<transition name="slide"></transition>

.slide-enter-active, .slide-leave-active {
        transition: left .5s;
}
.slide-enter, .slide-leave-to {
      left: 100px;
}

<transition></transition>配合animate.css

安装animate.css
npm i animate.css --save
```

## Vuex

### Vuex 的五大核心理念

1. **State**：存储应用的全局状态，类似于 Vue 组件中的 `data`。
2. **Mutations**：用于同步修改 `state` 的方法，类似于 Vue 组件中的 `methods`（不处理异步操作）。
3. **Actions**：用于提交 `mutations`，可以包含异步操作，类似于 Vue 组件中的 `methods`（处理异步操作）。
4. **Getters**：用于计算和过滤 `state` 中的数据，类似于 Vue 组件中的 `computed`。
5. **Modules**：用于将 `state`、`mutations`、`actions`、`getters` 分模块管理，适合大型项目。

------

### 辅助函数

Vuex 提供了几个辅助函数，简化访问 `state`、`mutations`、`actions` 和 `getters` 的写法：

- **`mapState()`**：简化从 `state` 中获取数据。
- **`mapMutations()`**：简化调用 `mutations` 方法。
- **`mapActions()`**：简化调用 `actions` 方法。
- **`mapGetters()`**：简化获取 `getters` 计算结果。

**示例**：

```js
import { mapState, mapMutations, mapActions, mapGetters } from 'vuex';

// 在组件中使用 mapState、mapMutations、mapActions、mapGetters
export default {
  computed: {
    ...mapState(['all_information', 'body']),  // 获取 state 中的数据
    ...mapGetters(['filterCount', 'product500'])  // 获取 getters 的计算结果
  },
  methods: {
    ...mapMutations(['saveall_information']),  // 提交 mutations 修改 state
    ...mapActions(['addAnimal', 'changeTitle'])  // 提交 actions 进行异步操作
  }
}
```

------

### Vuex Store 结构

```js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {  // 全局状态
    all_information: [],
    all_durati: [],
    body: 123,
  },
  getters: {  // 计算属性和过滤数据
    filterCount(state) {
      return state.all_durati.filter(v => v >= 90);
    },
    product500(state) {
      return state.all_information.filter(item => item.price >= 500);
    },
  },
  mutations: {  // 同步操作，修改 state
    saveall_information(state, pathName) {
      state.all_information = pathName;
    },
  },
  actions: {  // 异步操作
    addOneAnimal({ commit }, value) {
      return new Promise((resolve, reject) => {
        // 模拟异步操作
        setTimeout(() => {
          commit('saveall_information', value);
          resolve('成功添加');
        }, 1000);
      });
    },
  },
  modules: {  // 分模块管理
  }
});
```

------

### 在组件中使用 Vuex

#### 1. **获取全局状态**：

```js
this.$store.state.all_information;
```

#### 2. **修改全局状态**：

```js
this.$store.commit('saveall_information', data);
```

#### 3. **触发异步操作**：

```js
this.$store.dispatch('addOneAnimal', value).then(result => {
  console.log(result);
});
```

------

### Vuex Getters 和 Actions

#### Getters 示例

Getters 用于从 `state` 中派生出一些需要计算的状态，类似于 Vue 组件中的 `computed`。

```js
getters: {
  filterCount(state) {
    return state.all_durati.filter(v => v >= 90);
  },
  ...mapGetters(['filterCount'])
}
```

#### Actions 示例

Actions 用于处理异步操作，并在操作完成后提交 `mutations` 来修改状态。

```js
actions: {
  addOneAnimal({ commit }, value) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        commit('saveall_information', value);
        resolve('数据已添加');
      }, 1000);
    });
  }
}
```

# Vue3

## 1. **Vue 3 组合式 API：`ref` 和 `reactive`**

在 Vue 3 的组合式 API 中，`ref` 和 `reactive` 是处理不同类型数据的核心函数。

- **`ref`**：用于处理基本类型的数据（如字符串、数字、布尔值等）。
- **`reactive`**：用于处理复杂的数据类型（如对象和数组）。

```js
import { ref, reactive } from 'vue';

export default {
  setup() {
    const count = ref(0); // 基本数据类型
    const user = reactive({ name: 'Alice', age: 25 }); // 复杂数据类型

    return {
      count,
      user
    };
  }
};
```

------

## 2. **全局方法注册**

在 Vue 3 中，可以通过 `app.config.globalProperties` 添加全局方法。这些方法可以在应用的任意组件中调用。

```js
import { createSSRApp } from 'vue';
import App from './App.vue';

const app = createSSRApp(App);

app.config.globalProperties.$getImgSrc = function(img) {
  return `https://welfare.juguzi.com/images/${img}`;
};

// 组件中调用
export default {
  setup() {
    const { proxy } = getCurrentInstance();
    const imgSrc = proxy.$getImgSrc('image.jpg');
    return { imgSrc };
  }
};
```

------

## 3. **父子组件通讯**

在 Vue 中，父子组件之间的数据传递通过 **`props`** 和 **`emit`** 实现。

##### 父组件向子组件传递数据（`props`）：

- **父组件** 使用 `props` 向子组件传递数据。
- **子组件** 通过 `props` 接收来自父组件的数据。

**父组件**：

```vue
<template>
  <div>
    <Article :msg="name"></Article>
  </div>
</template>

<script>
import Article from '@/components/Article.vue';
export default {
  components: { Article },
  setup() {
    const name = '渐行渐远渐无书，水阔鱼沉何处问';
    return { name };
  }
};
</script>
```

**子组件**：

```vue
<template>
  <div>
    {{ msg }}
    {{ info }}
  </div>
</template>

<script>
export default {
  props: ['msg'],
  setup(props) {
    return {
      info: props.msg
    };
  }
};
</script>
```

##### 子组件向父组件发送数据（`emit`）：

**子组件**：

```vue
<template>
  <button @click="sendToParent">点击传数据</button>
</template>

<script>
export default {
  setup(_, { emit }) {
    const sendToParent = () => {
      emit('updateMessage', '来自子组件的数据');
    };
    return { sendToParent };
  }
};
</script>
```

**父组件**：

```vue
<template>
  <ChildComponent @updateMessage="handleUpdate" />
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: { ChildComponent },
  setup() {
    const handleUpdate = (msg) => {
      console.log('父组件接收到消息:', msg);
    };
    return { handleUpdate };
  }
};
</script>
```

------

## 4. **`getCurrentInstance`**

`getCurrentInstance` 是 Vue 3 中用于获取当前组件实例的一个方法，常用于访问实例的代理对象（`proxy`）和全局方法。

```js
import { getCurrentInstance } from 'vue';

export default {
  setup() {
    const { proxy } = getCurrentInstance();
    proxy.$getImgSrc('example.jpg');  // 访问全局方法

    return {};
  }
};
```

# 微信小程序

## 1. **生命周期**

### 应用生命周期（写在 `app.js` 中）

- **onLaunch**: 应用初始化完成时触发（只触发一次）
- **onShow**: 小程序从后台进入前台时触发，可以多次触发
- **onHide**: 小程序从前台进入后台时触发
- **onError**: 当小程序运行错误时触发

```js
App({
  onLaunch() {
    console.log('App Launched');
  },
  onShow() {
    console.log('App Shown');
  },
  onHide() {
    console.log('App Hidden');
  },
  onError(error) {
    console.log('App Error: ', error);
  }
});
```

### 页面生命周期（写在 `Page({})` 中）

- **onLoad**: 页面加载时触发
- **onShow**: 页面显示时触发
- **onReady**: 页面初次渲染完成后触发
- **onHide**: 页面隐藏时触发
- **onUnload**: 页面卸载时触发
- **onPullDownRefresh**: 用户下拉动作触发
- **onReachBottom**: 页面滚动到底部时触发

```js
Page({
  onLoad(options) {
    console.log('Page loaded with options: ', options);
  },
  onShow() {
    console.log('Page Shown');
  },
  onReachBottom() {
    console.log('Reached bottom');
  }
});
```

### 组件生命周期

- **beforeCreate**: 组件实例化之前调用
- **created**: 组件实例化后调用
- **mounted**: 组件挂载后调用
- **beforeUpdate**: 数据更新前调用
- **updated**: 数据更新后调用
- **beforeDestroy**: 组件销毁前调用
- **destroyed**: 组件销毁后调用

------

## 2. **云函数操作**

### 增（添加数据）

```js
const db = wx.cloud.database();
const userCollection = db.collection('users');
userCollection.add({
  data: {
    name: 'Tom',
    age: 20
  }
}).then(res => {
  console.log('添加成功', res);
}).catch(err => {
  console.log('添加失败', err);
});
```

### 查（查询数据）

```js
const db = wx.cloud.database();
const userCollection = db.collection('users');
userCollection.where({
  name: 'Tom'
}).get().then(res => {
  console.log('查询成功', res.data);
}).catch(err => {
  console.log('查询失败', err);
});
```

### 删（删除数据）

```js
const db = wx.cloud.database();
const userCollection = db.collection('users');
userCollection.where({
  _id: 'abc123'
}).remove().then(res => {
  console.log('删除成功', res);
}).catch(err => {
  console.log('删除失败', err);
});
```

### 改（更新数据）

```js
const db = wx.cloud.database();
const userCollection = db.collection('users');
userCollection.where({
  _id: 'abc123'
}).update({
  data: {
    age: 25
  }
}).then(res => {
  console.log('更新成功', res);
}).catch(err => {
  console.log('更新失败', err);
});
```

------

## 3. **本地存储**

- **存储数据**：

```js
wx.setStorageSync('key', 'value');
```

- **获取数据**：

```js
wx.getStorage({
  key: 'key',
  success(res) {
    console.log(res.data);
  }
});
```

- **删除数据**：

```js
wx.removeStorageSync('key');
```

- **清空所有存储**：

```js
wx.clearStorageSync();
```

------

## 4. **对象赋值**

- **对象中的属性赋值**：

```js
this.setData({
  'object.property': value
});
```

- **数组中的元素赋值**：

```js
this.setData({
  'array[1].property': value
});
```

------

## 5. **小程序事件**

- **常见 WXML 事件**：

```html
<button bindtap="handleTap">Click Me</button>
```

- **事件绑定**：
- **阻止冒泡事件**：

```html
<button catchtap="handleTap">Click Me</button>
```

------

## 6. **页面跳转与传参**

- **跳转到其他页面**：

```js
wx.navigateTo({
  url: '/pages/details/details?id=123',
});
```

- **接收参数**：

```js
Page({
  onLoad(options) {
    console.log('参数', options.id);
  }
});
```

- **传递多个参数**：

```js
wx.navigateTo({
  url: `/pages/details/details?name=Tom&age=20`,
});
```

- **跳转到 Tab 页面**：

```js
wx.switchTab({
  url: '/pages/home/home',
});
```

# uniapp（多端）

## **小贴士**

#### 1. **Safe Area Insets**

使用 `env(safe-area-inset-bottom)` 可以确保布局适配设备的安全区域，比如 iPhone X 系列的底部区域。

```css
padding-bottom: env(safe-area-inset-bottom);
```

#### 2. **强制更新 Vue 组件**

- **`$forceUpdate()`**：强制更新 Vue 组件，通常在需要重新渲染但 Vue 无法自动检测变化时使用。
- **`$set`**：用于动态修改数组或对象的特定属性，确保变化响应式。

```js
that.$forceUpdate();
_this.$set(_this.msg.MediaList[index], 'currentTime', '00:00');
```

#### 3. **背景图片样式控制**

通过 `:style` 动态设置背景图片，并使用 `background-size: cover` 使图片等比例缩放填充容器。

```vue
<div :style="{backgroundImage:'url('+e+')'}" 
     style="background-repeat: no-repeat; background-position: 50% 50%; background-size: cover;">
</div>
```

#### 4. **App配置**

在 `app-plus` 中禁用回弹效果。

```json
"app-plus": {
  "bounce": "none"
}
```

#### 5. **富文本处理**

使用 `rich-text` 组件展示富文本内容，可以动态调整 `<img>` 标签的样式，让图片宽度自适应。

```vue
<rich-text :nodes="data.goods_desc.replace(/\<img/gi, '<img style=\'max-width: 100%;height:auto;display:block;\'')"></rich-text>
```

#### 6. **Class 动态绑定**

Vue 中可以使用 `:class` 绑定多个类名，结合条件判断。

```vue
<div :class="[{'a': c == i}, 'b']"></div>
```

#### 7. **阻止事件冒泡**

通过 `.native.stop` 可以阻止事件冒泡，通常用于点击事件。

```vue
<button @click.native.stop="handleClick">阻止冒泡</button>
```

#### 8. **富文本图片处理**

使用正则表达式修改富文本中的 `<img>` 标签，确保图片宽度自适应。

```js
.replace(/\<img/gi, '<img style=\'max-width: 100%;height:auto;display:block;\'')
```

#### 9. **渐变文字**

通过 `-webkit-text-fill-color` 和 `-webkit-background-clip` 可以实现渐变文字效果。

```css
background-image: -webkit-linear-gradient(bottom, #FEF1A0 0%, #FFFFFF 100%);
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
```

#### 10. **保持屏幕常亮**

使用 `uni.setKeepScreenOn` 让屏幕在使用期间保持常亮状态。

```js
onLaunch() { 
  uni.setKeepScreenOn({ 
    keepScreenOn: true 
  });
}
```

#### 11. **打开客服会话**

在小程序中使用 `open-type='contact'` 可以调用客服会话。

```vue
<button class="m2_item" type="submit" open-type="contact">联系客服</button>
```

#### 12. **预览图片**

使用 `uni.previewImage` 可以打开图片预览功能。

```js
uni.previewImage({
  urls: [i],  // 图片数组
  current: 0  // 当前显示的图片
});
```

## **获取 DOM 元素尺寸**

在 UniApp 中可以使用 `uni.createSelectorQuery()` 获取 DOM 元素的尺寸或属性：

```js
const query = uni.createSelectorQuery().in(this);
query.select('.tabbar').boundingClientRect(data => {
  console.log('.tabbar height:', data.height);
}).exec();
```

## **获取可视区域信息**

使用 `uni.getSystemInfoSync()` 可以同步获取设备信息，其中包括窗口的高度、宽度等：

```js
const res = uni.getSystemInfoSync();
console.log('窗口高度:', res.windowHeight);
```

## **网络状态检测**

你可以使用 `uni.getNetworkType()` 检测当前的网络状态，并根据结果执行相应操作，如弹窗提醒用户打开网络连接：

```js
uni.getNetworkType({
  success: function(res) {
    if (res.networkType === 'none') {
      uni.showModal({
        title: '网络链接失败',
        content: '检测到网络权限可能关闭，您可以在“设置”中检查无线数据及蜂窝移动网络',
        success: function (res) {
          if (res.confirm || res.cancel) {
            plus.runtime.quit();  // 退出应用
            plus.ios.import('UIApplication').sharedApplication().performSelector('exit');
          }
        }
      });
    }
  }
});
```

## **订阅消息**

在小程序中，你可以使用 `wx.requestSubscribeMessage` 来向用户请求订阅消息权限：

```js
wx.requestSubscribeMessage({
  tmplIds: ['FgXOn86wn1UUgoWSPo0Nxk8LU4jVnz1g7oMZv7vxm-0'],
  success(res) {
    console.log('订阅成功:', res);
  },
  fail(err) {
    console.log('订阅失败:', err);
  }
});
```

- **`tmplIds`**：订阅消息模板的 ID 数组，可以向用户请求多个模板的订阅权限。
- **`success`**：订阅成功时的回调函数。
- **`fail`**：订阅失败时的回调函数。

## **ScrollView 滚动视图**

`scroll-view` 组件用于创建可滚动的视图容器，支持上下和左右滚动，提供滚动事件监听。

- **`scroll-y`**：开启纵向滚动。
- **`scroll-x`**：开启横向滚动。
- 事件：
  - **`@scroll`**：滚动过程中触发，返回滚动的详细信息。
  - **`@scrolltoupper`**：滚动到顶部时触发。
  - **`@scrolltolower`**：滚动到底部时触发。

```vue
<scroll-view class="scroll-view" scroll-y="true" @scroll="scroll" @scrolltoupper="scrollToUpper" @scrolltolower="scrollToLower">
  <!-- 滚动内容 -->
</scroll-view>

<script>
export default {
  methods: {
    scroll(event) {
      console.log('滚动信息:', event.detail);
    },
    scrollToUpper() {
      console.log('滚动到顶部');
    },
    scrollToLower() {
      console.log('滚动到底部');
    }
  }
};
</script>
```

## **视频下载**

使用 `uni.downloadFile` 下载视频，并使用 `uni.saveVideoToPhotosAlbum` 将视频保存到设备相册中。下载过程中可以提示用户下载进度。

```js
uploadVideo(e) {
  uni.showToast({
    title: "下载中",
    icon: "loading"
  });
  
  uni.downloadFile({
    url: e.playUrl,
    success: (res) => {
      if (res.statusCode === 200) {
        uni.saveVideoToPhotosAlbum({
          filePath: res.tempFilePath,
          success() {
            uni.showToast({
              title: "下载成功",
              icon: "success"
            });
          },
          fail() {
            uni.showToast({
              title: "保存失败"
            });
          }
        });
      } else {
        uni.showToast({
          title: "资源格式错误，请联系管理员"
        });
      }
    },
    fail() {
      uni.hideLoading();
      uni.showToast({
        title: "下载失败"
      });
    }
  });
}
```

**路由控制**

UniApp 中可以通过配置 `pages.json` 文件来修改页面的导航栏样式。

- **`navigationStyle: "custom"`**：隐藏顶部系统导航栏，启用自定义导航栏。
- **`navigationBarBackgroundColor`**：设置导航栏背景颜色。

```json
{
  "navigationStyle": "custom",
  "navigationBarBackgroundColor": "#ffffff"
}
```

## **UniApp 安全距离设置**

使用 `uni.getSystemInfoSync()` 可以获取设备信息，如状态栏高度和屏幕宽度，并通过 `uni.getMenuButtonBoundingClientRect()` 获取菜单按钮的位置，以此来设置顶部安全距离。

```js
let {
  statusBarHeight,
  windowWidth
} = uni.getSystemInfoSync();
this.BarHeight = statusBarHeight;

let {
  top,
  bottom
} = uni.getMenuButtonBoundingClientRect();
this.navBareight = (bottom - statusBarHeight) + (top - statusBarHeight);

this._this = getCurrentInstance();
```

在模板中，使用这些值动态设置导航栏的高度：

```vue
<view class="navbar" :style="{height:IndexStore.BarHeight+IndexStore.navBareight +'px'}">
  <view class="narbar-content" :style="{height:IndexStore.navBareight+'px'}">
    <uv-icon name="search" size="28" color="#444548"></uv-icon>
  </view>
</view>
```

对应的 CSS 样式：

```css
.navbar {
  width: 100vw;
  position: sticky;
  z-index: 5;
  top: 0;
  left: 0;
  background-color: white;
}
.narbar-content {
  position: absolute;
  left: 0;
  bottom: 0;
  box-sizing: border-box;
  padding: 0 10rpx;
  display: flex;
  align-items: center;
}
```

------

## **滑动选择器 Slider**

使用 `slider` 组件可以实现滑动选择功能，并支持设置最小值、最大值、步长、滑块颜色等。

```vue
<view>
  <slider @change="slider" value="10" show-value="true" min="0" max="100" step="1" activeColor="#3C9" block-size="20" />
</view>

<script>
export default {
  methods: {
    slider(event) {
      console.log('当前值:', event.detail.value);
    }
  }
};
</script>
```

------

## **路由跳转与动画**

UniApp 提供多种路由跳转方式，每种方式适用于不同的场景：

1. **`uni.navigateTo`**：保留当前页面，跳转到新页面，可以使用 `uni.navigateBack` 返回。

   ```js
   uni.navigateTo({
     url: './index/index'
   });
   ```

2. **`uni.redirectTo`**：关闭当前页面并跳转到新页面。

   ```js
   uni.redirectTo({
     url: './index/index'
   });
   ```

3. **`uni.reLaunch`**：关闭所有页面并打开新页面。

   ```js
   uni.reLaunch({
     url: './index/index'
   });
   ```

4. **`uni.switchTab`**：跳转到 `tabBar` 页面并关闭其他非 `tabBar` 页面。

   ```js
   uni.switchTab({
     url: '/pages/index/index'
   });
   ```

5. **`uni.navigateBack`**：返回上一页面或多级页面。

   ```js
   uni.navigateBack({
     delta: 2 // 返回两层页面
   });
   ```

#### 动画效果

UniApp 跳转页面时可以配置动画效果，例如：

```json
"animationType": "fade-in",
"animationDuration": 50
```

支持的动画效果：

| 显示动画       | 关闭动画        | 描述                         |
| -------------- | --------------- | ---------------------------- |
| slide-in-right | slide-out-right | 新窗体从右侧进入             |
| slide-in-left  | slide-out-left  | 新窗体从左侧进入             |
| slide-in-top   | slide-out-top   | 新窗体从顶部进入             |
| fade-in        | fade-out        | 新窗体从透明到不透明逐渐显示 |
| zoom-out       | zoom-in         | 新窗体从小到大缩放显示       |

#### 传递参数

使用路由跳转时，可以通过 `options` 传递参数。

传递对象参数：

```js
uni.navigateTo({
  url: `/pages/detail/detail?textObj=${JSON.stringify(this.textObj)}`
});
```

接收参数并解析：

```js
onLoad(options) {
  this.textObj = JSON.parse(options.textObj.replace(/""/g, ""));
}
```

##  **获取手机系统信息**

通过 `uni.getSystemInfo()` 可以获取手机的屏幕宽度、高度等系统信息：

```js
uni.getSystemInfo({
  success: (res) => {
    const screenWidth = res.windowWidth; // 获取屏幕宽度（单位：px）
    const screenHeight = res.windowHeight; // 获取屏幕高度（单位：px）
    console.log('屏幕宽度：', screenWidth);
    console.log('屏幕高度：', screenHeight);
  }
});
```

## **本地存储操作**

UniApp 提供多种方式进行数据存储，如同步和异步的存取操作：

- **同步存储**：

```js
// 同步设置存储
uni.setStorageSync('latitude', res.latitude);

// 同步获取存储
var regionss = uni.getStorageSync("region");
```

- **异步存储**：

```js
// 异步设置存储
uni.setStorage({
  key: "id",
  data: 100,
  success() {
    console.log("存储成功");
  }
});

// 异步获取存储
uni.getStorage({
  key: "id",
  success(res) {
    console.log("获取成功", res);
  }
});

// 移除存储
uni.removeStorage({
  key: "id",
  success() {
    console.log("移除数据");
  }
});
```

##  **提示框操作**

UniApp 提供多种类型的提示框，如成功提示框、加载框、模态弹窗等：

- **成功提示框**：

```js
uni.showToast({
  title: '提交成功',
  duration: 2000
});
```

- **加载框**：

```js
uni.showLoading({
  title: '加载中'
});

// 隐藏加载框
setTimeout(function () {
  uni.hideLoading();
}, 2000);
```

- **无图标提示框**：

```js
uni.showToast({
  title: '请填写员工工号',
  icon: 'none',
  duration: 2000
});
```

- **模态弹窗**：

```js
uni.showModal({
  title: '提示',
  content: '这是一个模态弹窗',
  success: function (res) {
    if (res.confirm) {
      console.log('用户点击确定');
    } else if (res.cancel) {
      console.log('用户点击取消');
    }
  }
});
```



## **微信小程序**

使用 `uni.login()` 获取用户的登录凭证，配合 `uni.getUserProfile()` 获取用户的微信信息。

```js
return new Promise((resolve, reject) => {
  // 获取登录凭证
  uni.login({
    success: res => {
      console.log('登录成功:', res);
    }
  });

  // 获取用户微信信息
  uni.getUserProfile({
    desc: '用于获取您的个人信息',
    success: res => {
      console.log('用户微信信息:', res);
    },
    fail: err => {
      console.error('获取微信信息失败:', err);
    }
  });
});
```

------

### **时间戳转换**

使用 `new Date()` 将时间戳转换为年月日时分秒格式的字符串，并补充不足两位的数字。

```js
sjc(value) {
  if (value === undefined) {
    return;
  }
  // 时间戳为10位需*1000，时间戳为13位无需乘1000
  let date = new Date(value);
  let y = date.getFullYear();
  let MM = date.getMonth() + 1;
  MM = MM < 10 ? ('0' + MM) : MM; // 月份补0
  let d = date.getDate();
  d = d < 10 ? ('0' + d) : d; // 天补0
  let h = date.getHours();
  h = h < 10 ? ('0' + h) : h; // 小时补0
  let m = date.getMinutes();
  m = m < 10 ? ('0' + m) : m; // 分钟补0
  let s = date.getSeconds();
  s = s < 10 ? ('0' + s) : s; // 秒补0

  // 返回年月日时分秒格式
  return `${y}-${MM}-${d} ${h}:${m}:${s}`;
}
```

------

### **去掉标题栏**

通过配置 `navigationStyle` 和 `titleNView` 去掉小程序及 App/H5 的顶部导航栏。

```json
"style": {
  "navigationBarTitleText": "商城",
  "navigationStyle": "custom",  // 去掉小程序的顶部导航
  "app-plus": {
    "titleNView": false  // 去掉APP、H5的顶部导航
  }
}
```

------

# ts

声明变量+基础数据类型：

```tsx
let isDone: boolean = false;
let decLiteral: number = 6;
let name: string = "bob";
let list: number[] = [1, 2, 3]; or let list: Array<number> = [1, 2, 3];

元组 Tuple
let x: [string, number];
```

# node

```js
安装node.js第三方模块
npm i 模块名 --save
npm i 模块名 --save-dev

express: 搭建web服务器模块(第三方模块)
npm i express --save

使用node命令启动服务器
node index.js

commonJS规范
导入: require()
导出: exports, module.exports
exports相当于给module.exports对象添加属性

express中间件: 在访问接口之前做一些事情
  app.use((req, res, next) => {

  })


借助nodemon模块辅助开发, 当后台服务器文件发改变时, 后台自动重启
npm i nodemon -g

使用nodemon启动node.js服务器
nodemon index.js
//自动编译 

视图引擎ejs
  app.set('views', 视图路径)
  app.set('view engine', 视图引擎类型)

  //如果是html后缀, 则需要以下配置
  app.engine(引擎解析视图文件后缀, ejs.__express)

__dirname: 当前文件的绝对路径, 属于node.js全局变量

module.exports 和 exports 

get、post、跨域请求


借助body-parser模块解析请求体
npm i body-parser --save
```

```js
const express = require('express');

//创建express实例
const app = express();

app.get('/user', (req, res) => {
  console.log('访问/user接口');
  res.send({msg: '获取用户数据成功', code: 2000, result: [{uid: 'u001', phone: 15219233321, nickname: 'Kevin'}]});
})
```

## 跨域问题

```js
CORS配置
app.all('*', (req, res, next) => {

  //允许跨域地址
  res.header("Access-Control-Allow-Origin", "http://www.kangliuyong.com:10000");

  //*表示允许所有域请求，在实际开发中，一般指定允许某个域请求，如上面设置
  //res.header("Access-Control-Allow-Origin", "*");

  //如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
  res.header("Access-Control-Allow-Headers", "X-Requested-With");

  //该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

  //该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可
  //res.header('Access-Control-Allow-Credentials', true);

  next();

});
```

## 操作数据库

### 连接数据库

```js
npm i sequelize
npm i mysql2 --save

//导入sequelize
const {Sequelize,Model,DataTypes} = require('sequelize')
//创建sql连接实例
const sequelize = new Sequelize('textdb', 'root', '123456', {
    host: 'localhost',
    dialect: 'mysql',

    //定义字段规则
    define:{
        underscored:true//当定义模型字段时，有大写字母自动转换为下划线
    }
});
//测试连接mysql
// async function a() {
//     try {
//         await sequelize.authenticate();
//         console.log('连接成功');
//     } catch (error) {
//         console.error('连接失败', error);
//     }
// }
// a()
```

### 添加表

```js
//定义用户（user）模型
class user extends Model{}
user.init({
    id:{
        type:DataTypes.INTEGER.UNSIGNED,//字段类型，INTEGER:整形，UNSIGNED:无符号
        allowNull:false,//是否允许为null
        primaryKey:true,//主键
        autoIncrement:true,//自动递增
        comment:'表id'//备注
    },
    phone:{
        type:DataTypes.STRING(11),
        allowNull:false,
        defaultValue:'',//默认值
        unique:true,//是否唯一
        comment:'手机号'
    },
    password:{
        type:DataTypes.STRING(32),
        allowNull:false,
        defaultValue:'',
        comment:'密码'
    },
    nickName:{
        type:DataTypes.STRING(30),
        allowNull:false,
        defaultValue:'',
        comment:'昵称'
    }
},{
    sequelize,
    modelName:'User',
    freezeTableName:true,//强制停止复数化
    //指定表名
    // tableName:'t-user'
    //不创建时间戳字段
    // createdAt:false,
    // updatedAt:false
})
//同步到mysql
//force:删除原有的表，创建新表，false ==> 如果表存在则不执行，不存在则创建
user.sync({
    force:false
})
```



# react

## 上手

```js
	<!-- react文件 -->	
	<script src="./react.development.js"></script>
    <!-- react-dom文件,渲染视图,生成ReactDOM对象 -->
    <script src="./react-dom.development.js"></script>
    <!-- babel文件,处理JSX语法,ES6 转 ES5 -->
    <script src="./babel.min.js"></script>


	<script type="text/babel">
        // 渲染视图,将视图渲染到div #root中
        const root = ReactDOM.createRoot(document.getElementById('root'))
        // 渲染组件
        let title = '我要赚米米'
        let id = 'html'

        let html = <div id={id} name="react">
            <h1>{title}</h1>  
            <h2>React开发</h2>  
        </div>
        root.render(html)
    </script>
```

## 脚手架

```react
 npm i create-react-app -g	//安装脚手架
 create-react-app -V	//查看版本
 create-react-app app	//创建
 npm start	//运行
```

## 安装less

```react
1.npm install less-loader less --save-dev //下载
2.查找 node_modules 下面的react-scripts/config/webpack.config.js
3.import "lib-flexible"; index.js里面
//我自己添加
const lessRegex = /\.less$/;
const lessModuleRegex = /\.module\.less$/;
//搜索sass-loader下面
{
  test: lessRegex,
  exclude: lessModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 2,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
      modules: {
        mode: 'icss',
      },
    },
    'less-loader'
  ),
  sideEffects: true,
},

 //我自己添加
{
  test: lessModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 2,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
      modules: {
        mode: 'local',
        getLocalIdent: getCSSModuleLocalIdent,
      },
    },
    'less-loader'
  ),
},
```

## px转rem

```react
1.//安装postcss-pxtorem
npm i lib-flexible postcss-pxtorem -s

2.在src目录下index.js里引入lib-flexible
import "lib-flexible";

3.修改webpack.config.js（这个文件在node_modules文件夹下的react-scripts文件夹下的config文件夹中）
const pxtorem = require('postcss-pxtorem');

//搜索postcss-normalize（因为这里是三元运算符，所以要加两次）
// 基于iphone6 适配
pxtorem({ rootValue: 37.5, unitPrecision: 1, propList: ['*'] })
```



## 组件

```react
const {Component} = React

const com = ReactDOM.createRoot(document.getElementById('component'))
        class Box extends Component {
            // 类数据定义
            constructor() {
                super()
                this.a = 'a'
                this.state = {
                    title: 'react组件',
                    arr: [1, 2, 3],
                    n: 0,
                    show:false
                }
            }

            update() {
                this.a = 'b'
                // this.state.title='改变啦'
                this.setState({
                    title: '改变啦',
                    n: 1,
                    show:!this.state.show
                })
            }

            render() {
                console.log('render执行');
                return (
                    <div>
                        <h1>{this.state.title}</h1>
                        <h2>{this.a}</h2>
                        <button onClick={() => (this.update())}>改变</button>
                        {/*<div>{this.state.arr}</div>*/}
                        { this.state.show && <h1>我出来啦!</h1>}
                        
                        <div>
                            {
                                this.state.arr.map((item, index) => 
                                    <h1 key={index}>{item}</h1>
                                )
                            }
                        </div>

                    </div>
                )
            }
        }

        com.render(<Box />)
```

## 页面跳转

```react
// ********不携带参数跳转********
	navigate('/detail');

// ********跳转到详情页面, 并且携带state参数, 该参数不会在浏览器地址栏中显示********
    navigate('/detail?a=10&b=20', {state: {x: 1, y: 2}});
    
{/*目标页面*/}
import {
  //截取state参数的hook
  useLocation
} from 'react-router-dom';

    let location = useLocation();
    console.log('location ==> ', location);

// ********跳转到详情页面, 并且携带路由参数(url可见)********
	navigate('/detail/008/9');
{/*路由页面*/}
    path: '/detail/:pid/:count',
{/*目标页面*/}
import {
  //截取路由参数的hook
  useParams
} from 'react-router-dom';
	//截取路由参数
      let data = useParams();
      console.log('data ==> ', data)

// ********跳转到详情页面, 并且携带查询参数(url可见)********
	navigate('/detail?a=100&b=200');
{/*目标页面*/}
import {
  //截取查询参数的hook
  useSearchParams
} from 'react-router-dom';
	// 截取查询参数
      let [search] = useSearchParams();
      let s = {};
	  search.forEach((v,k) => {
          s[k] = v
      })
```

## 返回上一个页面

```react
// 不带参数 
window.history.back(-1)
// 带参数
this.props.history.push('/admin/user/info/' + userId) // 不确定
```



## 事件

```react
阻止事件冒泡
	e.stopPropagation()
表单
	input 输入框 value 必须与 onChange 使用 ，实现v-mode。
	
	

```

## ref

```react
    class Box extends React.Component {
      constructor() {
        super();

        this.h3Ref = React.createRef();
        this.divRef = null;
        this.A1Ref = null;
        this.A1Btn = null;

        this.state = {
          title: 'Ref',
          fruit: '荔枝'
        }
      }

      getBtn(el) {
        console.log('el ==> ', el);
        this.A1Btn = el;
      }

      componentDidMount() {
        console.log('this.h3Ref.current ==> ', this.h3Ref.current);
        console.log('this.divRef ==> ', this.divRef);
        console.log('this.A1Ref ==> ', this.A1Ref);
        //调用A1组件的getBook方法
        this.A1Ref.getBook();
      }

      //修改A1组件的book
      updateBook() {
        this.A1Ref.setState({
          book: 'React-App开发'
        })
      }

      render() {
        return (
          <div>
            <h3 className="title" ref={this.h3Ref}>{this.state.title}</h3>
            <div className="box" ref={el => this.divRef = el}></div>
            {/*在Box组件中直接引用A1组件的Button*/}
            <A1 ref={el => this.A1Ref = el} f={this.state.fruit} btn={el => {this.getBtn(el)}}></A1>
            <button onClick={() => {this.updateBook()}}>修改A1组件的book</button>
          </div>
        );
      }
    }
```



## 生命周期

```react
 class A2 extends React.Component {
      constructor() {
        super();
        this.state = {
          title: '生命周期'
        }
        console.log('01-A2-constructor');
      }

      //更新title
      updateTitle() {
        this.setState({
          title: 'React生命周期'
        })
      }

      //生命周期
      //组件挂载之前执行, 首次渲染组件执行一次
      UNSAFE_componentWillMount() {
        // console.log('02-this.state.title ==> ', this.state.title);
        console.log('02-A2-UNSAFE_componentWillMount');
      }

      //组件挂载之后执行, 推荐在这个钩子发起ajax请求，首次渲染组件执行一次
      componentDidMount() {
        // console.log('03-this.state.title ==> ', this.state.title);
        console.log('03-A2-componentDidMount');
      }

      //当组件接收的props发生改变时触发, 首次渲染组件不会执行
      UNSAFE_componentWillReceiveProps(newProps) {
        //newProps: 最新的props
        console.log('newProps ==> ', newProps);
        console.log('04-A2-UNSAFE_componentWillReceiveProps');
      }

      //更新state和props的拦截器, 首次渲染组件不会执行
      shouldComponentUpdate(newProps, newState) {
        //newProps: 最新的props数据
        //newState: 最新的state数据
        // console.log('newProps ==> ', newProps);
        // console.log('newState ==> ', newState);

        console.log('05-A2-shouldComponentUpdate');
        //必须返回一个布尔值
        //阻止更新, 不会引起render方法执行
        // return false;

        //更新, 会引起render方法执行
        return true;
      }

      //更新数据之前(数据同步到视图之前), 首次渲染组件不会执行
      UNSAFE_componentWillUpdate() {
        console.log('06-A2-UNSAFE_componentWillUpdate');
      }

      //更新数据之后(数据同步到视图之后), 首次渲染组件不会执行
      componentDidUpdate() {
        console.log('07-A2-componentDidUpdate');
      }

      //组件被卸载之前, 首次渲染组件不会执行
      componentWillUnmount() {
        console.log('08-A2-componentWillUnmount');
      }


      render() {
        console.log('A2-render');
        return (
          <div name="A2">
            <h1>{this.state.title}</h1>
            <h2>{this.props.book}</h2>
            <button onClick={() => {this.updateTitle()}}>修改title</button>
          </div>
        );
      }
    }

    //渲染组件
    root.render(
      <div>
        <A1 />
      </div>
    );
```

## 跨组件传值

```react
let {useState, createContext, useContext, useEffect} = React;
//createContext 创建 useContext 查询 useEffect 类组件钩子

//创建context, 并初始化值, 当不使用ProductContext.Provider组件提供数据时, 默认使用初始化数据
let ProductContext = createContext({name: '葡萄', price: 6});

let [product, setProduct] = useState({
        name: '苹果',
        price: 4.5
      })

<ProductContext.Provider value={product}></ProductContext.Provider>

//获取ProductContext
let data = useContext(ProductContext);

```



# Dart

## 变量声明

```dart
void main(){
    //void 没有返回值
}
//dart 变量会自动校验
//声明区分大小写
const //常量
final //可以开始不赋值，只能赋值一次；惰性
```

## 定义类型

```dart
String 类型 
    ''' a
    b
    c'''  //多行字符串 
print("$text1 $text2"); //拼接 

double 类型 int 类型
bool 类型
List 类型
    var list = <String>["选择类型"]
    list.add("数组添加")
    var list<> = List.filled(10,'')  //固定长度，参数一：长度 参数二：内容
```

## List常用属性

```dart
~/ //取整
??= //默认赋值
    
//常用属性：
    length 长度
    reversed 翻转 //反转之后不是数组  list.reversed.toList(); 设置为数组
    isEmpty 是否为空
    isNotEmpty 是否不为空
//常用方法：
    add 增加
    addAll 拼接数组
    indexOf 查找 //返回索引 没有返回-1
    remove 删除 //直接删除对应
    removeAt 删除 //删除下标
    fillRange(0,1,'') 修改 //下标修改
    insert(index,value) //指定位置插入
    insertAll(index,value) //指定位置插入数组
    toList() //转换成数组
    join(',') //转换为字符
    split() //字符串转换为数组
//Set 去重
    var s = new Set();

var newlist = list.where((value){reture value>5}) //循环遍历，满足条件reture
    			  any //返回bool 有一个满足条件返回true
    			  every //每一个都要
```

## 方法

```dart
返回数据类型 方法名(){}
int log(String username,[int age,String sex='男']){ //[可选参数]
    reture 123;
}

//命名参数
	int log2(String username,{int age,String sex='男'}){ //[可选参数]
    	reture 123;
	}
	log2(2,age:18,sex='男')

//匿名方法
     var a = (){}
  	 a ()
//自执行方法
     ((int n){
         print('自执行');
     })(12);
```

## 类

```dart
//定义首字母必须大写
class Person{
    String name;
    //默认匿名构造函数
    Person(this.name) ==>
    Person(String name,int age){
        this.name = name; //初始化 
        print('构造函数 实例化的时候被触发->a')
    }
    //命名构造函数
    Person.now(){
        print('命名构造函数-> b')
    }
    
    void printInfo(){
        print('构造方法')
    }
}

void main(){
    var a = new Person();
    var b = new Person().now;
}
```

## 泛型

```dart
T getData<T>(T value){reture value}//泛型 传入数值为什么类型就返回什么类型
```

## 异步

```dart
async 和 await
    //只有async方法才可以使用await，如果调用别的async方法必须使用await字符
    void main() async{
    var result = await test()
}
```

## 导入

```dart
//自定义库
import 'lib/my/myMath.dart' show getAge; //只导入某个方法
import 'lib/my/myMath.dart' hide getAge; //隐藏某个方法

//系统内置库
import 'dart:math';'dart:io'_'dart:convert';

//Pub包管理系统中的库
	1.项目根目录新建一个pubspec.yaml;
	2.配置名称描述，依赖信息;
	3.运行 pub get;
	4.项目中引入 import 看文档使用；
```

# Flutter

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget { //自定义组件 StatelessWidget
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(  //MaterialApp是一个widget 一般作为顶层widget ，
      // title: 'Flutter Demo',  
      theme: ThemeData(
        primarySwatch: Colors.red, //主题颜色
      ),
      // home: const MyHomePage(title: '测试'),
      home:Scaffold(
        appBar: AppBar(
          title: Text('测试'),
        ),
        body: Center(
          child: Text('xxx'),
        ),
      )
    );
  }
```

## 组件关键词

### Container盒子

```dart
alignment //对齐方式
    topCenter：顶部居中对齐
    topLeft：顶部左对齐
    topRight：顶部右对齐
    center：水平垂直居中对齐
    centerLeft：垂直居中水平居左对齐
    enterRight：垂直居中水平居右对齐
	bottomCenter 底部居中对齐
	bottomLeft：底部居左对齐
	bottomRight：底部居右对齐;
decoration //
    decoration: BoxDecoration(
		color: Colors.blue,
		border: Border.all(
		color: Colors.red,
		width: 2.0,
	),
	borderRadius:BorderRadius.all(
		Radius.circular(8.0)
	);
margin //外边距
    margin 属性是表示 Container 与外部其他组件的距离。
	EdgeInsets.all(20.0);
padding //内边距
     padding 就 是 Container 的内边距，指Container 边缘与 Child 之间的距离
	padding: EdgeInsets.all(10.0);
transform //旋转
     让 Container 容易进行一些旋转之类的
child //容器子元素
```

### Text文本

```dart
textAlign
    文本对齐方式（center 居中，left 左对齐，right 右对齐，justfy 两端对齐）;
textDirection
    文本方向（ltr 从左至右，rtl 从右至左）;
overflow
    文字超出屏幕之后的处理方式（clip裁剪，fade 渐隐，ellipsis 省略号）;
textScaleFactor
    字体显示倍率;
maxLines
    文字显示最大行数
style
    字体的样式设置
    
//TextStyle
TextStyle{
    decoration
        文字装饰线（none 没有线，lineThrough 删除线，overline 上划线，underline 下划线）;
    decorationColor
        文字装饰线颜色;
    decorationStyle
        文字装饰线风格（[dashed,dotted]虚线，double 两根线，solid 一根实线，wavy 波浪线）;
    wordSpacing
        单词间隙（如果是负值，会让单词变得更紧凑);
    letterSpacing
        字母间隙（如果是负值，会让字母变得更紧凑）;
    fontStyle
        文字样式（italic 斜体，normal 正常体）
	fontSize
        文字大小;
    color
        文字颜色;
    fontWeight
        字体粗细（bold 粗体，normal 正常体）
}
```

### Image图片

```dart
Image.asset，本地图片
Image.network远程图片
    
alignment Alignment 
    图片的对齐方式；
color和colorBlendMode 
    设置图片的背景颜色，通常和colorBlendMode配合一起使用，这样可以是图片颜色和背景色混合。上面的图片就是进行了颜色的混合，绿色背景和图片红色的混合
fit
    BoxFitfit
    	属性用来控制图片的拉伸和挤压，这都是根据父容器来的;
	BoxFit.fill:
		全图显示，图片会被拉伸，并充满父容器。
	BoxFit.contain:
		全图显示，显示原比例，可能会有空隙。
	BoxFit.cover：
    	显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。
	BoxFit.fitWidth：
        宽度充满（横向充满），显示可能拉伸，可能裁切。
	BoxFit.fitHeight：
        高度充满（竖向充满）,显示可能拉伸，可能裁切。
	BoxFit.scaleDown：
        效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。
repeat
    ImageRepeat.repeat:
		横向和纵向都进行重复，直到铺满整个画布。
	ImageRepeat.repeatX:
		横向重复，纵向不重复。
	ImageRepeat.repeatY：
         纵向重复，横向不重复。
width
        宽度一般结合ClipOval才能看到效果
height
        高度一般结合ClipOval才能看到效果
            
child:Image.network(
    "http://pic.baike.soso.com/p/20130828/201308281611371346445960.jpg",
    alignment:Alignment.topLeft,
    color:Colors.red,
    colorBlendMode:BlendMode.colorDodge,
    //repeat:ImageRepeat.repeatX,fit:BoxFit.cover,
),

//圆角图片child:ClipOval()

//引入本地图片
//1.新建images目录 2.0x 3.0x 4.0x
//2.修改pubspec.yaml 关键词：assets： -images/2.0x
```

### ListView 列表

```dart
scrollDirection
    Axis.horizontal水平列表 Axis.vertical垂直列表;
padding
    EdgeInsetsGeometry 内边距;
resolve
    bool 组件反向排序;
children
    List<Widget> 列表元素;

1、垂直列表
    ListTile(title:Text("thisislist"),subtitle:Text('thisislistthisislist'),)
2、垂直图文列表
3、水平列表
    Container(width:180.0,color:Colors.lightBlue,),
4、动态列表
    return ListView.builder(
    	itemCount:this.list.length,
    	itemBuilder:(context,index){
            //print(context);
            return ListTile(
                leading:Icon(Icons.phone),
                title:Text("${list[index]}"),
            );
        },
	);
5、矩阵式列表
	1、可以通过GridView.count实现网格布局
	2、通过GridView.builder实现网格布局
    scrollDirection
    	Axis 滚动方法
    padding
    	EdgeInsetsGeometry 内边距
    resolve
    	bool 组件反向排序
    crossAxisSpacing
    	double 水平子Widget之间间距
    mainAxisSpacing
    	double 垂直子Widget之间间距
    crossAxisCount
    	int 一行的Widget数量
    childAspectRatio
    	double 子Widget宽高比例
    children
    	<Widget>[]
    gridDelegate
    	SliverGridDelegateWithFixedCrossAxisCount（常用）SliverGridDelegateWithMaxCrossAxisExtent 控制布局主要用在GridView.builder里面
    
    Widget_getListData(context,index){
    	return Container(
            child:Column(
                children:<Widget>[
                    image.network(listData[index]["imageUrl"]),
                    SizedBox(height:12),
                    Text(listData[index]["title"],textAlign:TextAlign.center,style:TextStyle(fontSize:20)),
                ],
            )
    
   @overrideWidgetbuild(BuildContextcontext){//TODO:implementbuild
       return GridView.builder(
           itemCount:listData.length,
           gridDelegate:SliverGridDelegateWithFixedCrossAxisCount(//横轴元素个数
               crossAxisCount:2,//纵轴间距
               mainAxisSpacing:20.0,//横轴间距
               crossAxisSpacing:10.0,//子组件宽高长度比例
               childAspectRatio:1.0
               ),
           itemBuilder:this._getListData
      )
```

### Paddiing组件

```dart
padding
    padding值,EdgeInsetss设置填充的值;
child
    子组件
    
padding:EdgeInsets.fromLTRB(0,0,10,0),
```

### Row水平布局组件

```dart
mainAxisAlignment
	主轴的排序方式;
crossAxisAlignment
	次轴的排序方式;
children
    组件子元素
    
child:Row(
	crossAxisAlignment:CrossAxisAlignment.center,
	mainAxisAlignment:MainAxisAlignment.spaceEvenly,
    //crossAxisAlignment:CrossAxisAlignment.center,
    children:<Widget>[
        IconContainer(Icons.home,color:Colors.red),
    	IconContainer(Icons.search,color:Colors.blue),
        IconContainer(Icons.send,color:Colors.orange),
    ],),
```

### Column垂直布局组件

```dart
child:Column(
  crossAxisAlignment:CrossAxisAlignment.center,
    mainAxisAlignment:MainAxisAlignment.spaceEvenly,
    //crossAxisAlignment:CrossAxisAlignment.center,
    children:<Widget>[
        IconContainer(Icons.home,color:Colors.red),
        IconContainer(Icons.search,color:Colors.blue),
        IconContainer(Icons.send,color:Colors.orange),
    ],
```

### Expanded Flex布局

```dart
flex
	元素站整个父Row/Column的比例;
child
    
    child:Row(
        //crossAxisAlignment:CrossAxisAlignment.start,
        mainAxisAlignment:MainAxisAlignment.center,
        //crossAxisAlignment:CrossAxisAlignment.center,
        children:<Widget>[
            Expanded(
                flex:2,child:IconContainer(Icons.home)),
            SizedBox(width:10),
            Expanded(
                flex:3,child:IconContainer(Icons.search)),
            //SizedBox(width:10),
            //Expanded(child:IconContainer(Icons.send))
        ],
```

### Stack定位布局组件

```dart
Stack表示堆的意思，我们可以用Stack或者Stack结合Align或者Stack结合Positiond来实现页面的定位布局
alignment
    配置所有子元素的显示位置;
children
    
//StackAlign
    alignment
    	配置所有子元素的显示位置;
//StackPositioned
	top bottom left right
```

### AspectRatio调整比例组件

```dart
//AspectRatio的作用是根据设置调整子元素child的宽高比。
//AspectRatio首先会在布局限制条件允许的范围内尽可能的扩展，widget的高度是由宽度和比率决定的，类似于BoxFit中的contain，按照固定比率去尽量占满区域。如果在满足所有限制条件过后无法找到一个可行的尺寸，AspectRatio最终将会去优先适应布局限制条件，而忽略所设置的比率。
 
aspectRatio
    宽高比，最终可能不会根据这个值去布局，具体则要看综合因素，外层是否允许按照这种比率进行布局，这只是一个参考值;
child
    

```

### Card卡片组件

```dart
//Card是卡片组件块，内容可以由大多数类型的Widget构成，Card具有圆角和阴影，这让它看起来有立体感。
margin 外边距;
child 子组件;
Shape Card的阴影效果，默认的阴影效果为圆角的长方形边;
Card(
    margin:EdgeInsets.all(10),
    child:Column(
        children:<Widget>[
            ListTile(
                title:Text("李四",style:TextStyle(fontSize:28)),
                subtitle:Text("高级软件工程师"),
            ),
            Divider(),
            ListTile(
                title:Text("电话：1213214142"),),
            ListTile(
                title:Text("地址：北京市海淀区"))
        ],
    ),
```

### Card图文组件

```dart
return ListView(
children:listData.map((value){
return Card(
	margin:EdgeInsets.all(10),
	child:Column(
    	children:<Widget>[
        	AspectRatio(
            	aspectRatio:16/9,
            	child:Image.network(value["imageUrl"],fit:BoxFit.cover)
        	),
        	ListTile(
                title:Text(value["title"]),
            	subtitle:Text(value["description"],overflow:TextOverflow.ellipsis),
            	leading:CircleAvatar(
                	backgroundImage:NetworkImage(value["imageUrl"]))
        	)
    	],
	),
```

### 按钮组件

```dart
//RaisedButton：凸起的按钮，其实就是MaterialDesign风格的Button
//FlatButton：扁平化的按钮
//OutlineButton：线框按钮
//IconButton：图标按钮
//ButtonBar:按钮组
//FloatingActionButton:浮动按钮
```

```dart
onPressed
    VoidCallback，一般接收一个方法 必填参数，按下按钮时触发的回调，接收一个方法，传null表示按钮禁用，会显示禁用相关样式;
textColor
    Color 文本颜色;
color
    按钮的颜色;
disabledColor
    按钮禁用时的颜色;
disabledTextColor
    按钮禁用时的文本颜色;
splashColor
    点击按钮时水波纹的颜色;
highlightColor
    点击（长按）按钮后按钮的颜色;
elevation
    double 阴影的范围，值越大阴影范围越大;
padding
    内边距;
shape
    设置按钮的形状
    shape:RoundedRectangleBorder(
        borderRadius:
        BorderRadius.circular(10),
    );
	shape:CircleBorder(
        side:BorderSide(
            color:Colors.white,
        )
    )
```

#### RaisedButton定义一个按钮

```dart
return RaisedButton(
    child:Text('女装'),
    textColor:Theme.of(context).accentColor,
    onPressed:(){},
);

Flutter2.x以后新增了一些按钮组件 ElevatedButton替代RaisedButton;

Widgetbuild(BuildContextcontext){
    return ElevatedButton(
        child:Text(this.text),
        onPressed:(){});}
```



### Wrap流组件

```dart
Wrap可以实现流布局，单行的Wrap跟Row表现几乎一致，单列的Wrap则跟Row表现几乎一致。但Row与Column都是单行单列的，Wrap则突破了这个限制，mainAxis上空间不足时，则向crossAxis上去扩展显示。
    
direction
    主轴的方向，默认水平;
alignment
    主轴的对其方式;
spacing
    主轴方向上的间距;
textDirection
    文本方向;
verticalDirection
    定义了children摆放顺序，默认是down，见Flex相关属性介绍。
runAlignment
    run的对齐方式。run可以理解为新的行或者列，如果是水平方向布局的话，run可以理解为新的一行;
runSpacing
    run的间距;

return Wrap(
    spacing:10,
    runSpacing:10,
    alignment:WrapAlignment.spaceEvenly,
    children:<Widget>[
        MyButton("第1集"),
        MyButton("第2集"),
        MyButton("第3集"),
    ],
);
```

### 自定义有状态组件

```dart
//在Flutter中自定义组件其实就是一个类，这个类需要继承StatelessWidget/StatefulWidget

//StatelessWidget是无状态组件，状态不可变的widget
//StatefulWidget是有状态组件，持有的状态可能在widget生命周期改变。通俗的讲：如果我们想改变页面中的数据的话这个时候就需要用到StatefulWidget

class HomePage extends StatefulWidget{
    //Flutter2.2.0之后需要注意把Key改为可空类型{Key?key}表示key为可空类型
	HomePage({Key?key}):super(key:key);
    _HomePageStatecreateState()=>_HomePageState();
}
```

### BottomNavigationBar底部导航组件

```dart
items
    List<BottomNavigationBarItem>底部导航条按钮集合;
iconSize
    icon;
currentIndex
    默认选中第几个;
onTap
    选中变化回调函数;
fixedColor
    选中的颜色;
type
    BottomNavigationBarType.fixed
    BottomNavigationBarType.shifting;

Scaffold(
    appBar:AppBar(
        title:Text('FlutterDemo')
    ),
    body:this._pagesList[this._curentIndex],
    bottomNavigationBar:BottomNavigationBar(
        currentIndex:_curentIndex,
        onTap:_changePage,
        fixedColor:Colors.black,
        type:BottomNavigationBarType.fixed,
        items:[
            BottomNavigationBarItem(
                title:Text("首页"),
                icon:Icon(Icons.home)
            ),
            BottomNavigationBarItem(
                title:Text("分类"),
                icon:Icon(Icons.category)
            ),
            BottomNavigationBarItem(
                title:Text("设置"),
                icon:Icon(Icons.settings)
            ),
        ],
    ),
)
```

### 常用表单

```dart
//Flutter中常见的表单有TextField单行文本框，TextField多行文本框、CheckBox、Radio、SwitchCheckboxListTile、RadioListTile、SwitchListTile、Slide.
```

#### TextField文本框组件

```dart
maxLines
    设置此参数可以把文本框改为多行文本框;
onChanged
    文本框改变的时候触发的事件;
decoration
    hintText 类似html中的placeholder
    border配置文本框边框 OutlineInputBorder配合使用
    labelText  lable的名称
    labelStyle配置lable的样式;
obscureText
    把文本框框改为密码框;
controller
    controller结合TextEditingController()可以配置表单默认显示的内容
    
```

#### Checkbox**、**CheckboxListTile多选框组件

```dart
1.Checkbox常见属性：
	value
		true或者false;
	onChanged
	    改变的时候触发的事件;
	activeColor
	    选中的颜色、背景颜色;
	checkColor
	    选中的颜色、Checkbox里面对号的颜色;
2.CheckboxListTile常见属性：
    value
    	true或者false
    onChanged
    	改变的时候触发的事件;
	activeColor
        选中的颜色、背景颜色
    title
        标题
    subtitle
        二级标题
    secondary
        配置图标或者图片
    selected
        选中的时候文字颜色是否跟着改变
    
```

## Radio**、**RadioListTile单选按钮组件

```dart
1.Radio常用属性：
    value 
    	单选的值;
	onChanged
        改变时触发;
	activeColor
        选中的颜色、背景颜色
    groupValue
        选择组的值;

2.RadioListTile常用属性：
    title
    	标题
    subtitle
    	二级标题
    secondary
    	配置图标或者图片
```



## Flutter 路由

Flutter中的路由通俗的讲就是页面跳转。在Flutter中通过Navigator组件管理路由导航。并提供了管理堆栈的方法。如：Navigator.push和Navigator.pop

Flutter中给我们提供了两种配置路由跳转的方式：1、基本路由2、命名路由

### 基本路由使用

```dart
1、需要在HomPage中引入SearchPage.dart
    import'../SearchPage.dart';
2、在HomePage中通过下面方法跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
        	Navigator.of(context).push(
            	MaterialPageRoute(
                	builder:(BuildContextcontext){
                    	return SearchPage();
                	}
            	)
        	);
    	},
    color:Theme.of(context).accentColor,
    textTheme:ButtonTextTheme.primary
)
```

### 路由跳转传值

```dart
1、需要在HomPage中引入SearchPage.dart
    import'../SearchPage.dart';
2、在HomePage中通过下面方法跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
            Navigator.of(context).push(
                MaterialPageRoute(
                    builder:(BuildContextcontext){
                        return SearchPage(title:"表单");//传值
					}
                )
            );
        },
    	color:Theme.of(context).accentColor,
    	textTheme:ButtonTextTheme.primary
    )
```

### 命名路由

```dart
1、配置路由
	import'package:flutter/material.dart';
	import'pages/Tabs.dart';

	import'pages/Search.dart';
	import'pages/Form.dart';

	voidmain()=>runApp(MyApp());
classMyAppextendsStatelessWidget{
    @override
    Widgetbuild(BuildContextcontext){
        return MaterialApp(
            //home:Tabs(),
            initialRoute:'/',
            routes:{
                '/':(contxt)=>Tabs(),
                '/search':(contxt)=>SearchPage(),
                '/form':(context)=>FormPage(),
            },
        );
    }
}
2、路由跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
            Navigator.pushNamed(context,'/search');
        },
```

### 命名路由跳转传值

```dart
官方文档：https://flutter.dev/docs/cookbook/navigation/navigate-with-arguments
1、配置路由：
	import'package:flutter/material.dart';import'pages/Tabs.dart';import'pages/Search.dart';import'pages/Form.dart';
	voidmain()=>runApp(MyApp());
	class MyApp extends StatelessWidget{
        final routes={
            '/':(contxt)=>Tabs(),
            '/search':(contxt)=>SearchPage(),
            '/form':(context,{arguments})=>FormPage(arguments:arguments),
        };
        @override
        Widgetbuild(BuildContextcontext){
            return MaterialApp(
                home:Tabs(),
                onGenerateRoute:(RouteSettingssettings){
                    //统一处理
                    final Stringname=settings.name;
                    final Function pageContentBuilder=this.routes[name];
                    if(pageContentBuilder!=null){
                        if(settings.arguments!=null){
                            finalRouteroute=MaterialPageRoute(
                                builder:(context)=>pageContentBuilder(context,
                                	arguments:settings.arguments));
                            return route;
                        }else{
                            final Route route=MaterialPageRoute(
                            	builder:(context)=>pageContentBuilder(context));
                            return route;
                            )
                        }
                    }
                });
        }
    }
2、跳转传值:
	RaisedButton(
    	child:Text("跳转到表单演示页面"),
        onPressed:(){
            Navigator.pushNamed(
                context,'/form',
                arguments:{"id":20});
        },
        color:Theme.of(context).accentColor,textTheme:ButtonTextTheme.primary
    );
3、接收参数:
	import'package:flutter/material.dart';
	class FormPage extends StatelessWidget{
        finalMaparguments;
        FormPage({this.arguments});
        @override
        Widget build(BuildContext context){
            return Scaffold(
                appBar:AppBar(title:Text("搜索"),
                ),
                body:Text("我是一个表单页面${arguments!=null?arguments['id']:'0'}")
       	);
```

### 命名路单独抽离到一个文件

```dart
import'package:flutter/material.dart';import'../pages/Tabs.dart';import'../pages/Search.dart';import'../pages/Form.dart';

finalMap<String,Function>routes={
    '/':(contxt,{arguments})=>Tabs(),
    '/search':(contxt,{arguments})=>SearchPage(arguments:arguments),
    '/form':(context,{arguments})=>FormPage(arguments:arguments),
};
varonGenerateRoute=(RouteSettingssettings){
    //统一处理
    finalStringname=settings.name;
    finalFunctionpageContentBuilder=routes[name];
    if(pageContentBuilder!=null){
        finalRouteroute=MaterialPageRoute(
            builder:(context)=>
            	pageContentBuilder(context,arguments:settings.arguments));
        return route;
    }
}
```

```dart
import'package:flutter/material.dart';import'routes/Routes.dart';voidmain()=>runApp(MyApp());

class MyApp extends StatelessWidget{
    @override
    Widget build(BuildContext context){
        return MaterialApp(
            //home:Tabs(),
            initialRoute:'/',
            onGenerateRoute:onGenerateRoute
            );
    }
}
```

### 回到上一级页面

```dart
Navigator.of(context).pop();
```

### 替换路由

```dart
比如我们从用户中心页面跳转到了registerFirst页面，然后从registerFirst页面通过
pushReplacementNamed跳转到了registerSecond页面。这个时候当我们点击registerSecond
的返回按钮的时候它会直接返回到用户中心
    
Navigator.of(context).pushReplacementNamed('/registerSecond');
```

### 返回到根路由

```dart
Navigator.of(context).pushAndRemoveUntil(
	new MaterialPageRoute(builder:(context)=>newTabs(index:1)),
	(route)=>route==null
};
```

## 布局

### Drawer侧边栏

```dart
//在Scaffold组件里面传入drawer参数可以定义左侧边栏，传入endDrawer可以定义右侧边栏。侧边栏默认是隐藏的，我们可以通过手指滑动显示侧边栏，也可以通过点击按钮显示侧边栏

return Scaffold(
    appBar:AppBar(
        title:Text("FlutterApp"),
    ),
    drawer:Drawer(
        child:Text('左侧边栏'),
    ),
    endDrawer:Drawer(
        child:Text('右侧侧边栏'),
    ),
);
```

#### DrawerHeader

#### UserAccountsDrawerHeader

#### Flutter侧边栏路由跳转

```dart
onTap:(){
    Navigator.of(context).pop();
    Navigator.pushNamed(context,'/search');
}
```

## Flutter2.2.0之后的一些变化

```dart
官方sdk地址：
https://flutter.dev/docs/development/tools/sdk/releases?tab=windows#windows

一、创建组件的变化：
    以前创建的StatefulWidget格式如下：
    class PayPage extends StatefulWidget{
    	PayPage({Key key}):super(key:key);
    	_PayPageStatecreateState()=>_PayPageState();
	}
	现在创建StatefulWidget的时候需要注意把Key配置成可空参数格式如下：
    class PayPage extends StatefulWidget{
        PayPage({Key? key}):super(key:key);
        _PayPageStatecreateState()=>_PayPageState();
    }
二、配置路由的变化
    1、需要指定路由的类型finalMap<String,Function>routes
    	finalMap<String,Function>routes={
    '/':(context)=>Tabs(),
    '/buttonPage':(context)=>ButtonDemoPage(),
    '/buttonExtend':(context)=>ButtonExtendDemoPage(),
    '/textField':(context)=>TextFieldDemoPage(),
    '/checkBox':(context)=>CheckBoxDemo(),
    '/radio':(context)=>RadioDemo(),};

	2、配置onGenerateRoute的时候注意可空类型
        
```

## 日期组件

```dart
//日期转化成时间戳：
varnow=newDateTime.now();
print(now.millisecondsSinceEpoch);//单位毫秒，13位时间戳

//时间戳转化成日期：
varnow=newDateTime.now();
vara=now.millisecondsSinceEpoch;//时间戳
print(DateTime.fromMillisecondsSinceEpoch(a));
```

#### 第三方库date_format的使用

```dart
date_format可以格式化日期文档：https://pub.dev/packages/date_format
```

# NuxtJS

## 1. **动态设置页面 SEO**

在每个页面中可以通过 `head()` 方法动态设置页面的 SEO 元信息，例如标题、描述等。

```js
export default {
  head() {
    return {
      title: "我是标题",
      meta: [
        { charset: "utf-8" },
        { name: "viewport", content: "width=device-width, initial-scale=1" },
        { hid: "description", name: "description", content: "我是首页内容，这是描述" },
        { name: "renderer", content: "webkit" },
      ],
      // 图标
      link: [{ rel: "icon", type: "image/x-icon", href: "/favicon1.ico" }],
    };
  }
};
```

------

## 2. **伪静态设置**

通过在 `nuxt.config.js` 中的 `router` 属性扩展路由，实现 URL 的伪静态化。

```js
router: {
  extendRoutes(routes, resolve) {
    routes.push(
      {
        name: 'Index',
        path: '/index.html', // 伪静态路由
        component: resolve(__dirname, 'pages/index')
      },
      {
        name: 'Products',
        path: '/Products.html',
        component: resolve(__dirname, 'pages/AllProducts')
      }
    );
  }
}
```

------

## 3. **动态路由传参**

通过 `:name?/:age?` 等动态路由匹配路径来传递参数，并在 `<nuxt-link>` 中使用 `params`。

```js
router: {
  extendRoutes(routes, resolve) {
    routes.push(
      {
        name: 'Index',
        path: '/index/:name?/:age?/:sex?/:hobby?', // 动态路由
        component: resolve(__dirname, 'pages/index')
      }
    );
  }
}

// 动态传参链接示例
<nuxt-link :to="{ name: 'Index', params: { name: '蔡徐坤', age: 15, sex: '男', hobby: '打篮球' } }">
  进入
</nuxt-link>
```

------

## 4. **路由与视图**

Nuxt.js 路由和视图的区别：

- `<nuxt-link>`：Nuxt.js 中用于导航的组件，相当于 Vue.js 的 `<router-link>`。
- `<Nuxt />`：Nuxt.js 中的路由视图组件，相当于 Vue.js 的 `<router-view>`。

------

## 5. **动态路由渲染**

使用 `v-for` 循环创建多个动态路由链接。

```vue
<NuxtLink :to="'/aaaaaaa/1001'+index" v-for="(item, index) in 10" :key="index">
  {{ index }}
</NuxtLink>
```

------

## 6. **Nuxt.js 部署到服务器**

1. **安装 PM2 管理器**：在宝塔面板中下载并安装 PM2 管理器。
2. **配置反向代理**：

```nginx
upstream nodenuxt {
    server 127.0.0.1:3003; # Nuxt.js 监听端口
    keepalive 64;
}
```

1. **设置反向代理**：设置 Nginx 反向代理，指向 Nuxt.js 监听的端口（例如 `127.0.0.1:3003`）。
2. **修改 `package.json` 脚本**：

```json
"scripts": {
  "dev": "nuxt",
  "build": "nuxt build",
  "start": "PORT=3003 nuxt start", // 启动 Nuxt.js 并监听端口
  "generate": "nuxt generate"
}
```

1. **打包应用**：运行 `npm run build` 打包应用，打包后上传以下文件至服务器：
   - `.nuxt`
   - `static`
   - `nuxt.config.js`
   - `package.json`
2. **启动应用**：在宝塔终端中运行：

```bash
npm install
npm start
```

1. **使用 PM2 启动**：

```bash
pm2 start npm --name "项目名称" -- run start
```

常用 PM2 命令：

- `pm2 stop all`：停止所有应用程序
- `pm2 stop 0`：停止 ID 为 0 的应用程序

# 代码库

## 前端截取第一帧

```vue
<template>
	<view class="content">
		// 逻辑层调用视图层方法，采用监听data中变量改变的方法
		<view id="canvas" class="canvas" :prop="newVal" :change:prop="canvas.create"></view>
		<button @click="choose">chooseVideo</button>

		<view class="img" :style="{backgroundImage:'url('+imgurl+')'}">

		</view>
	</view>
</template>

<!-- 逻辑层script -->
<script>
	export default {
		data() {
			return {
				newVal: null,
				imgurl: ''
			};
		},
		methods: {
			choose() {
			uni.chooseVideo({
					sourceType: ['camera', 'album'],
					success:  (blod)=>{
						// 获取视频信息，拿到宽高信息
						uni.getVideoInfo({
							src: blod.tempFilePath,
							success: (info) => {
								// 上传视频到网络地址，当然也可以使用本地地址。App、H5平台本人都测试过，都没问题！！！
								uni.uploadFile({
									url: 'http://替换成自己个上传文件接口/api/common/upload', //仅为示例，非真实的接口地址
									filePath: blod.tempFilePath,
									name: 'file',
									formData: {
										'token': uni.getStorageSync('userInfo').token
									},
									success: src => {
										// fullurl也可以使用本地地址，上传选择文件获取到的 => blod.tempFilePath
										this.newVal = {fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height}
										// 这里当时想做个平台区分，但是后面发现H5平台这种调用方式，视图层create接受参数的时候，只能接收到newValue，但是不能接收到event, ownerInstance，所以还是统一使用上方操作
										// 下方方法仅展示，调用还是统一使用上方操作
										// // #ifdef APP-PLUS
										// this.newVal = {fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height}
										// // #endif
										// // #ifdef H5
										// this.create({fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height})
										// // #endif
									},
									complete: all => {
										console.log(JSON.parse(all.data))
									}
								})
							}
						})
					}
				})
			},
			getBase64(options) {
				this.imgurl = options.base64
			},
		}
	}
</script>


<script module="canvas" lang="renderjs">
	export default {
		methods: {
			// 视图层创建base64图片
			create(newValue, oldValue, ownerInstance) {
				// 第一次进入为空不操作
				if (newValue == null) {
					return
				}
				// 在缓存中创建video标签
				var video = document.createElement("VIDEO")
				video.autoplay = true
				// 该设置方法无效
				// video.setAttribute('autoplay', true)
				// 再添加一个静音的属性，否则自动播放会有声音
				// 该设置方法无效
				// video.setAttribute('muted', true)
				video.muted = true
				// 如果报错Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.
				// 可以把下面两行代码加上，因为我用的线上video url，所以可能抛出了异常。大概意思就是跨域了toDataURL()使用了外域资源
				video.setAttribute('crossOrigin', 'anonymous')
				video.crossOrigin = '*'
				// 上面我们只是创建了video标签，视频播放需要内部的source的标签，scr为播放源
				video.innerHTML = '<source src=' + newValue.fullurl + ' type="audio/mp4">'
				// 再创建canvas画布标签
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				// video注册canplay自动播放事件
				// 防止video不播放，所以手动加个播放操作
				video.play()
				// video播放事件
				video.addEventListener('canplay', () => {
					// 创建画布的宽高属性节点，就是图片的大小，单位PX
					var anw = document.createAttribute("width");
					anw.nodeValue = newValue.width;
					var anh = document.createAttribute("height");
					anh.nodeValue = newValue.height;
					canvas.setAttributeNode(anw);
					canvas.setAttributeNode(anh);
					// 画布渲染
					ctx.drawImage(video, 0, 0, newValue.width, newValue.height);
					// 生成base64图片，指定type为jpeg格式生成的图片base64编码会小很多
					var base64 = canvas.toDataURL('image/jpeg') // 这就是封面图片的base64编码
					// 传递数据给逻辑层
					console.log('base64', base64);
					ownerInstance.callMethod('getBase64', {
						base64: base64
					})
					// 删除创建的video 、canvas dom，要不然重新选取视频生成图片不生效
					// ps：开始有这个问题，但是后面不知道为什么又没有了，如果发现生成第一次base64之后再选择不生效，可以尝试一下把下方注释打开
					// document.body.removeChild(video)
					// document.body.removeChild(canvas)
				})
			}
		}
	}
</script>

<style>
	.img {
		width: 200px;
		height: 200px;
		background-repeat: no-repeat;
		background-position: 50% 50%;
		background-size: cover;
	}
</style>

```



# Canvas

### Canvas 基础操作

#### 1. **绘制线条**

```JS
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
// moveTo(x, y) 定义线条开始坐标
ctx.moveTo(0, 0);
// lineTo(x, y) 定义线条结束坐标
ctx.lineTo(200, 100);
// 使用 stroke() 方法绘制线条
ctx.stroke();
```

#### 2. **绘制圆形**

```JS
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
// beginPath() 方法开始一条路径
ctx.beginPath();
// arc(x, y, radius, startAngle, endAngle) 绘制圆形
ctx.arc(95, 50, 40, 0, 2 * Math.PI);
ctx.stroke();
```

#### 3. **绘制文本**

- `fillText()` 用于绘制实心文本。
- `strokeText()` 用于绘制空心文本。

```JS
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
// 设置字体大小和样式
ctx.font = "30px Arial";
// fillText(text, x, y) 绘制实心文本
ctx.fillText("Hello World", 10, 50);
```

#### 4. **绘制图像**

```JS
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
var img = document.getElementById("scream");
// drawImage(image, x, y) 绘制图像
ctx.drawImage(img, 10, 10);
```



# vite+vue3+ts

### 创建项目

```bash
npm create vite@latest
npm install
npm run dev
```

### 配置路由

```ts
// 定义路由规则
name: '路由名称',
path: '路由路径',
component: '路由对应组件',
meta: {
  title: '页面标题',
  requiresAuth: true, // 示例元信息，用于权限判断
  ...
}
```

### 路由跳转示例

```vue
<template>
  <router-link to="/about">Go to About</router-link>
</template>

<script setup>
import { useRouter } from 'vue-router'
const router = useRouter()
const gotoAbout = () => {
  router.push('/about')
}
</script>
```

### 路由传参示例

```ts
const routes = [
  { path: '/user/:id', name: 'User', component: UserComponent }
]

// 在组件内获取参数
import { useRoute } from 'vue-router'
const route = useRoute()
console.log(route.params.id)
```

## 使用 Pinia 管理状态

```ts
// 定义store
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
  }),
  getters: {
    doubleCount: (state) => state.count * 2,
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
vue复制代码<template>
  <div>{{ store.doubleCount }}</div>
</template>

<script setup>
import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'

const store = useCounterStore()
const { doubleCount } = storeToRefs(store)
</script>
```

### 更新状态

```ts
store.$patch({
  count: store.count + 1,
})
```

### 重置状态

```ts
store.$reset()
```

## i18n 国际化示例

```vue
<template>
  <div>
    <a-button @click="switchLanguage('zhCN')">中文</a-button>
    <a-button @click="switchLanguage('en')">英文</a-button>
    <p>{{ $t('messages.name') }}</p>
  </div>
</template>

<script setup>
import { useI18n } from 'vue-i18n'

const { locale } = useI18n()

const switchLanguage = (lang) => {
  locale.value = lang
  localStorage.setItem('lang', lang)
}
</script>
```

#### 在 script 中使用

```ts
import { useI18n } from 'vue-i18n'
const { t } = useI18n()

console.log(t('messages.name'))
```

# Three.js

## 支持的三维文件格式

1. **OBJ (Wavefront)**
2. **STL (Stereolithography)**
3. **3MF (3D Manufacturing Format)**
4. **AMF (Additive Manufacturing File Format)**
5. **FBX (Filmbox)**
6. **PLY (Polygon File Format)**
7. **GLTF/GLB (GL Transmission Format/Binary)**
8. **X3D (XML-based 3D model format)**
9. **Collada (Digital Asset Exchange)**
10. **DXF (AutoCAD Drawing Exchange Format)**
11. **JSON (JavaScript Object Notation)**

此外，`three.js` 提供的 `Assimp2Json` 工具还支持将多种三维文件格式（如 3DS、OBJ、FBX、Collada、GLTF 等）转化为 `JSON` 格式。

## 渲染器 (WebGLRenderer)

创建 `WebGLRenderer`：

```js
let renderer = new THREE.WebGLRenderer({ antialias: true });
```

### 渲染器属性

1. `.autoClear`: 自动清除输出。
2. `.autoClearColor`: 是否清除颜色缓存，默认为 `true`。
3. `.autoClearDepth`: 是否清除深度缓存，默认为 `true`。
4. `.autoClearStencil`: 是否清除模板缓存，默认为 `true`。
5. `.domElement`: 返回画布节点，需要手动插入到 HTML 中。
6. `.shadowMap.enabled`: 是否允许在场景中使用阴影贴图，默认 `false`。
7. `.shadowMap.type`: 定义阴影贴图类型，支持 `THREE.PCFShadowMap`（默认）等。

### 常用方法

- `.clear(color, depth, stencil)`: 清除颜色、深度、模板缓存。
- `.getContext()`: 返回 WebGL 上下文。
- `.render(scene, camera)`: 渲染场景。
- `.setClearColor(color, alpha)`: 设置背景颜色和透明度。
- `.setSize(width, height)`: 修改渲染器大小。

## 添加轨道控制器 (OrbitControls)

`OrbitControls` 可以实现对三维场景的缩放、平移和旋转操作，影响的是相机参数，而非场景内容。

```JS
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;  // 禁止右键拖拽
controls.enableZoom = false; // 禁止缩放
controls.enableRotate = false; // 禁止旋转
```

### 设置缩放范围

```js
controls.minZoom = 0.5;
controls.maxZoom = 2;
```

### 设置旋转范围

```JS
// 上下旋转范围
controls.minPolarAngle = 0;
controls.maxPolarAngle = Math.PI;

// 左右旋转范围
controls.minAzimuthAngle = -Math.PI * (100/180);
controls.maxAzimuthAngle = Math.PI * (100/180);
```

### 轨道控制器属性

- **autoRotate**: 相机是否自动旋转。
- **enableDamping**: 是否启用阻尼（惯性效果）。
- **dampingFactor**: 阻尼系数，适用于启用阻尼时。
- **enabled**: 控制器是否启用。
- **enablePan**: 相机平移是否启用。
- **panSpeed**: 平移速度。
- **maxPolarAngle**: 最大垂直旋转角度。
- **minPolarAngle**: 最小垂直旋转角度。
- **maxDistance**: 相机最大距离。
- **minDistance**: 相机最小距离。

### 常用方法

- `.dispose()`: 移除所有事件监听器。
- `.getAzimuthalAngle()`: 获取水平旋转角度（弧度制）。
- `.getPolarAngle()`: 获取垂直旋转角度（弧度制）。
- `.reset()`: 重置控件状态。
- `.update()`: 更新控件状态，在动画循环中调用。

## 添加坐标系

```JS
const axes = new THREE.AxesHelper(40);
scene.add(axes);
```

### 轨道控制器和 WebGLRenderer 示例

```JS
const renderer = new THREE.WebGLRenderer();
renderer.setClearColor(new THREE.Color(0xeeeeee));
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new OrbitControls(camera, renderer.domElement);

const sphereGeometry = new THREE.SphereGeometry(4);
const sphereMaterial = new THREE.MeshBasicMaterial({
  color: 0x7777ff,
  wireframe: true,
});
```



## 光源

### 1. DirectionalLight - 方向光

方向光模拟的是远距离光源，例如太阳的光。方向光照射的区域强度均匀，不会随距离变化。

##### 创建方向光

```js
var directionalLight = new THREE.DirectionalLight(0x0c0c0c); // 创建方向光
scene.add(directionalLight); // 将方向光添加到场景
```

##### 主要属性

- **color**: 颜色，需用 `THREE.Color()` 创建。
- **visible**: 布尔值，控制光源是否可见。
- **intensity**: 光的强度，默认为 `1`。
- **target**: 控制光源的方向，通常指向场景中的对象。
- **position**: 光源的位置，影响光线的方向。
- **castShadow**: 控制是否生成阴影。
- **shadow.camera**: 设置阴影的投影范围，包含 `near`、`far`、`top`、`bottom`、`left`、`right` 等属性，用来控制阴影的范围。
- **shadow.mapSize**: 控制阴影贴图的分辨率。

```JS
directionalLight.castShadow = true;
directionalLight.shadow.camera.near = 0.1;
directionalLight.shadow.camera.far = 100;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
```

### 2. AmbientLight - 环境光

环境光影响整个场景的亮度，均匀地照射所有对象，不受位置影响。通常和其他光源结合使用，作为辅助光源。

##### 创建环境光

```JS
var ambientLight = new THREE.AmbientLight(0x0c0c0c); // 创建环境光
scene.add(ambientLight); // 将环境光添加到场景
```

##### 属性

- **color**: 环境光的颜色。
- **visible**: 是否显示环境光。

##### 修改颜色

```JS
var color = new THREE.Color(0x26E250); // 创建颜色对象
ambientLight.color = color; // 修改环境光颜色
```

##### 控制显示

```JS
ambientLight.visible = true; // 显示环境光
ambientLight.visible = false; // 隐藏环境光
```

### 3. PointLight - 点光源

点光源从一个点向四面八方发光，类似电灯泡或照明弹的光线。它会产生迎光面明亮、背光面较暗的效果。

##### 创建点光源

```JS
var pointLight = new THREE.PointLight(0x0c0c0c); // 创建点光源
scene.add(pointLight); // 将点光源添加到场景
```

##### 主要属性

- **color**: 点光源的颜色。
- **visible**: 控制点光源是否可见。
- **intensity**: 点光源的强度，控制光源的亮度。
- **distance**: 控制光的最大照射距离，超过这个距离的地方将不会被照亮。
- **position**: 控制点光源的位置。

```JS
pointLight.intensity = 2;
pointLight.distance = 4; // 距离超过4将看不到点光源发出的光
pointLight.position.set(2, 3, 1); // 设置光源位置
```

### 组合使用光源

通常在一个场景中，会使用多种光源进行组合，以获得更好的视觉效果。例如，环境光和方向光组合使用，方向光用于突出场景中的重点对象，环境光则为整体场景提供基本的亮度。

```JS
var ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // 柔和的环境光
scene.add(ambientLight);

var directionalLight = new THREE.DirectionalLight(0xffffff, 1); // 方向光
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

var pointLight = new THREE.PointLight(0xff0000, 1, 10); // 红色点光源
pointLight.position.set(0, 5, 0);
scene.add(pointLight);
```

## 监听窗口大小变化

为了让 Three.js 的场景在浏览器窗口大小变化时自适应，可以监听 `resize` 事件，并动态调整相机和渲染器的大小：

```JS
window.addEventListener("resize", () => {
  // 更新相机宽高比例
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  // 更新渲染器的尺寸
  renderer.setSize(window.innerWidth, window.innerHeight);

  // 重新渲染场景
  renderer.render(scene, camera);
});
```

## 包围盒 (Bounding Box)

在 Three.js 中，包围盒用于计算物体的边界范围，常用于碰撞检测、物体居中、缩放等操作。

### 计算和使用包围盒

```JS
// 获取模型中的一个网格对象
let Mesh = gltf.scene.getObjectByName("package_01");

// 获取网格对象的几何体
let geometry = Mesh.geometry;

// 计算几何体的包围盒
geometry.computeBoundingBox();

// 将几何体设置为居中
geometry.center();

// 获取几何体的包围盒
let box = geometry.boundingBox;

// 更新世界矩阵
Mesh.updateMatrixWorld(true, true);

// 将包围盒应用到世界矩阵中
box.applyMatrix4(Mesh.matrixWorld);

// 获取包围盒的中心点
let center = box.getCenter(new THREE.Vector3());

// 创建一个包围盒的辅助线框
let boxMesh = new THREE.Box3Helper(box, 0xff0000);

// 将包围盒辅助线框添加到场景
scene.add(boxMesh);
```

#### 解释

- **computeBoundingBox()**: 计算几何体的包围盒。
- **center()**: 将几何体的中心点设置到几何体的原点。
- **applyMatrix4()**: 将包围盒应用到对象的世界矩阵上，使其与对象的世界变换保持同步。
- **getCenter()**: 获取包围盒的中心点。
- **Box3Helper**: 用于在场景中可视化包围盒，显示一个线框。

## Tween 补间动画

Tween 是一种简单的补间动画库，它可以在动画期间更新对象的属性。可以用在 Three.js 中实现平滑的动画效果。

### 示例代码：

```JS
// 导入 TWEEN 模块
import * as TWEEN from 'three/examples/jsm/libs/tween.module.js';

// 创建补间动画
const tween = new TWEEN.Tween(gltf.scene.position)
  .to({ x: 10 }, 2000) // 将 gltf.scene 的 x 轴位置在 2 秒内移动到 10
  .easing(TWEEN.Easing.Quadratic.InOut) // 使用缓动函数
  .onUpdate(() => {
    console.log(gltf.scene.position); // 在动画更新时输出位置
  })
  .onComplete(() => {
    console.log('动画完成');
  });

// 创建第二个补间动画
const tween2 = new TWEEN.Tween(gltf.scene.position)
  .to({ y: -10 }, 2000); // 将 gltf.scene 的 y 轴位置在 2 秒内移动到 -10

// 链式播放 tween 和 tween2
tween.chain(tween2);

// 开始动画
tween.start();

// 在动画循环中更新补间动画
function animate() {
  requestAnimationFrame(animate);

  // 更新 TWEEN 动画
  TWEEN.update();
  
  // 渲染场景
  renderer.render(scene, camera);
}
animate();
```

### 动画的参数说明：

- `.to()`: 定义目标属性值和持续时间。
- `.easing()`: 使用缓动函数，例如 `TWEEN.Easing.Quadratic.InOut`。
- `.onUpdate()`: 当动画更新时的回调函数。
- `.onComplete()`: 动画完成后的回调函数。
- `.chain()`: 将两个动画串联起来依次播放。
- `.start()`: 开始动画。

## GUI：右上控制区（dat.GUI）

dat.GUI 是一个轻量级用户界面控制库，用于调试和控制 Three.js 中的各种参数。

### 示例代码：

```JS
import * as dat from 'dat.gui';

// 事件对象
let eventObj = {
  Full: () => {
    document.body.requestFullscreen(); // 全屏
  },
  Color: '#1f1f1f',
};

// 创建 GUI 控制面板
const gui = new dat.GUI();

// 创建文件夹来分类控制
const folder = gui.addFolder('测试控制');

// 添加全屏按钮
folder.add(eventObj, 'Full').name('全屏');

// 控制球体位置的 X 轴
folder
  .add(sphere.position, 'x', -50, 50) // 控制球体 x 轴范围 -50 到 50
  .name('position_x')
  .onChange((val) => {
    console.log('X 轴改变:', val);
  })
  .onFinishChange((val) => {
    console.log('X 轴最终值:', val);
  });

// 添加颜色控制
folder
  .addColor(eventObj, 'Color')
  .name('颜色')
  .onChange((val) => {
    sphere.material.color.set(val); // 改变球体材质颜色
  });
```

控制面板的参数说明：

- `.add()`: 添加参数控制，支持数值范围控制、布尔值切换、文本输入等。
- `.addColor()`: 添加颜色选择器，实时更新场景中的颜色。
- `.onChange()`: 当值发生变化时调用的回调函数。
- `.onFinishChange()`: 当值改变完成后调用的回调函数。
- `.addFolder()`: 为控件分组显示。

dat.GUI 可以让你快速调整场景中的各种属性，便于调试和控制三维物体的行为。

## 鼠标模型交互（Raycaster）

通过鼠标点击与场景中的模型进行交互，常用方法是使用射线投射器（Raycaster）。射线投射器通过摄像机和鼠标的二维坐标创建一条射线，并计算与场景中的三维物体的交点，从而检测点击了哪个物体。

### 示例代码：

```js
// 创建射线投射器
const raycaster = new THREE.Raycaster();
// 创建鼠标二维向量
const mouse = new THREE.Vector2();

// 监听鼠标点击事件
window.addEventListener("click", (event) => {
  // 将鼠标的 X 坐标映射到 [-1, 1] 的范围
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  // 将鼠标的 Y 坐标映射到 [-1, 1] 的范围，并反转 Y 轴
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // 使用摄像机和鼠标位置更新射线
  raycaster.setFromCamera(mouse, camera);

  // 计算射线和场景中所有子物体的交点
  const intersects = raycaster.intersectObjects(scene.children);
  
  // 如果有交点
  if (intersects.length > 0) {
    // 改变第一个交点物体的颜色
    intersects[0].object.material.color.set(0xff0000);
    console.log("点击了物体:", intersects[0].object);
  }
});
```

### 核心步骤：

1. **Raycaster**：创建射线投射器，用于从鼠标指向生成射线。
2. **Vector2**：用于表示鼠标的二维坐标。
3. **setFromCamera**：通过鼠标位置和摄像机生成射线。
4. **intersectObjects**：计算射线与场景中所有物体的交点，返回交点对象数组。
5. **响应交点**：点击的物体可以进行颜色变化或执行其他逻辑。

## UV 坐标

UV 坐标用于在 3D 物体上指定纹理的映射方式。UV 坐标是二维的，定义在 [0, 1] 的范围内。

### 示例代码：

```js
// 创建 UV 坐标数据（以正方形为例）
const uv = new Float32Array([
  0, 0,  // 左下角
  1, 0,  // 右下角
  1, 1,  // 右上角
  0, 1   // 左上角
]);

// 将 UV 坐标应用到几何体的属性上
geometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
```

### 核心步骤：

1. **UV 坐标**：指定 3D 物体顶点上的纹理坐标。
2. **BufferAttribute**：创建并应用 UV 属性，该属性指定了每个顶点的纹理坐标。

## 法向向量

法向向量（Normal Vector）用于计算光照效果，使物体表面根据光源方向正确地显示明暗变化。每个顶点需要有法向量，才能正确渲染光照。

### 示例代码：

```js
// 计算法向量
geometry.computeVertexNormals();
```

### 核心步骤：

1. **computeVertexNormals()**：自动计算几何体的每个顶点的法向量，用于实现光照效果。

应用场景

- **Raycaster**：用于检测鼠标点击与 3D 模型的交互，如选择物体、改变颜色等。
- **UV 坐标**：用于在 3D 模型上正确地映射纹理图像。
- **法向向量**：用于实现光照效果，使物体看起来更具立体感。

## 添加模型

### GLTF 模型

```js
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import Plane from "../assets/plane/plane.gltf?url";

// 初始化 GLTFLoader
const loaderPlane = new GLTFLoader();
let planeModel = null;

// 加载模型
loaderPlane.load(
  Plane,
  function (gltf) {
    // 加载完成后的回调函数，将模型添加到场景
    planeModel = gltf.scene;
    planeModel.scale.set(3, 3, 3);
    planeModel.position.set(0, 0, 0);
    scene.add(planeModel); // 将模型添加到场景
  },
  function (xhr) {
    // 进度回调，可以用于显示加载进度
    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
  },
  function (error) {
    // 加载错误回调
    console.error('模型加载出错', error);
  }
);
```

### GLB 模型（使用 DRACOLoader）

```js
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';

// 初始化 GLTFLoader 并关联 DRACOLoader
const loader = new GLTFLoader();
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('./draco/'); // 设置 Draco 解码器路径
loader.setDRACOLoader(dracoLoader);

// 加载 GLB 模型
loader.load('/bolsa.glb', function (gltf) {
  gltf.scene.scale.set(0.1, 0.1, 0.1);
  gltf.scene.position.set(-20, 0, 0);
  scene.add(gltf.scene); // 将模型添加到场景
});
```

## 环境贴图（HDR）

```js
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';
import { EquirectangularReflectionMapping } from 'three';

// 初始化 RGBELoader
const rgbeLoader = new RGBELoader();
rgbeLoader.load('../src/assets/Alex_Hart-Nature_Lab_Bones_2k.hdr', (envMap) => {
  // 设置球形反射贴图
  envMap.mapping = EquirectangularReflectionMapping;

  // 设置背景和环境贴图
  scene.background = envMap;
  scene.environment = envMap;
});
```

## 灯光与阴影

要使模型投射和接收阴影，步骤如下：

1. **开启渲染器的阴影计算**：

   ```js
   renderer.shadowMap.enabled = true;
   ```

2. **配置光源投射阴影**：

   ```js
   const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
   directionalLight.castShadow = true; // 光源投射阴影
   scene.add(directionalLight);
   
   // 设置阴影贴图模糊度
   directionalLight.shadow.radius = 20;
   // 设置阴影贴图的分辨率
   directionalLight.shadow.mapSize.set(4096, 4096);
   ```

3. **设置物体投射阴影和接收阴影**：

   ```js
   const sphere = new THREE.Mesh(geometry, material);
   sphere.castShadow = true; // 投射阴影
   scene.add(sphere);
   
   const plane = new THREE.Mesh(planeGeometry, planeMaterial);
   plane.receiveShadow = true; // 接收阴影
   scene.add(plane);
   ```

### 总结：

- **GLTFLoader/DRACOLoader** 用于加载模型，支持 glTF 和 GLB 文件。
- **RGBELoader** 用于加载 HDR 贴图，设置场景的环境贴图。
- **阴影** 需要光源、材质、物体共同支持，渲染器需要开启阴影计算。



## 案例

```
<template>
	<div class="box">
		<div ref="canvasContainer"></div>
	</div>
</template>

<script setup>
	import {
		ref,
		onMounted
	} from 'vue';
	import * as THREE from 'three';
	import {
		OrbitControls
	} from 'three/examples/jsm/controls/OrbitControls';

	// 创建场景、相机和渲染器
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera(75, 680 / 680, 0.1, 1000);
	const renderer = new THREE.WebGLRenderer({
		alpha: true
	});

	renderer.setSize(680, 680);

	// 添加光源
	const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
	scene.add(ambientLight);

	const pointLight = new THREE.PointLight(0xffffff, 1);
	pointLight.position.set(50, 50, 50);
	scene.add(pointLight);

	// 创建轨道控制器
	// const controls = new OrbitControls(camera, renderer.domElement);
	// controls.enableDamping = true;
	// controls.dampingFactor = 0.25;
	// controls.enablePan = false; // 禁用平移
	// controls.enableZoom = false; // 禁用缩放

	// 创建球体几何体
	const radius = 20;
	const widthSegments = 84; // 增加密度
	const heightSegments = 84; // 增加密度
	const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);

	// 创建着色器材料 0x47cbfc 0xf4c806
	const shaderMaterial = new THREE.ShaderMaterial({
		uniforms: {
			color1: {
				value: new THREE.Color(0x1b4d9e)
			},
			color2: {
				value: new THREE.Color(0xfbfbfb)
			},
			time: {
				value: 0
			},
			mode: {
				value: 1
			}, // 初始模式设置为随机模式
			transition: {
				value: 0
			}, // 过渡值
			direction: {
				value: 1
			} // 1 表示从 0 到 1，-1 表示从 1 到 0
		},
		vertexShader: `
    varying vec3 vPosition;
    uniform float time;
    uniform float transition;
    uniform int mode;
    uniform int direction;
    void main() {
      vPosition = position;
      vec3 transformed = position;
      float waveHeight = sin(position.y * 2.0 + time) * 3.0; // 随机波浪高度
      float waveWidth = sin(position.x * 2.0 + time) * 3.0; // 随机波浪宽度
      float scale = 1.0 + 0.3 * sin(time + position.x * 10.0) * sin(time + position.y * 10.0) * sin(time + position.z * 10.0);

      // 平滑过渡两种模式
      transformed.z += mix(waveHeight, (scale - 1.0) * position.z, transition);
      transformed.x *= mix(1.0, scale, transition);
      transformed.y *= mix(1.0, scale, transition);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1);
    }
  `,
		fragmentShader: `
    varying vec3 vPosition;
    uniform vec3 color1;
    uniform vec3 color2;
    void main() {
      float mixValue = (vPosition.x + 20.0) / 40.0; // 修改渐变比例，颜色从左往右渐变
      mixValue = clamp(mixValue, 0.0, 1.0); // 限制混合值范围
      gl_FragColor = vec4(mix(color1, color2, mixValue), 0.95);
    }
  `,
		wireframe: true,
	});

	// 创建球体网格
	const sphereMesh = new THREE.Mesh(sphereGeometry, shaderMaterial);
	sphereMesh.position.y = 5
	sphereMesh.rotation.y = 4.5
	scene.add(sphereMesh);

	// 设置相机位置
	camera.position.z = 55;

	// 创建射线投射器和鼠标向量
	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let mouseOver = false;
	let modeSwitching = false;

	const onMouseMove = (event) => {
		const container = canvasContainer.value;
		const rect = container.getBoundingClientRect();
		mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
		mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
	};

	const switchMode = (targetMode) => {
		if (modeSwitching) return;
		modeSwitching = true;
		const duration = 2.0; // 过渡持续时间
		let startTime = Date.now();
		let initialTransition = shaderMaterial.uniforms.transition.value;
		let targetTransition = initialTransition === 0 ? 1 : 0;

		function transition() {
			let elapsed = (Date.now() - startTime) / 1000.0;
			if (elapsed >= duration) {
				shaderMaterial.uniforms.transition.value = targetTransition;
				if (targetTransition === 1) {
					shaderMaterial.uniforms.mode.value = targetMode;
				}
				modeSwitching = false;
			} else {
				shaderMaterial.uniforms.transition.value = initialTransition + (elapsed / duration) * (
					targetTransition - initialTransition);
				requestAnimationFrame(transition);
			}
		}

		transition();
	};

	// 将渲染器添加到页面中
	const canvasContainer = ref(null);

	onMounted(() => {
		const container = canvasContainer.value;
		container.appendChild(renderer.domElement);
		container.addEventListener('mousemove', onMouseMove);
	});

	// 渲染场景
	const animate = function() {
		requestAnimationFrame(animate);
		// controls.update();

		// 更新着色器的时间变量
		shaderMaterial.uniforms.time.value += 0.01; // 增加时间步长

		// 射线投射检测
		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObject(sphereMesh);

		if (intersects.length > 0) {
			if (!mouseOver) {
				mouseOver = true;
				switchMode(0); // 切换到波浪模式
			}
		} else {
			if (mouseOver) {
				mouseOver = false;
				switchMode(1); // 切换到随机模式
			}
		}

		// 整体缓慢旋转
		sphereMesh.rotation.y += 0.001;
		sphereMesh.rotation.x += 0.001;

		renderer.render(scene, camera);
	};
	animate();
</script>

<style lang="scss" scoped>
	.box {
		width: 100%;
		height: 100%;
		position: relative;
		z-index: 50;
		overflow: hidden;
	}
</style>
```

# python

运行命令 uvicorn main:app --reload

## sqlalchemy（数据库操作）

```
查询
query.filter() 过滤
query.filter_by() 根据关键字过滤
query.all() 返回列表
query.first() 返回第一个元素
query.one() 有且只有一个元素时才正确返回
query.one_or_none()，类似one，但如果没有找到结果，则不会引发错误
query.scalar()，调用one方法，并在成功时返回行的第一列
query.count() 计数
query.order_by() 排序
```



## 虚拟环境

```
1.创建虚拟环境
python -m venv venv
2. 激活虚拟环境
Windows:
	venv\Scripts\activate
macOS 和 Linux:
	source venv/bin/activate
```



## fastAPI

```python
from typing import Union

from fastapi import FastAPI, Response
from starlette.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

app = FastAPI()
origins = [
    "*"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}


@app.get("/loginVIEW", response_class=HTMLResponse)
async def read_item():
    return open('./login.html', 'r', encoding='utf-8').read()


class User(BaseModel):
    username: str
    password: str


@app.post("/login")
async def login(user: User):
    with open('User.json', 'r') as file:
        # 读取文件内容
        content = file.read()
        a = eval(content)
    type = 'true'
    for e in a["list"]:
        if e['username'] == user.username:
            type = 'false'
            if e['password'] == user.password:
                return {"code": '00000', "msg": '登录成功'}
            else:
                return {"code": '00000', "msg": '密码错误'}
    if type:
        return {"code": '00000', "msg": '用户不存在'}


class PasswordTool():
    # 密码工具类
    def __init__(self, password):
        self.password = password
        self.strength_level = 0
        self.msg = ''

    def check_number_exist(self):
        """
          判断是否含数字
        """
        has_number = False
        for c in self.password:
            if c.isnumeric():
                has_number = True
                break
        return has_number

    def check_letter_exist(self):
        """
          判断是否含字母
        """
        has_upper_letter = False
        has_lower_letter = False
        for c in self.password:
            if c.isupper():
                has_upper_letter = True
            elif c.islower():
                has_lower_letter = True
            has_both_letter = has_upper_letter and has_lower_letter
            if has_both_letter:
                break
        return has_both_letter

    def check_specialchar_exist(self):
        """
          判断是否包含特殊字符
        """
        has_specialchar = False
        specialchar_list = ['+', '-', '*', '/', '_', '&', '%', ',']
        for c in self.password:
            if c in specialchar_list:
                has_specialchar = True
                break
        return has_specialchar

    def process_password(self):
        """
          判断是否符合规则
        """
        # 规则1：长度至少8位
        if len(self.password) >= 8:
            self.strength_level += 1
        else:
            self.msg = '密码长度至少8位'
            return

        # 规则2：必须包含数字
        if self.check_number_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含数字'
            return

        # 规则3：必须包含大小写字母
        if self.check_letter_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含大小写字母'
            return

        # 规则4：需要包含特殊字符
        if self.check_specialchar_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含至少一个特殊字符("+,-,*,/,_")'
            return
        self.msg = '注册成功'


@app.post("/register")
async def register(user: User):
    mypwdtool = PasswordTool(user.password)
    mypwdtool.process_password()
    if mypwdtool.msg == "注册成功":
        with open('User.json', 'r') as file:
            # 读取文件内容
            content = file.read()
            a = eval(content)
        for e in a["list"]:
            if e['username'] == user.username:
                return {"code": '00000', "msg": '账号已存在'}
        a["list"].append({'username': user.username, 'password': user.password})
        with open('User.json', 'w') as file:
            b = str(a)
            file.write(b)
        return {"code": '00000', "msg": '注册成功'}
    else:
        return {"code": '00000', "msg": mypwdtool.msg}

```

### 状态码

```python
@app.post("/login", status_code=status.HTTP_201_CREATED)
async def login(user: schemas.Users, response: Response, db: Session = Depends(get_db)):
	# 设置状态码
    response.status_code = 202
```

### HTTPException(返回 HTTP 错误响应)

```python
from fastapi import FastAPI, HTTPException
@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=400, detail={"code": 401, "msg": "密码错误"}, headers={"X-Error": "error"})
    return {"item": items[item_id]}
```

# 服务器

## 上传

```
vscode SFTP插件
ctrl + shift + p呼出命令行,运行SFTP:config,创建文件.vscode/sftp.json
```

## nginx

```
启动nginx
systemctl start nginx
停止nginx
systemctl stop nginx
重启nginx
systemctl reload nginx
查看nginx的状态（正常启动，会看到绿色的running）
systemctl status nginx

lsof -i tcp:8088
查看端口
 kill -9 (PID)
清端口
nohup uvicorn main:app --port 8099
nohup 后台运行 fastapi

```

## fastapi部署

```
server {
      	listen 8088;
          server_name 47.96.28.91;# 这里的domain_name是域名地址。
          location / {
              proxy_pass http://127.0.0.1:8099; # 注意这里的端口跟配置脚本的端口一致。
              proxy_set_header Host $host;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          }
      }
      
gunicon_conf.py
from multiprocessing import cpu_count

    # 是否守护
    daemon = True

    # 绑定
    bind = '0.0.0.0:8099'

    # pid 文件地址
    pidfile = 'gunicorn.pid'

    # 项目地址
    chdir = './main.py'

    # Worker Options
    workers = cpu_count() + 1
    worker_class="uvicorn.workers.UvicornWorker"
    threads = 2

    # Logging Options
    loglevel="debug"
    accesslog = 'access_log.log'
    errorlog =  'error_log.log'

import uvicorn
from fastapi import FastAPI
 
app = FastAPI()
 
@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/test")
def test():
    return {"Hello": "World test"}

if __name__ == '__main__':
    uvicorn.run('main:app', port=8099, reload=True)
```

## vue部署

```
include /root/myvue/*.conf;
server {
        listen	8077;                          
        server_name  47.96.28.91;                          
        location / {
            root   /usr/local/nginx/html/dist;             
            index  index.html;                     
            try_files $uri $uri/ @router;
        }
 
        location @router {
			    rewrite ^.*$ /index.html last; 
		    }
        
        location /prod-api/ {
            proxy_pass http://47.96.28.91:8080/;  
        }
        error_page   500 502 503 504  /50x.html;  
	}
```







































