









# html+css 

**万国码**：`<meta charset="utf-8">`

**外部样式链接**：`<link href="文件路径" rel="stylesheet">`

**列表类型**：

- 无序列表：`<ul></ul>`
- 有序列表：`<ol></ol>`
- 定义列表：`<dl><dt><dd></dl>`

**列表样式**：

- 设置项目图像：`list-style-image: url(...)`
- 符号位置：`list-style-position: inside / outside`
- 样式去除符号：`list-style: none`

**盒子模式：**`box-sizing = border-box;` 

------

## HTML5新增语义化标签

```html
<header>   <!-- 网页顶部内容 -->
<nav>      <!-- 页面导航 -->
<aside>    <!-- 侧边栏 -->
<main>     <!-- 网页主要内容 (仅一个) -->
<article>  <!-- 独立内容块，如博客文章 -->
<section>  <!-- 内容分组，主题相关 -->
<footer>   <!-- 网页底部，如版权声明 -->
```

------

## CSS选择器：

**并集选择器**：`h1, h2 { ... }` （同时选择多个标签）

**子代选择器**：`div > li { ... }` （仅选择直接子代）

**相邻兄弟选择器**：`ul li ~ li { ... }` （选择`ul li`后相邻的`li`标签）

**平级选择器**：`div + div { ... }` （选择紧跟的兄弟元素）

------

### 属性选择器:

**选择类名完全相同的元素**：`[class="box"] { ... }`

**选择包含指定类名的元素**：`.box [class="box"] { ... }`

**选择类名以"box"开头的元素**：`[class^="box"] { ... }`

**选择类名中包含"box"的元素**：`[class*="box"] { ... }`

------

## 常见实体字符:

| 实体字符 | 描述           | 实体字符 | 描述           |
| -------- | -------------- | -------- | -------------- |
| `<`      | 小于号 (`<`)   | `>`      | 大于号 (`>`)   |
| `©`      | 版权符号 (`©`) | `®`      | 注册商标 (`®`) |
| `&`      | 与符号 (`&`)   | `×`      | 乘号 (`×`)     |
| `"`      | 双引号 (`"`)   | ` `      | 空格           |

------

## 文本属性：

**字体设置**：

- `font-family: "微软雅黑", "宋体";`
- **字体大小**：`font-size: px;`
- **字体粗细**：`font-weight: 400;`
- **行高**：`line-height: px;`
- **首行缩进**：`text-indent: em;`
- **字体颜色**：`color: #000;`
- **字体间距**：`letter-spacing: px;`
- **大写/小写转换**：`text-transform: uppercase / lowercase;`

**文本修饰**：

- **下划线**：`text-decoration: underline;`
- **删除线**：`text-decoration: line-through;`
- **顶线**：`text-decoration: overline;`
- **取消链接下划线**：`a { text-decoration: none; }`

**鼠标悬停样式**：`cursor: pointer;`

**禁止文本复制**：`user-select: none;`

**字体渐变**：

```css
background-image: -webkit-linear-gradient(left, #25D38B, #1FB682, #1DAC7F);
-webkit-text-fill-color: transparent;
-webkit-background-clip: text;
```

**文本对齐与溢出处理**：

- **两端对齐**：`text-align-last: justify;`

  **文本溢出显示省略号**：`text-overflow: ellipsis;`

  **强制一行显示**：`white-space: nowrap;`

  **换行与隐藏**：

  ```css
  word-break: break-all;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* 限制行数 */
  -webkit-box-orient: vertical;
  overflow: hidden;
  ```

------



## 盒子属性：

**定位属性**：`position: relative | absolute | fixed | sticky | static;`

**盒子阴影**：

```css
box-shadow: 水平偏移, 垂直偏移, 模糊半径, 扩散半径, 颜色, inset(内阴影);
```

**视口单位**：

- **宽度单位**：`1vw = 1% viewport width;`
- **高度单位**：`1vh = 1% viewport height;`

**清除浮动**：

1. 新建一个清除浮动的盒子：`clear: both;`
2. 大盒子设置：`overflow: hidden;`

**滚动条隐藏**：

```css
::-webkit-scrollbar {
    width: 0px;
    height: 0px;
    background-color: #F5F5F5;
}
```

### 	弹性盒子 (Flexbox)

**弹性容器**：`display: flex;`

**水平居中**：`justify-content: center;`（主轴）

**垂直居中**：`align-items: center;`（侧轴）

**设置子元素方向**：`flex-direction: row | row-reverse | column | column-reverse;`

**是否换行**：`flex-wrap: nowrap | wrap | wrap-reverse;`

**不拉伸子元素**：`flex-shrink: 0;`

**`row`**：主轴水平方向，起点在左。

**`row-reverse`**：主轴水平方向，起点在右。

**`column`**：主轴垂直方向，起点在上。

**`column-reverse`**：主轴垂直方向，起点在下。

- **元素对齐方式**：
  - **空间分布**：
    - `space-around`：元素之间的间距相等，左右边距为元素间距的一半。
    - `space-evenly`：元素之间和两边的间距相等。
    - `space-between`：元素之间的间距相等，左右两端对齐。
- **单独控制元素对齐**：
  - `align-self`：用于单个元素的对齐方式，覆盖容器的`align-items`设置。
- **元素排列顺序**：
  - `order`：定义元素的顺序，值越小，排列越靠前，默认值为 `0`。
- **Flex子元素占比**：
  1. **扩展比例**：`flex-grow: number;` （值越大，元素扩展越大）
  2. **收缩比例**：`flex-shrink: number;` （值越大，元素收缩越多）
  3. **基础大小**：`flex-basis: 基准值;` （设置元素初始大小）

**图片背景居中**：

```html
:style="{ backgroundImage: 'url(' + getImgSrc(ig.xwzx) + ')' }"
```

```css
/* 图片背景居中 */
background-size: cover;         /* 背景图像完全覆盖元素 */
background-repeat: no-repeat;   /* 不重复显示背景图像 */
background-position: 50% 50%;   /* 背景图片居中对齐 */
```



## 表单以及控件：

- ### 表单元素

  - **表单**：`<form></form>` 用于提交用户输入信息。

  - **文本输入框**：

    ```html
    <input type="text" placeholder="提示" value="初始值"/>
    ```

    - **取消`input`点击效果**：`outline: none;`
    - **取消`input`默认样式**：`-webkit-appearance: none;`

  ### 按钮类型

  - **提交按钮**：`<input type="submit" value="提交">`

  - **重置按钮**：`<input type="reset" value="重置">`

  - **普通按钮**：`<input type="button" value="按钮">`

  - **禁用按钮**：

    ```js
    btn.setAttribute("disabled", true);  // 禁用按钮
    ```

  - ### 表格标签

    - **表格标签**：`<table></table>`
    - **行**：`<tr></tr>` 用于定义表格的行。
    - **单元格**：
      - 标题单元格：`<th></th>`（表头）
      - 数据单元格：`<td></td>`（表内容）
    - **合并单元格**：
      - **向下合并**：`rowspan` 属性，用于纵向合并单元格。
      - **向右合并**：`colspan` 属性，用于横向合并单元格。

------

## 背景：

> `background：position`		**精灵图**

> `linear-gradient（to left，××，××）`		**线性渐变**

> `background-repeat：no-repeat`		**图片不重复**

------

## 类型转换：

`display`：		**行内元素**：`inline`		**块元素**：`block`		**行内块元素**：`inline-block`		**不显示**：`none`

------

## 伪类选择器：

**链接相关伪类**：

- `:link`：未访问的链接
- `:visited`：已访问的链接
- `:active`：选中的链接

**结构伪类**：

- `:first-of-type`：父级元素的首个指定类型子元素
- `:last-of-type`：父级元素的最后一个指定类型子元素
- `:nth-child(n)`：匹配父元素的第 `n` 个子元素，支持 `odd`（奇数）和 `even`（偶数）
- `:nth-last-child(n)`：从后往前数的第 `n` 个子元素
- `:first-child`：父元素的第一个子元素
- `:last-child`：父元素的最后一个子元素
- **公式** `(an+b)`：如 `nth-child(2n+1)` 匹配奇数位置元素，`nth-child(-n+3)` 匹配前三个元素

**状态伪类**：

- `:enabled`：启用状态的元素
- `:disabled`：禁用状态的元素
- `:checked`：被选中的 `input` 元素
- `:focus`：元素获取焦点时的样式，常用于表单控件，取消默认样式：`outline: none;`

**其他伪类**：

- `:not(selector)`：匹配所有不符合 `selector` 的元素
- `:target`：选取当前激活的目标元素，如锚点链接 `#anchor:target`

## 伪元素选择器

**`:first-letter`**：向块级元素的首个字符添加样式。

**`:first-line`**：向块级元素的首行文本添加样式。

**`:before`**：在元素内部开头插入内容，常用于修饰：

```css
element::before {
    content: "前置内容";
}
```

**`:after`**：在元素内部结尾插入内容：

```css
element::after {
    content: "后置内容";
}
```



# css3

## 瀑布流

```
column-count: 3;

column-gap: 10px;

break-inside: avoid;

栅格化
```



## @media 查询

响应式页面

```css
@media scre en and (max-width: 300px) {

}
@media screen and (min-width: 769px) and (max-width: 992px) {
    /* 大于768px 小于992px  小屏幕 */
}
```

## calc计算

```css
calc(100% - 50px)
```

## transition 过度属性

```css
transition: background-color 0.2s linear 0s; /* 背景颜色的过渡效果，持续0.2秒，线性过渡 */
```

### 常用过渡效果

- **linear**：匀速过渡，速度不变，等价于 `cubic-bezier(0, 0, 1, 1)`。
- **ease**：慢速开始，中间加速，最后慢速结束，等价于 `cubic-bezier(0.25, 0.1, 0.25, 1)`。
- **ease-in**：缓慢开始，后续加速，等价于 `cubic-bezier(0.42, 0, 1, 1)`。
- **ease-out**：快速开始，缓慢结束，等价于 `cubic-bezier(0, 0, 0.58, 1)`。
- **ease-in-out**：缓慢开始和结束，中间加速，等价于 `cubic-bezier(0.42, 0, 0.58, 1)`。

### 自定义过渡曲线

- **cubic-bezier(\*n\*, \*n\*, \*n\*, \*n\*)**：自定义过渡曲线，值在 `0` 到 `1` 之间。例如：

- ```css
  transition-timing-function: cubic-bezier(0.5, 0, 0.5, 1);
  ```

### 过渡属性参数解释

- **属性名**：如 `background-color`，定义要过渡的CSS属性。
- **持续时间**：过渡效果的持续时间（如 `0.2s`）。
- **过渡函数**：定义过渡效果的速度曲线，如 `linear`、`ease`。
- **延迟时间**：定义过渡效果何时开始（如 `0s` 为无延迟）。

## transform 旋转属性

### 常用 `transform` 转换属性

- **无转换**：`none` – 无任何转换。
- **2D 转换**：
  - `matrix(n, n, n, n, n, n)`：2D 矩阵转换（6个值）。
  - `translate(x, y)`：2D 平移转换。
  - `scale(x, y)`：2D 缩放转换。
  - `rotate(angle)`：2D 旋转转换，按指定角度旋转。
  - `skew(x-angle, y-angle)`：2D 倾斜转换。
- **3D 转换**：
  - `matrix3d(n, n, ..., n)`：3D 矩阵转换（16个值）。
  - `translate3d(x, y, z)`：3D 平移转换。
  - `scale3d(x, y, z)`：3D 缩放转换。
  - `rotate3d(x, y, z, angle)`：3D 旋转转换，指定 x、y、z 轴和角度。
  - `perspective(n)`：设置 3D 透视视图。

### 单轴转换

- **平移**：
  - `translateX(x)`：仅沿 X 轴平移。
  - `translateY(y)`：仅沿 Y 轴平移。
  - `translateZ(z)`：仅沿 Z 轴进行 3D 平移。
- **缩放**：
  - `scaleX(x)`：沿 X 轴缩放。
  - `scaleY(y)`：沿 Y 轴缩放。
  - `scaleZ(z)`：沿 Z 轴进行 3D 缩放。
- **旋转**：
  - `rotateX(angle)`：沿 X 轴旋转（3D）。
  - `rotateY(angle)`：沿 Y 轴旋转（3D）。
  - `rotateZ(angle)`：沿 Z 轴旋转（3D）。
- **倾斜**：
  - `skewX(angle)`：沿 X 轴倾斜。
  - `skewY(angle)`：沿 Y 轴倾斜。

```css
/* 2D 旋转 */
transform: rotate(45deg);
/* 3D 旋转 */
transform: rotate3d(1, 1, 0, 45deg);
/* 缩放 */
transform: scale(1.5, 1.5);
/* 平移 */
transform: translate(50px, 100px);
```



## 音频audio

```html
<audio src="音频资源路径" controls autoplay loop muted></audio>
```

```js
// 播放事件
audioElement.onplay = () => console.log('音频开始播放');
// 暂停事件
audioElement.onpause = () => console.log('音频已暂停');
// 播放时间变化
audioElement.ontimeupdate = () => console.log(`当前时间: ${audioElement.currentTime}s`);
// 可以播放时
audioElement.oncanplay = () => console.log('音频可播放');
// 播放结束
audioElement.onended = () => console.log('音频播放结束');
// 拖动进度条完成
audioElement.onseeked = () => console.log('拖动完成');
// 正在拖动进度条
audioElement.onseeking = () => console.log('正在拖动');
// 音量改变事件
audioElement.onvolumechange = () => console.log('音量已改变');
```

```js
audioElement.play();    // 播放音频
audioElement.pause();   // 暂停音频
audioElement.load();    // 重新加载音频

audioElement.loop = true;                     // 设置音频循环
console.log(audioElement.currentTime);        // 当前播放时间
console.log(audioElement.duration);           // 音频总时长
audioElement.volume = 0.5;                    // 设置音量
audioElement.playbackRate = 1.5;              // 设置播放速度
```

## 拖放拖拽

```css
<div id="box" class="box" draggable="true"></div>  <!-- 设置可拖拽属性 draggable="true" -->
<div id="target" class="target"></div>  <!-- 拖拽的目标区域 -->
```

```js
// 获取元素
const box = document.getElementById('box');
const target = document.getElementById('target');

// 开始拖拽事件，作用于被拖拽元素
box.ondragstart = function () {
    console.log('开始拖拽');
};

// 结束拖拽事件，作用于被拖拽元素
box.ondragend = function () {
    console.log('结束拖拽');
};

// 被拖拽元素进入目标区域事件，作用于目标元素
target.ondragenter = function () {
    console.log('被拖拽元素进入目标元素');
};

// 在目标元素内拖拽，作用于目标元素
target.ondragover = function(e) {
    // 阻止默认行为，使得 ondrop 可以触发
    e.preventDefault();
    console.log('被拖拽元素在目标元素里面');
};

// 拖放事件，作用于目标元素
target.ondrop = function () {
    console.log('拖放完成');
    this.appendChild(box);  // 将被拖拽元素添加到目标元素中
};
```

## 本地储存

### localStorage（本地存储）

- **设置本地存储**：

  ```js
  localStorage.setItem('name', 'kevin');
  ```

  **存储引用数据类型（序列化）**

  ```js
  const books = [{name: 'HTML'}, {name: 'CSS'}, {name: 'JS'}];
  localStorage.setItem('books', JSON.stringify(books));  // 序列化
  ```

  **获取本地存储**：

  ```js
  const storedBooks = localStorage.getItem('books');
  const booksArray = JSON.parse(storedBooks);  // 反序列化
  ```

  **删除单个存储项**：

  ```js
  localStorage.removeItem('name');
  ```

  **清空所有本地存储**：

  ```js
  localStorage.clear();
  ```

  

### sessionStorage（会话存储）

- **设置会话存储**：

  ```js
  sessionStorage.setItem('name', 'kevin');
  ```

  **获取会话存储**：

  ```js
  const storedApple = sessionStorage.getItem('apple');
  const appleObject = JSON.parse(storedApple);  // 反序列化
  ```

  

### Cookie 操作

- **设置 Cookie（有效时间 30 分钟）**：

  ```js
  const time = new Date().getTime() + 30 * 60 * 1000;
  const date = new Date(time).toUTCString();
  document.cookie = `cookieKey=cookieValue;expires=${date}`;
  ```

  **获取所有 Cookie**：

  ```js
  const cookieData = document.cookie;
  const cookies = cookieData.split('; ');
  const cookieObject = {};
  
  cookies.forEach(cookie => {
    const [key, value] = cookie.split('=');
    cookieObject[key] = value;
  });
  ```

  **删除 Cookie（设置过期时间）**：

  ```js
  const expires = new Date('1970-01-01 00:00:00').toUTCString();
  document.cookie = `fruit=;expires=${expires}`;
  ```

  

## woker

**主线程（创建和使用 Worker）**

```js
// 创建一个新的 Web Worker
var worker = new Worker('./myworker.js');

// 向 Worker 发送数据
worker.postMessage('Some data');

// 接收 Worker 线程返回的数据
worker.onmessage = function(e) {
    var data = e.data;
    console.log('接收到的数据：', data);
};

// 终止 Worker 线程
worker.terminate();
```

**Worker 线程**（`myworker.js`）

```js
// 监听主线程发来的消息
onmessage = function(e) {
    var content = e.data;
    console.log('收到主线程的数据：', content);
    
    // 处理并返回结果给主线程
    var result = `Processed: ${content}`;
    postMessage(result);  // 发送结果回主线程
};
```

# ES6

## 箭头函数

```js
let gn1 = () => {};
let gn2 = a => {};
let gn3 = (a, b) => {};
let gn5 = (a, b) => a + b + 16;
let gn6 = (name, age) => ({name, age});  // 简化属性名
```

## 解构赋值

```js
let { height: studentHeight, technology: tech, name: studentName, weight, address: { city: ci } } = {
    name: '小明',
    height: 170,
    weight: 130,
    technology: ['编程', '打篮球'],
    address: { city: '广州' }
};
```

## 拓展运算符

```js
// 复制对象并添加/合并属性
let student = { name: '小明', height: 170, weight: 120, color: '黄色' };
let obj = { book: 'HTML' };
let person = { ...student, price: 100, address: '广州', ...obj };

// 复制数组
let arr3 = ['电动车', '自行车', '泥头车'];
let arr4 = [...arr3];
arr3.push('水泥车');  // arr4 不受影响
console.log('arr3 ==> ', arr3);
console.log('arr4 ==> ', arr4);

// 扩展运算符在函数参数中的使用
function sum1(...params) {
    return params.reduce((total, v) => total + v, 0);
}
let t1 = sum1(100, 52, 60);
let t2 = sum1(10, 24);
```

## 	String拓展

```JS
let t = 'this is an apple';
//includes(char[,index]): 查找是否包含指定字符串, 返回一个布尔值, char: 查找的字符串, index: 开始查找位置, 默认为0
let isHas3 = t.includes('is', 4);

//startsWith(char[, index]): 匹配开头的字符串, 返回一个布尔值, char: 查找的字符串, index: 开始查找位置, 默认为0
let isHas4 = t.startsWith('is', 2);

//endsWith(char[, n]): 匹配结尾的字符串, 返回一个布尔值, char: 查找的字符串, n: 前n个字符(n不是下标)
let isHas5 = t.endsWith('i', 6);
```

## 数组拓展

```js
//Array.from(): 将类数组对象转换为数组
//Array.of(): 将一组值转化为数组
let myBook = book.map(function (value, index, arr) {
      //value: 数组的元素
      //index: 数组的元素下标
      //arr: 原数组
      console.log('this ==> ', this);
      return `<li data-index="${index}">${value}</li>`;
}, o1)

//Array.prototype.find(fn[, fn的this指向]): 查找数组元素, 如果return true, 返回当前元素, 找不到返回undefined
let animal = ['老鹰', '白兔', '老虎', '青龙'];
let isHas = animal.find(function (a, b, c) {
      console.log('find a ==> ', a);
      console.log('b ==> ', b);
      console.log('c ==> ', c);

      console.log('this ==> ', this);

      return a === '老鹰';
}, {aa: 1});
```

## 对象拓展

### 简写

```js
// 简写
let animalName = '鸭子';
let k = 'a';
let fnName = 'getAnimalName';
let animal = {
    animalName,
    color: '淡黄色',
    [k]: '10km/h',
    swim() { console.log(this.animalName + '会游泳'); },
    getColor() { console.log('this.color ==> ', this.color); },
    [fnName]() { console.log('this.animalName ==> ', this.animalName); }
};
```

### defineProperty( )方法

```js
// 定义不可写、不可删除、不可枚举的属性
Object.defineProperty(data, 'height', {
    writable: false,
    configurable: false,
    enumerable: false
});
```

## set数据结构

```js
// 创建Set去重
let book = ['html', 'css', 'js', 'css', 'js', 'es6'];
let myBook = new Set(book);
let bookData = [...myBook];  // 将Set转换为数组
console.log('bookData ==> ', bookData);

// Set基础操作
let fruit = new Set();

// 1. 添加元素
fruit.add('黑布林');

// 2. 获取keys迭代器并遍历
for (let key of fruit.keys()) {
    console.log('key ==> ', key);
}

// 3. 获取values迭代器并遍历
for (let value of fruit.values()) {
    console.log('value ==> ', value);
}

// 4. 获取entries迭代器并遍历，返回[key, value]对
for (let [key, value] of fruit.entries()) {
    console.log(`[key, value] ==> ${key}, ${value}`);
}

// 5. 判断是否存在指定元素
let isHas = fruit.has('葡萄1');

// 6. 删除元素或清空
fruit.delete('黑布林'); // 删除一个元素
fruit.clear();           // 清空Set

// 7. 获取Set大小
console.log('Set size ==> ', fruit.size);
```

## 类的继承

```js
class Person {
      constructor(name, height) {
        this.name = name;
      }
      run() {
        console.log(this.name + '会跑步');
      }
}
//继承关键字 extends
class DancerPerson extends Person {
      dancer() {
        console.log(this.name + '会跳舞');
      }
}
//重写
class SwimPerson extends Person {
      //在子类中重写Person的contructor
      constructor(name, height, speed) {
        //super方法指向于Person的contructor 重写中的继承属性
        super(name, height);
        //扩展子类自身的属性
        this.speed = speed;
      }

      //重写Person的run方法
      run() {
        let text = this.name + '的跑步速度为' + this.speed;
        console.log('text ==> ', text);
      }
}

//创建实例对象
let mark = new SwimPerson('mark', 172, '5km/h');
```

## 类的三大状态

```js
let o = {
      name: 'kevin',
      age: 20
};
//防扩展: 不能添加新的属性, 可删除可修改
Object.preventExtensions(o);
//判断对象是否防扩展
let isYes1 = Object.isExtensible(o);
//密封对象: 可修改属性, 不可添加新的属性和删除属性
Object.seal(o);
//判断对象是否密封
let isYes2 = Object.isSealed(o);
//冻结对象
Object.freeze(o);
//判断对象是否冻结
let isYes3 = Object.isFrozen(o);
//es6	Reflect: 扩展Object的方法
let m = Reflect.apply(Math.max, Math, arr);
class Animal {
      constructor(name, color) {
        this.name = name;
        this.color = color;
      }
}
//Reflect.construct(构造函数, 构造函数的参数数组)
let yellowDuck = Reflect.construct(Animal, ['小黄鸭', '黄色']);
//删除对象属性
//Reflect.deleteProperty(目标对象, 属性名)
//定义属性
Object.defineProperty(book, 'author', {
    value: 'kevin',
})
// Object.defineProperties(book, {
    //   author: {
    //     value: '小明',
    //     writable: true,
    //     configurable: true,
    //     enumerable: true
    //   },
    //   city: {
    //     value: '广州',
    //     writable: true,
    //     configurable: true,
    //     enumerable: true
    //   }
    // })
//获取键名
let keys = Reflect.ownKeys(book);
```



# JavaScript

## 数据类型

```js
string 
number 
boolean 
null 
undefined 
symbol
object
array
function
```

## **原型对象（prototype）**

JS是一种基于原型对象的函数式编程语言

原型是一个对象，词汇：**prototype**

是每个构造函数都有这个prototype属性

**它是JS中本身就存在的一种机制**

凡是挂载在原型对象上的属性和方法，都可以被其所属构造函数的实例对象使用。

内置构造函数：

```js
// 1.0 JS内置的构造函数
// 官方文档构造函数名称首字母都是大写
// String  Number  Boolean Array Object Function  Date

// 2.0 字符串构造函数的原型
// var obj = String.prototype
// console.log(obj);
console.log(String);// 构造函数（抽象的）
console.log(String.prototype);// 构造函数的原型

// 创建String的实例
var o1 = new String("hello");
console.log(o1);// String {"hello"} (具体的)

// 声明字符串变量
var str = "hello";// 这个字符串也是String的实例 (具体的)
console.log(str);
console.log(str.split(""));

// 3.0 构造函数的原型
// 每个构造函数身上都有原型对象,
// 凡是出现在原型对象上的属性和方法（通常是把方法添加原型上），都可以被其所属构造函数的实例对象使用
String.prototype
Number.prototype
Boolean.prototype
Array.prototype
Object.prototype
Date.prototype
```

总结： 

构造函数可以创建对象并且返回该对象（this）

构造函数作用域可以通过this添加属性

构造函数的原型（prototype）上添加方法

属性用于记录数据,方法用于处理业务逻辑

### **隐式原型   __proto__**

```js
// __proto__ 这个属性是每个实例对象都有的属性 , [[prototype]]
// 原型：prototype ,是构造函数的属性    
// 隐式原型：__proto__ ,是实例对象的属性  

// 构造函数： Array      People
// 实例对象： var arr = new Array()   var xiaoming = new People()

// 示例：
function People(){}
var xiaoming = new People();
console.log(People.prototype);// 原型
console.log(xiaoming.__proto__);//隐式原型

// 在隐式原型上添加的方法
xiaoming.__proto__.sayHello = function(){
    console.log("hello world!");
}
People.prototype.sayHello2 = function(){// 常用编码方式
    console.log("hello world!222");
}

console.log(People.prototype === xiaoming.__proto__ );// true

xiaoming.sayHello();// hello world!
xiaoming.sayHello2();// hello world!222
```

### **构造属性   constructor**

```js
// constructor 这个属性可以找出原型所属的构造函数
// 构造函数
function People(){}
// 实例对象
var xiaoming = new People();
//  打印原型
console.log(People.prototype);// {constructor: ƒ}
console.log(People.prototype.constructor);// 构造函数
console.log(People.prototype.constructor === People);// true
// 通过实例对象的隐式原型
console.log(xiaoming.__proto__.constructor === People);// true
```

### **原型链**

是构造函数的原型(prototype)和实例对象的隐式原型(__proto__ ) 所形成的链式结构，称之为原型链。

作用： 属性和方法只要在原型链上，那么他们就能被所属构造函数的实例对象使用！

```js
// 自定义构造函数
function App() {
    // 添加属性
    this.width="100px";
}
// App构造函数原型添加方法(随机整数)
App.prototype.getRandom = function(min,max){
    return Math.round(Math.random()*(max-min)+min);
}
// Object 构造函数原型添加方法(获取坐标)
Object.prototype.getPos = function(){
    return {
        x: 100,
        y: 200
    }
}


// 实例对象(a1)
var a1 = new App();

// 构造函数: App
// App原型对象: App.prototype
// Object原型对象: Object.prototype
console.log(a1.width);// 100px
var num = a1.getRandom(50,200);
console.log(num);// 随机整数
var point = a1.getPos();
console.log(point);// {x: 100, y: 200}

console.log(a1);// 实例对象
console.log(a1.__proto__);// App.prototype
console.log(a1.__proto__.__proto__);// Object.prototype
console.log(a1.__proto__.__proto__.__proto__);// null (链式结构结束的位置)

// 上述的链式结构,我们叫做原型链
// 可以把属性和方法添加到原型链上,实现数据和方法的共享.
```

## arguments对象 

```js
// 1.0 加法函数
function add() {
// console.log(arguments);
    var x = arguments[0];// 代表实参 2
    var y = arguments[1];// 代表实参 98
    var total = x + y;
    console.log(total);
}
add(2,98)

// 2.0 调用函数
// add(2, 98);
// arguments 具有数组的特征和length属性,但是不能调用数组的API.
// arguments 是个伪数组,可以通过索引值取值
// arguments 仅仅可以在函数作用域中使用
// console.log(arguments);// 报错

// 1.0 定义函数
var foo = function() {
    console.log(arguments);
    // arguments.length 等于 0 ,说明没有实参
    // arguments.callee 代表函数本身
    console.log( foo === arguments.callee);// true 
}

// 2.0 调用函数
// foo("red");
```



## 浅拷贝

```js
// 简单的数据结构(仅仅有一层数据)：
// 例如：
var arr = ["red","green","blue"];
var point = {x: 100, y: 200, color: "pink"}
// var obj = point;// 复制地址， 任何一方的数据修改，会互相影响
// 复制arr或point的数据
// 浅拷贝：
// 复制数据集合中的第一层数据，而且复制数据的过程中，不区分数据类型。
// 适用于复制简单的数据结构

// 编码：
function simpleCopy(elements){
    // 定义空的数据集合 是[数组]呢? 是{对象}呢?
    var newData = Array.isArray(elements) == true ? [] : {};
    // 复制数据了 
    for(var key  in  elements){
        // 复制
        newData[key] = elements[key];
    }
    // 循环结束，完成复制
    return newData;
}

// 拷贝 arr
var res = simpleCopy(arr);
res[0] = "红色";//新数据变化了
console.log(res);// ["红色", "green", "blue"]
console.log(arr);// ["red", "green", "blue"]


// 拷贝 point
var obj = simpleCopy(point);
obj.x = 888;  //新数据变化了
console.log(obj); //  {x: 888, y: 200, color: "pink"}
console.log(point);// {x: 100, y: 200, color: "pink"}


// 针对简单的数据结构：
// 新的数据修改了，不会影响原来的数据！
```



## 深拷贝

```js
// 复杂的结构：
// 数组嵌套对象
// 对象嵌套数组
// 数组
var arr2 = [{color:"red"},{color:"green"},{color:"blue"},"orange"]
// 对象
 var point = {
     msg:"中心坐标",
     result: [100, 200, "pink",["内容"]]
}

// 这种数据结构就不能使用浅拷贝的逻辑复制数据
// 深拷贝：
        // 复制数据的时候，会深层次的复制，每一层数据都需要判断数据类型
        // 如果是基本数据类型，那么就直接赋值
        // 如果是引用数据类型，那么就继续执行递归函数，进行深层次的复制，直到复制的数据为基本数据类型为止

// 编码实现：
function deepCopy(elements){ // elements 是形参，代表需要复制的集合
    // 判断当前的数据集合是数组，还是对象
    var newData = Array.isArray(elements) == true ? [] : {};
    // 循环数据集合
    for(var key in elements){
        // 判断复制的数据是何种数据类型
        if(typeof elements[key] === "object" ){ // object 说明这是引用数据类型 [] {}
            // 复制数据，通过递归实现深层次的复制
            // 左侧是新数据 = 待复制的数据
            newData[key] = deepCopy(elements[key]);
        }else {
            // 执行的传值（复制基本数据类型的数据）
            // 复制数据，直接赋值
            newData[key] = elements[key];
        }
    }
    // 循环结束了，方可得到拷贝的新数据
    // 返回新数据
    return newData;
}
// 拷贝 point
var obj2 = deepCopy(point)
// 修改新数据
obj2.result[2] = "粉色";
console.log(point); // 原数据
console.log(obj2);  // 新数据
// 以下代表两个引用地址
// var o1 = {}
// var o2 = {}
```



## **显式转换**

全局函数

String()

Number()

Boolean()

Symbol()

```js
// 字符串  String()
// console.log(true); // true 布尔值
// console.log(typeof true); // boolean
// true  -----> "true"
// var str = String("true");
// console.log(str);// true  字符串
// console.log(typeof str);// string
// console.log(typeof String(100)); // string
// console.log(typeof String(null)); // string

// ============================================

// 数字 Number()
// console.log(typeof "100");// string
// console.log(Number("100"));// 100
// console.log(typeof Number("100"));// number
// console.log(Number("xxx100"));// NaN
// console.log(Number("100xxx"));// NaN  如果仅仅提取字符串中的数字： parseInt("100xxx"); // 100


// ============================================
// 布尔值 Boolean()
// console.log("hello"); // hello
// console.log(Boolean("hello"));// true
// console.log(Boolean(1000));// true
// console.log(Boolean("")); // false
// console.log(Boolean(0));  // false

备注： 先暂时了解
Object()
Array()
Function()

// 以下作为构造函数用于产生指定的数据
// var arr = ["red"];
// 通过Array构造函数创建数组实例： 
// var arr2 = new Array("red");
// console.log(arr2);// ["red"]  数据

// var obj = {}
// 通过Object构造函数创建对象实例：
// var obj2 = new Object();
// obj2.width = "100px";
// console.log(obj2);//          对象

// var f = function(){}
// var f = new Function("console.log('这是函数xxx')");
// console.log(f);//              函数
// f();// 这表示函数的调用
```

parseFloat()  **转浮点数**

parseInt()      **转整数**

```js
// 100 , 101, 6            整数
// 99.9999 , 12.11 , 0.5   浮点数(小数点)

// 1)  parseFloat
// 参数：  字符串
// 返回值： 浮点数（数字）
// 作用：  把字符串解析成 浮点数
var str = "99.99$";
var price =  parseFloat(str);
console.log(price); // 99.99
console.log(typeof price);  // number

console.log(parseFloat("xxx100"));// NaN
console.log(parseFloat("100xxx"));// 100
console.log(parseFloat("100.11xxx"));// 100.11
console.log(parseFloat(" 100.11xxx "));//100.11
console.log(parseFloat(" 100yy.11xxx "));// 100

// 总结：
// parseFloat 方法，可以把一个数字开头的字符串解析成浮点数
// 如果字符串不是数字字符开头，解析成非数值（NaN）

console.log("--------");

// 2)  parseInt
// 另外一个含义：强制转换为整型
// 参数：1.字符串   2.基数（可选） 2 ~ 26
// 返回值：整数或 NaN
// 作用： 把字符串解析为整数
var width = "100px";
var v1 = parseInt(width);
console.log(v1);// 100
console.log(typeof v1);// number

console.log(parseInt("px100"));// NaN
console.log(parseInt("100xxx"));// 100
console.log(parseInt("100.66xxx"));// 100
console.log(parseInt("100yy66xxx"));// 100
console.log(parseInt(" 98yy66xxx  "));// 98


// 总结：
// parseInt 方法， 可以把以数字字符开头的字符串解析成整数
// 如果字符串不是以数字字符开头，解析的结果就是NaN

console.log("--------");
// 备注：
//  parseInt(string , radix) // 参数1： 字符串  ， 参数2： 可选参数（不需要深究）
console.log(parseInt("13", 1));  // NaN
console.log(parseInt("13", 2));  // 1
console.log(parseInt("13", 14)); // 17
console.log(parseInt("a", 16));  //  10
console.log(parseInt("b", 16));  //  11
console.log(parseInt("f", 16));  //  15

//  parseInt的第一个参数 ： 字符串
//  parseInt的第二个参数 ： 基数
//  例如 ： parseInt("f", 16)
//  意思把 16进制的  "f" 字符串 转成 10进制的数字
//  作用：把指定进制的字符串，解析成10进制的数字


// 以下为十六进制的数字
// 1-9 10 11 12 13  14 15 
// 1-9 a   b  c  d  e  f 
```



## **隐式转换**

```js
// == 值相等运算符 
// 字符串
var str = ""; //  false   0 
// 数字
var num = 0; //  false  ""
// 布尔值
var isOpen = false;  // 0  ""
// 记忆： 
console.log("" == false );// true
console.log("" == 0 );// true
console.log("" == [] );// true
console.log(0  == false );// true
console.log(1  == true );// true
console.log(null  == undefined );// true

console.log("-----");
// 判断语句
var isMouseDown = false;
if(isMouseDown == true){
console.log("第1句话");
}
if(isMouseDown){// 隐式转换 isMouseDown == true
console.log("第2句话");
}

if(str){//  ""
console.log("第3句话");
}
if(num){//  0
console.log("第4句话");
}

var arr = [];
if(arr){//  例外：空数组存在,表示条件是成立
console.log("第5句话");
}

console.log("-----");
// 运算符
// +  
// 字符串 + 数字 ，表示字符串拼接(转string类型)
console.log("11" + 22);// 1122 
console.log(11 + 22);// 33 
console.log("11" + true);// 11true   字符串
console.log("11" + "hello");// 11hello    字符串
console.log("11" + undefined);// 11undefined    字符串

// - 
// 数字字符串 - 数字 ， 表示转number类型
console.log("100" - 0);// 100 
console.log(typeof ("100" - 0));// number

// 非数字字符串 - 数字 ， 表示非数字（NaN）
console.log("abc" - 0); // NaN
```

## 字符串的操作【相关API】

```js
// 定义字符串
var str = "Today is sunny day!";

// 属性 length ,记录字符串的长度
// 以后判断输入框是否有值 str.length == 0
// console.log(str.length);

// 循环字符串
for(var i = 0 ; i < str.length ; i ++){
	// 循环输出每个字符
	// console.log(str[i]);
}

// Today is sunny day!
// 0123456789

// indexOf
首次出现的字符串下标
// 参数: 可以是字符或者字符串
// 返回值： 字符串中首次出现的字符的下标（索引值） ;  > -1 , 表示字符串存在指定的文本
// 功能： 通过字符(串)找出对应的下标，否则，不存在指定的字符，返回值为 -1

// 例如: 
// images/demo.txt
// var src = "images/demo.jpg";
// src.indexOf("jpg") > -1 , 说明这是一个图片路径


// lastIndexOf 
// 返回值： 字符串中最后一次出现的字符的下标
最后一次出现的字符下标
// console.log(str.lastIndexOf("o"));// 1


// split
分割字符，返回数组
// console.log(str.split());// ["Today is sunny day!"]
// console.log(str.split(""));// ["T", "o", "d", "a", "y", " ", "i", "s", " ", "s", "u", "n", "n", "y", " ", "d", "a", "y", "!"]
// console.log(str.split(" "));//  ["Today", "is", "sunny", "day!"]
// 参数：分割点字符
// 返回值： 把字符串切割成数组并返回 （数组）
// 功能： 把字符串切割成数组


// charAt
返回值下标对应的字符
// console.log(str.charAt(0));// T
// console.log(str.charAt(6));// i
// 参数： 下标（索引值）数字
// 返回值： 返回值下标对应的字符
// 功能： 通过下标检索相应的字符并且返回

// charCodeAt
// unicode编码（每个字符都有相应的数值）和字符一一对应的数值
var demo = "abcA"
// console.log(demo.charCodeAt(0));// 97
// console.log(demo.charCodeAt(1));// 98
// console.log(demo.charCodeAt(3));// 65

// replace
替换成指定的文本
console.log(str.replace("Today","*****"));//  ***** is sunny day!
// 参数： 1. 选中的文本 2. 替换成指定的文本
// 返回值： 被替换之后的字符串
// 功能： 替换文本


// slice
slice() 方法可从已有的数组中返回选定的元素。
slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
注意： slice() 方法不会改变原始数组。


// substr
var str = "Hello world!";
var n = str.substr(2,3)
llo
substr() 方法可在字符串中抽取从 开始 下标开始的指定数目的字符。
提示： substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。

// substring
```

## **数组操作【API】**

```js
// 数组： 有序的数据集合。根据索引值存取数据
var arr = [];
// 具有length属性 (数量)
// console.log(arr);// []

// 添加数据
                            往数组的末端
// push
// 参数：数据
// 返回值：添加数据之后的数组的长度
// 功能：往数组的末端(索引值：length-1)添加数据
arr.push("red");
arr.push("green");
arr.push("blue");
// console.log(arr);// ["red", "green", "blue"]

// unshift
                           往数组的首位
// 功能：往数组的首位（索引值:0）添加数据
arr.unshift("pink");
arr.unshift("orange");
// console.log(arr);//["orange", "pink", "red", "green", "blue"]


// 删除数据
                           删除数组最后一个数据
var elements = ["div1","div2","div3","span1"];
// console.log(elements);// ["div1", "div2", "div3", "span1"]
// pop
// 参数： 无
// 返回值： 被删除最后一个元素。
// 功能：删除数组最后一个数据
var v1 = elements.pop();
console.log(v1);// span1
console.log(elements);// ["div1", "div2", "div3"]


// shift
                            删除数组的第一个数据 
// 此刻的数组:  ["div1", "div2", "div3"]
// 参数：无
// 返回值: 被删除的第一个元素
// 功能: 删除数组的第一个数据
var v2 = elements.shift();
console.log(v2);// div1
console.log(elements);// ["div2", "div3"]
```

```js
// 调用者： 数组 

                            splice 删除指定位置的数据（ 影响原来的数组 ）
// 参数：1.索引值， 2.删除多少个（数量）
// 返回值：数组， 被删除的数据包含在数组中
// 功能：删除数组指定位置的数据，以及返回这个被删除的数据数组
// splice()
var arr = ["red","green","blue","小明","小红","小米"];
        //  0      1       2      3      4    5
var res = arr.splice(2,2);
// console.log(res);// ["blue","小明"]    被删除的数据数组
// console.log(arr);// ["red","green","小红","小米"]  原数组


// 参数：1.索引值 , 2. 被删除的数量  3.插入数据(填充数据)
// 返回值： 数组， 被删除的数据包含在数组中
// 功能： 删除数组指定位置的数据，还可以插入数据，并且返回被删除的数据数组
var arr2 = ["red","green","blue","小明","小红","小米"];
            //  0      1       2      3      4     5
var res2 = arr2.splice(2,2,"蓝色","小小");
// console.log(res2);//["blue", "小明"]
// console.log(arr2);// ["red", "green", "蓝色", "小明", "小红", "小米"]



						 slice（不会影响原数组）
// 参数： 1.0 开始索引值 ， 如果是负数，从数组末端（length-1）进行截取
// 返回值：数组，从数组中指定位置截取出来的数据
// 功能： 截取数组中指定位置的数据
var arr3 = ["red","green","blue","小明","小红","小米"];
           //  0      1       2      3      4     5
console.log(arr3);// ["red", "green", "blue", "小明", "小红", "小米"]
console.log(arr3.slice(3));// ["小明", "小红", "小米"]
console.log(arr3.slice(-1));// ["小米"]

// 参数2：1.0 开始索引值  2.0 结束索引值 ; (包左不包右)
console.log(arr3.slice(0,2)); // ["red", "green"]
console.log(arr3.slice(3,5));// ["小明","小红"]
```

```js
 var arr3 = ["red","green","blue","小明","小红","小米"];

join()
// 参数：可选参数 " ";
// 返回值： 返回数据拼接好字符串
// 功能：把数组中的各项数据拼接成字符串 
var str1 = arr3.join();
console.log(str1);// red,green,blue,小明,小红,小米
console.log(typeof str1);// string
var str2 = arr3.join(" ");
console.log(str2);// red green blue 小明 小红 小米


concat()
// 参数： 目标数组
// 返回值： 合并之后的数组
// 功能： 合并数组
var a1 = ["red"];
var a2 = ["green"];
var a3 = ["blue"];
var res = a1.concat(a2,a3)
console.log(res);//["red", "green", "blue"]


sort()
// 参数：无
// 返回值：排序完成的数组
// 功能：排序
var arr4 = [80,60,70,50,10];
var res4 = arr4.sort();
console.log(res4);// [20, 50, 60, 70, 80]
```

```js
// 升序 : 从小到大的排序
// 降序 ：从大到小的排序
// 1.0 定义数组
var arr = [80,40,70,60,8,9,20,100];
// 调用者: arr
// 参数: 匿名函数 (回调函数)
// function(){} 在sort函数作用域中被调用了
// 在sort函数封装过程中被调用了
// 这个匿名函数同时具有形参
var res1 = arr.sort(function(prev,next){
    return prev - next;// 升序
})
console.log(res1);// [20, 40, 60, 70, 80, 100]
var res2 = arr.sort(function(prev,next){
    return next - prev;// 降序
})
console.log(res2);//  [100, 80, 70, 60, 40, 20]


filter()过滤
this.showJujia=this.showJujia.filter(function(e){
     return e.isPlus
})


// 匿名函数(没有名字的函数)
// function(){}       // 报错
// (function(){})     // 正确的写法,不报错
// (function(){})()   // 表示匿名函数的调用 [立即执行函数]
// (function(){console.log("test");})()  // 表示匿名函数的调用 [立即执行函数]
// 把函数作为参数传递到另一个函数作用域中调用
// 作为参数的函数,我们叫做回调函数
伪数组转换成数组：Array.slice.call( 伪数组 )
```

## **数学对象Math (内置对象)**

```js
PI (圆周率)
// 3.14
// console.log(Math.PI);


ceil (向上取整)
// 99.1
// 99.5
console.log(Math.ceil(99.1));// 100
console.log(Math.ceil(99.2));// 100
console.log(Math.ceil(99.5));// 100

floor (向下取整)
// 1.1
console.log(Math.floor(1.1));// 1
console.log(Math.floor(-0.1));// -1

round (四舍五入取整)
console.log(Math.round(14.1));// 4
console.log(Math.round(14.4));// 4
console.log(Math.round(24.5));// 5

random (随机数)
console.log(Math.random()); // 0 ~ 1 之间的小数 随机的小数
console.log(Math.random() * 20); // 0 ~ 20 之间的小数 
console.log(Math.random() * 5 + 15); // 15 ~ 20 之间的小数 
// 1. 首先获取 0 ~ 5 之间的随机小数 （20 - 15 = 5）
// 2. 然后再加上 15 (最小值)
// 3. 得到的结果就是在指定范围之间
// 0 ~ 256 之间的随机整数
var num = Math.random() * 256;
console.log(Math.floor(num)); // 0 ~ 256之间的随机整数
// 50 ~ 81 之间的随机整数 【最小值~最大值】
// 81 - 50 = 31 
var code = Math.random()* 31 + 50;
console.log(Math.floor(code));//50 ~ 81 之间的随机整数
```

```js
// 三角函数的API
// 已知条件：
// 1. 角度 30°
// 2. 斜边（半径）  150

// 计算弧度（改变角度的值，元素围绕指定中心旋转）
var val = 30 * Math.PI / 180;
// 计算水平坐标位置
var x = Math.cos(val) * 150;
// 计算垂直坐标位置
var y = Math.sin(val) * 150;
console.log(x);
console.log(y);

// 渲染字符串
var str = ''
    str += '<div class="container">'
    str += '    <div style="left:'+x+'px; top:'+y+'px;"  class="point"></div>'
    str += '</div>'

document.write(str);
```

### **数字转字符串（进制）**

```js
// 数字
var num = 100;
// 数字转换字符串
var str = num.toString();
console.log(typeof str);
console.log(str);

// 参数：基线（进制）
var v1 = 15;
var r1 = v1.toString(2);
console.log(r1);// 1111

var v2 = 12;
var r2 = v2.toString(2);
console.log(r2);// 1100


var v3 = 11;
var r3 = v3.toString(16);
console.log(r3);// b 
```

### **保留多少位小数**

```js
// 小数
var num = 3.1414926;
// 保留两位数 (四舍五入)
console.log(num.toFixed(2));// 3.14
console.log(num.toFixed(1));// 3.1
console.log(num.toFixed(3));// 3.141
```

### **处理浮点数进度丢失的问题**

```js
// 计算机能够识别是二进制数字
// 把运算结果转十进制过程出现了精度丢失
// 主要是浮点型数据才会出现这种问题，整型数据不会
// var x = 0.1;
// var y = 0.2; // 0.30000000000000004 

var x = 0.2;
var y = 0.7;
var res = x + y ;
console.log(res);// 0.8999999999999999

// 把浮点数转整数再运算即可
var res2 = (x * 1000 + y * 1000) / 1000;
console.log(res2);// 解决的方法
```

## **日期对象** **Date**

```js
// 获取日期和时间的信息 （get）
// 创建Date的实例（实例：具体数据）
// var dt = new Date("1999");
var dt = new Date();// 当前的时间
// console.log(dt);

// 年份
// var yy = dt.getFullYear();
// console.log(yy);// 2021
console.log(dt.getFullYear());// 2021

// 月份 (0~11)
// 八月份 下标 ： 7
// 把月份的数据存放于数组中 
// ["一月份","二月份","三月份","四月份","五月份","六月份","七月份","八份","九月份","十月份","十一月份","十二月份"]
console.log(dt.getMonth());// 7

// 日期
console.log(dt.getDate());// 5

// 星期
// ["星期天","星期一","星期二","星期三","星期四","星期五","星期六"]
//  0          1       2       3         4        5      6
console.log(dt.getDay());// 4

// 小时
console.log(dt.getHours());// 11
// 分钟
console.log(dt.getMinutes());// 39
// 秒钟
console.log(dt.getSeconds());// 35
// 毫秒
// 1秒 = 1000 毫秒 
console.log(dt.getMilliseconds());// 675
```

### **时间戳**

```js
// 定义变量，记录从1970年凌晨到现在的毫秒值（时间戳）
// var time = new Date().getTime();var dt = new Date();var time = dt.getTime();console.log(time);
// 1628145280353 (不是固定的)
// 时间戳：
// 计算开始值到结束值之间的相差的值（隔了多久时间）
// 例如：    
// 鼠标按下按钮到鼠标松开按钮,花了多长的时间?    
// 可以利用时间戳进行计算    
// 以上，如果相差的时间值，是小于 300 毫秒 ，可以视为 "轻触"    
// 如果时间超过500或1000毫秒，可以视为 "长按"
```

### **设置日期和时间**

```JS
var dt = new Date();
// console.log(dt);// Thu Aug 05 2021 14:43:20 GMT+0800 (中国标准时间)
// console.dir(dt);// 查看日期对象相关属性和方法

// 设置年份
// dt.setFullYear("1999")
// 设置月份 (0~11)
// 设置了二月份
// dt.setMonth(1)
// 设置日期  28 29 30 31
// dt.setDate(12)
// 设置小时  1天 = 24 小时
// dt.setHours(13)
// 设置分钟  1小时 = 60分钟
// dt.setMinutes(15)
// 设置秒钟  1分钟 = 60秒
// dt.setSeconds(50)
 // 设置毫秒  1秒 =  1000毫秒
//  dt.setMilliseconds(500)
//  console.log(dt.getMilliseconds());// 500
// 设置时间戳
// 获取当前的时间戳
var currentTime = dt.getTime();
// 计算未来的时间 = 当前的时间 + 间隔的时间毫秒值
// 两个小时之后
var time = 2 * 60 * 60 * 1000;
var futureTime = currentTime + time ;
// 设置时间戳
dt.setTime(futureTime);
// 控制台打印
console.log(dt);
```

## 排序

```js
//排序的方式
// 1. 双重循环（粗暴）
// 2. 冒泡排序
// 3. 数组 sort 方法
// 4. 插入排序
// 5. 快速排序（递归）

// 定义函数  mySort 
var mySort = function(array) {
    // 外循环数组
    for(var i = 0 ; i < array.length ; i ++){
        // 记录有序数组的索引值（下标）
        var j = i  -  1;
        // 记录每个无序数组的值
        var temp = array[i];
        // 内循环，根据条件做大小的比较
        while(j >= 0 && temp < array[j]){
            // 把有序数组中较大的数值往后一位移动
            array[j + 1] = array[j];
            // 一方面为了计算插入数据的下标（插入有序数组的）
            // 另一方面是为了继续当前的while循环
            j --;
        }
        // 当while循环结束，就可以插入数据
        array[j + 1] = temp;
    }
    // 整个for循环结束（数组完成排序）
    return array;
}

// 调用函数
var res = mySort([80,20,50,60,30]);
console.log(res);//[20, 30, 50, 60, 80]
```

### 快速排序

```js
// 快速排序（递归排序）
// 基本思想：
    // 1. 找出数组的中间位置（偏）基准
    // 2. 划分三个数组，左边数组，中间数，右边数组
    // 3. 比如。升序的逻辑
    // 递归的方式，把较小的数值存放于左边数组，把较大数值存放于右边数组
    // 重复上述操作，一直到数组的length属性值小于等于1位置

//  递归：
    // 1.函数的自身调用
    // 2.终止调用的条件

 // 定义数组
 var arr = [100,80,20,90,60];
 //  第一次执行函数  基准值 20   ; 5/2 == 2.5 parseInt(2.5) == 2
 // [].concat([20] , [100,80,90,60])  

 //  第二次执行函数  基准值 90  ; 4/2 == 2 
 // [].concat([20] , [80,60].concat([90],[100]))

 //   第三次执行函数  基准值 60 ; 2 / 2 = 1
  // [].concat([20] , [].concat([60],[80]).concat([90],[100]))
  
//  等待递归函数执行完毕，就是一个排序完成的数组

//  定义函数 quickSort 
function quickSort(elements) {
    // 判断数组的length属性是否小于等于1
    if(elements.length <= 1){
        return elements;
    }
    // 找数组中偏中间的索引值（基准值）
    var midIndex = parseInt(elements.length / 2);
    // 找数组中偏中间的索引值的元素
    var middleVal = elements.splice(midIndex,1)[0];
    // middleVal = middleVal[0]
    // 定义左边数组
    var left_arr = [];
    // 定义右边的数组
    var right_arr = [];
    // 循环数组 elements 数组
    for(var i = 0 ; i < elements.length ; i ++){
        // 比较数组的元素 
        if(elements[i] < middleVal){
            // 把较小的元素添加到左边数组
            left_arr.push(elements[i]);
        }else {
            // 把较大的元素添加到右边数组
            right_arr.push(elements[i]);
        }
    }
    // 执行递归
    return quickSort(left_arr).concat([middleVal],quickSort(right_arr))
}

//  调用函数 quickSort 
var res = quickSort(arr);
console.log(res);// [20, 60, 80, 90, 100]


// var left = quickSort(left_arr);
// var right = quickSort(right_arr);
// return left.concat([middleVal],right);
```



## JavaScript 正则表达式

### 什么是正则表达式？

正则表达式是由一个字符序列形成的搜索模式

当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容

正则表达式可以是一个简单的字符，或一个更复杂的模式

正则表达式可用于所有文本搜索和文本替换的操作

### 语法

```js
/正则表达式主体/修饰符(可选)
```

其中修饰符是可选的

下面的代码创建了一个正则表达式

```js
var patt = /twle/i
```

1. **/twle/i** 是一个正则表达式
2. **twle** 是一个 **正则表达式主体** (用于检索)
3. **i** 是一个 **修饰符** (搜索不区分大小写)。

### 使用字符串方法

JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()

| 方法      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| search()  | 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置 |
| replace() | 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 |

### 正则表达式修饰符

**修饰符** 可以在全局搜索中不区分大小写:

| 修饰符 | 描述                                                   |
| ------ | ------------------------------------------------------ |
| i      | 执行对大小写不敏感的匹配                               |
| g      | 执行全局匹配 (查找所有匹配而非在找到第一个匹配后停止 ) |
| m      | 执行多行匹配                                           |

### 正则表达式模式

方括号用于查找某个范围内的字符

| 表达式 | 描述                     |
| ------ | ------------------------ |
| [abc]  | 查找方括号之间的任何字符 |
| [0-9]  | 查找任何从 0 至 9 的数字 |
| (x\|y) | 查找任何以 \| 分隔的选项 |

元字符是拥有特殊含义的字符

| 元字符 | 描述                                      |
| ------ | ----------------------------------------- |
| \d     | 查找数字                                  |
| \s     | 查找空白字符                              |
| \b     | 匹配单词边界                              |
| \uxxxx | 查找以十六进制数 xxxx 规定的 Unicode 字符 |

量词

| 量词 | 描述                            |
| ---- | ------------------------------- |
| n+   | 匹配任何包含至少一个n的字符串   |
| n*   | 匹配任何包含零个或多个n的字符串 |
| n?   | 匹配任何包含零个或一个n的字符串 |

### 使用 test()

test() 方法是一个正则表达式方法

test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false

下面的代码用于搜索字符串中的字符 "e"

```js
var patt = /e/;
patt.test("The best things in life are free!");
```

字符串中含有 "e"，所以范例输出为 `true`

[运行范例 »](https://www.twle.cn/t/yufei/javascript/basic/regexp_test)

你可以不用设置正则表达式的变量，以上两行代码可以合并为一行：

```js
/e/.test("The best things in life are free!")
```

### Throw 语句

throw 语句允许我们创建自定义错误

正确的技术术语是：创建或 **抛出异常** ( exception )

如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息

语法：

```js
throw exception
```

异常可以是 JavaScript 字符串、数字、逻辑值或对象

下面的范例用于检测输入变量的值

如果值是错误的，会抛出一个异常（错误）

catch 会捕捉到这个错误，并显示一段自定义的错误消息

```js
function myFunction() {
    var message, x;
    message = document.getElementById("message");
    message.innerHTML = "";
    x = document.getElementById("demo").value;
    try { 
        if(x == "")  throw "值为空";
        if(isNaN(x)) throw "不是数字";
        x = Number(x);
        if(x < 5)    throw "太小";
        if(x > 10)   throw "太大";
    }
    catch(err) {
        message.innerHTML = "错误: " + err;
    }
}
```

## JavaScript 计时事件

| 方法          | 描述                                 |
| ------------- | ------------------------------------ |
| setInterval() | 间隔指定的毫秒数不停地执行指定的代码 |
| setTimeout()  | 暂停指定的毫秒数后执行指定的代码     |

### setInterval() 方法

**（防抖思想，使用前先清楚定时器）**

`setInterval()` 用于间隔指定的毫秒数不停地执行指定的代码

### 语法

```js
window.setInterval("javascript function", milliseconds);
```

`window.setInterval()` 方法可以不使用 window 前缀，直接使用函数 **setInterval()**

setInterval() 第一个参数是函数 ( function )

第二个参数间隔的毫秒数

> **注意:** 1000 毫秒是一秒

下面的代码每三秒弹出 "hello"

```js
setInterval(function(){alert("Hello")},3000);
```

**clearTimeout()** 方法用于停止执行 **setTimeout()** 方法的函数代码

### 语法

```js
window.clearTimeout( timeoutVariable )
```

**window.clearTimeout()** 方法可以不使用 window 前缀

要使用 clearTimeout() 方法, 必须在创建超时方法中（setTimeout）使用全局变量

```js
var t1 = setTimeout("javascript function", milliseconds );
```

如果函数还未被执行，可以使用 clearTimeout() 方法来停止执行函数代码



------

# HTML DOM对象

## 获取dom对象的样式方法：

通过使用 getComputedStyle 读取样式，通过 element.style 修改样式；

## 获取页面元素的常见方法：

**1、通过标签获取元素，返回一个数组**

```js
var li = document.getElementsByTagName('li');*//标签获取元素*`
li.getElementsByTagName('p');//获取所有li元素里的p标签
li[0].innerHTML;// 查看获取元素的内容
li[0].innerHTML = "content";//修改获取到标签中的内容
```

**2、通过id获取页面元素**

```js
var header = document.getElementById("header");//id获取元素
```

**3、通过class名字获取页面元素**

```js
var list = document.getElementsByClassName('list');//返回一个数组，通过下标访问文本
```

**4、通过CSS选择符方式获取页面元素**

```js
var str = document.querySelector('li');//querySelector：返回符合条件的第一个
var str1 = document.querySelectorAll('li');//全部返回，每个li都是一个对象
```

```js
document.body.lastElementChild	//最后一个元素
var ele = document.body.firstElementChild	//第一个元素
//获取当前标签的父元素
console.log(ele.parentElement);
//获取ele的子元素
var elements = ele.children;
//获取当前标签的上一个元素
var prev_ele = prev_ele.previousElementSibling;
//获取当前标签的下一个元素
var prev_ele = prev_ele.nextElementSibling;
// 以下方法可通过选择器获取元素
// H5提供的方法(比较便捷)
var ele_1 = document.querySelector(".box-1");
console.log(ele_1);// 标签 <div class="box box-1" id="demo1">1</div>
var ele_arr = document.querySelectorAll(".box-1");
console.log(ele_arr);// 标签数组 NodeList [div#demo1.box.box-1]
```

**往父元素添加子元素**

```js
// 往body标签添加元素
document.body.appendChild(divCreate);

// 往container标签添加元素(追加元素) [img1,img2]
var container = document.querySelector(".container");
container.appendChild(img1);
container.appendChild(img2);
```

```js
在指定标签之前插入元素
// 获取.container标签
var container = document.querySelector(".container");
// 获取.box-2标签
var box2 = document.querySelector(".box-2");
// 在.box-2标签之前插入一个div
var div = document.createElement("div");
div.className = "box";
// insertBefore
// 调用者: 父元素
// 参数: 1. 创建的元素  2.目标元素
// 返回值: 忽略
// 功能: 在指定标签之前插入一个相邻关系的元素
container.insertBefore(div, box2);
//删除元素
父元素.remveChild(指定s)
```

**在指定标签之后插入元素**

```js
<div class="container">
    <div class="box-1">1</div>
    <div class="box-2">2</div>
    <div class="box-3">3</div>
</div>

<script>
    // 获取.container标签(父元素)
    var container = document.querySelector(".container");
    // 获取.box-2标签
    var box2 = document.querySelector(".box-2");
    
    // 封装一个myInserAfter方法
    // 作用: 在指定标签之后插入一个相邻关系的元素
    function myInserAfter(parent,element,target){
        // 判断目标元素(target)是否为父元素(parent)的最后一个子元素
        if(target == parent.lastElementChild){
            // 往父元素追加一个元素
            parent.appendChild(element);
        }else {
            // 找到目标元素的下一个标签
            var nextEl = target.nextElementSibling;
            // 在nextEl之前插入一个元素
            parent.insertBefore(element,nextEl);
        }
    }

    // 创建一个div标签
    var demo = document.createElement("div");
    demo.className = "box";
    // 在2号盒子后插入一个标签
    myInserAfter(container,demo,box2);

</script>
```

## DOM事件对象

### 鼠标事件：

|                             属性                             |                  描述                  | DOM  |
| :----------------------------------------------------------: | :------------------------------------: | :--: |
|  [onclick](https://www.runoob.com/jsref/event-onclick.html)  |  当用户点击某个对象时调用的事件句柄。  |  2   |
| [oncontextmenu](https://www.runoob.com/jsref/event-oncontextmenu.html) | 在用户点击鼠标右键打开上下文菜单时触发 |      |
| [ondblclick](https://www.runoob.com/jsref/event-ondblclick.html) |  当用户双击某个对象时调用的事件句柄。  |  2   |
| [onmousedown](https://www.runoob.com/jsref/event-onmousedown.html) |            鼠标按钮被按下。            |  2   |
| [onmouseenter](https://www.runoob.com/jsref/event-onmouseenter.html) |     当鼠标指针移动到元素上时触发。     |  2   |
| [onmouseleave](https://www.runoob.com/jsref/event-onmouseleave.html) |        当鼠标指针移出元素时触发        |  2   |
| [onmousemove](https://www.runoob.com/jsref/event-onmousemove.html) |              鼠标被移动。              |  2   |
| [onmouseover](https://www.runoob.com/jsref/event-onmouseover.html) |          鼠标移到某元素之上。          |  2   |
| [onmouseout](https://www.runoob.com/jsref/event-onmouseout.html) |           鼠标从某元素移开。           |  2   |
| [onmouseup](https://www.runoob.com/jsref/event-onmouseup.html) |            鼠标按键被松开。            |  2   |

### 键盘事件：

|                             属性                             |            描述            | DOM  |
| :----------------------------------------------------------: | :------------------------: | :--: |
| [onkeydown](https://www.runoob.com/jsref/event-onkeydown.html) |    某个键盘按键被按下。    |  2   |
| [onkeypress](https://www.runoob.com/jsref/event-onkeypress.html) | 某个键盘按键被按下并松开。 |  2   |
|  [onkeyup](https://www.runoob.com/jsref/event-onkeyup.html)  |    某个键盘按键被松开。    |  2   |

### **表单事件**

```js
onfocus      //输入框获取焦点
onblur       //输入框失去焦点
onchange     //value属性值发生变化(触发1次)
oninput      //value属性值发生变化(触发N次)
```

### **滚动事件**

```js
onscroll  //滚动事件
onmousewheel  //鼠标滚轮滚动事件
```

### **窗口事件**

**调用者:window** 

```js
onresize  //窗口尺寸发生变化
onload    //页面加载事件
```

### 获取元素css属性：

**getComputedStyle**

```js
var div = document.querySelector("div");
// 调用获取元素样式对象的方法
// 调用者： window
// 参数： 参数1：dom对象 ,参数2：可选参数（伪类）
// 返回值： css样式对象
// 功能： 可以获取元素的css属性数据
var obj = getComputedStyle(div);
// 取值
console.log(obj.width);
console.log(obj.height);
console.log(obj.backgroundColor);
// 取值
var w = getComputedStyle(div)["width"];
console.log(w);// "100px"
console.log(parseInt(w));// 100
```

### **offset(偏移)** page(页面偏移)：

```js
// 获取.child标签
var child = document.querySelector(".child");
// 尺寸
console.log("实际宽度：",child.offsetWidth);// 112
console.log("实际高度：",child.offsetHeight);// 112
// 位置(父元素没有定位的情况)
console.log("距离浏览器左边间距：",child.offsetLeft);// 120
console.log("距离浏览器顶部间距：",child.offsetTop);// 70
// 偏移父元素
console.log(child.offsetParent);// body标签
// 位置(父元素有定位的情况)
// console.log("距离浏览器左边间距：",child.offsetLeft);// 30
// console.log("距离浏览器顶部间距：",child.offsetTop); // 20
// console.log(child.offsetParent);//  div.parent标签
console.log("页面:",evt.pageX);
console.log("页面:",evt.pageY);
```

### **client（可视区）**

```js
// 获取.box标签
var box = document.querySelector(".box");
// 尺寸（忽略了边框）
console.log("宽度：",box.clientWidth);// 104
console.log("高度：",box.clientHeight);// 64
// 边框(左/上)
console.log("上边框：",box.clientTop);// 20
console.log("左边框：",box.clientLeft);// 50
```

### **scroll（滚动）**

```js
// 获取相关的元素
var box = document.querySelector(".box");
// 尺寸 (计算时包含内容的大小)
console.log("宽度：",box.scrollWidth);// 220
console.log("高度：",box.scrollHeight);// 456
// 位置
console.log("滚动超出部分Y:",box.scrollTop);// 重点
console.log("滚动超出部分X:",box.scrollLeft);
// 绑定滚动事件(滚动行为发生就触发事件)
box.onscroll = function(){
    // console.log("test");
    console.log("滚动超出部分:",box.scrollTop);
}
```

### 页面可见区域

```
网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
scrollTop=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;其实document.documentElement.scrollTop
```

## Event**事件监听**

###  target事件属性            

获取触发特定事件的元素：

```js
alert(event.target);
```

**事件监听**

```js
dom.addEventListener(参数1，参数2，参数3)          
```

```js
// 事件源
var btn = document.querySelector(".btn");
// 事件监听
// btn.addEventListener(参数1，参数2，参数3)
// 参数1： 事件类型 参数2：匿名函数  参数3：可选参数（布尔值）
```

### **移除事件监听**

```js
// 获取按钮标签
var btn = document.querySelector(".btn");
var count = 0;
// 定义函数（代码块）
var foo = function(){
    count ++;
    console.log("test:"+count);

    if(count >= 5){
        // 当count大于等于5时，就移除事件监听
        btn.removeEventListener("click",foo);
    }
}
// 事件监听 
// btn.addEventListener("click" , function(){})
btn.addEventListener("click" , foo);
// 移除事件监听
// btn.removeEventListener("click",foo);
removeEventListener
```

事件绑定 ：

​       仅仅可以看见事件冒泡。

事件监听 ：

​        可以看见事件捕获，也可以看见事件冒泡。

阻止事件冒泡

```js
//阻止事件冒泡
event.stopPropagation();
```

阻止事件捕获

```js
// 阻止事件捕获
event.stopImmediatePropagation();
```

事件源

在哪个元素发生的事件

```js
event.target              
```

## **location 对象**

```JS
// 该对象关于浏览器地址栏信息
// console.log(location)
// 获取页面地址
var url = location.href; console.log(url);
// 设置指定的页面地址
// location.href = "./detail.html";
// 获取协议
console.log(location.protocol);// http
// 获取端口
console.log(location.port);// 5500
// 获取服务器地址
console.log(location.host);// 127.0.0.1:5500
// 获取主机地址
console.log(location.hostname);// 127.0.0.1 (本地IP) // 14.215.177.38
// 获取地址栏的参数
console.log(location.search);// ?username=admin&userpass=123123  如果想获取 admin 和 123123 这些数据,那么就需要结合字符串的API (split)
// 获取锚点标记
console.log(location.hash);//#login

// 刷新页面的方法   location.href="/"
// location.reload();

// 跳转页面的方法
// location.href="https://www.baidu.com"
// location="https://www.baidu.com"
// 替换当前地址栏路径
// location.replace("https://www.baidu.com");
```

## **naigator 对象**

**判断浏览器所在终端**

```JS
// 该对象关于浏览器信息
// console.log(navigator);
// 获取设备信息(终端) 
// PC 端           关键字  Windows
// IOS 端(移动端)   关键字 iPhone
// 安卓端(移动端)   关键字  Android
var _userAgent = navigator.userAgent;
// console.log(_userAgent); // Mozilla/5.0 (Windows NT 10.0; Win64; x64) 
// console.log(_userAgent); // Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X)
// console.log(_userAgent); //Mozilla/5.0 (Linux; Android 6.0.1; Moto G (4)) 
if(_userAgent.indexOf("Windows") >-1){
    console.log("这是PC端");
}else if(_userAgent.indexOf("iPhone") >-1){
    console.log("这是苹果手机端");
}else if(_userAgent.indexOf("Android") >-1){
    console.log("这是安卓手机端");
}
```

## **history** 对象

```js
// 返回上一页
btnBack.onclick = function(){
    // 调用history的API
    history.back();
}
// 下一页
btnNext.onclick = function(){
    // 调用history的API
    history.forward();
}
// 返回上一页
btnBack.onclick = function(){
     // 调用history的API
     history.go(-1);
}
```

## **screen**对象

关于设配屏幕

```js
// 屏幕的尺寸 (除了任务栏)
var w = screen.availWidth;
var h = screen.availHeight;
// 打印数据
// console.log({w:w,h:h});
console.log({w,h});// {w: 1920, h: 1040}

// 屏幕的尺寸 (包含任务栏)
var w2 = screen.width;
var h2 = screen.height;
 // 打印数据
console.log({w2,h2});//{w2: 1920, h2: 1080}
```

# jQuery

入口函数:$(function(){

})

常见的弹窗效果

sweetalert

## $符

## **jquery 选择元素的基本方法**

```javascript
 // 选择.nav标签
$(".nav").css("background","deepskyblue");
// 选择.nav标签的父元素
$(".nav").parent().css("height","120px");
// 选择.nav标签的子元素
$(".nav").children("ul").css("background","#ccc")
// 选择.nav标签下所有的li元素
$(".nav").find("li").css("borderRadius","20px");

// 选择.active标签的上一个元素
$(".active").prev().css("background","blue");
// 选择.active标签的前面所有同级元素
$(".active").prevAll().css("background","blue");
// 选择.active标签的下一个元素
$(".active").next().css("background","purple");
// 选择.active以外的所有li元素(兄弟元素)
$(".active").siblings("li").css("background","#fff");


// 选择ul li列表中第一个li标签
// console.log($("ul li").first());
$("ul li").first().css("background","red");
// 选择ul li列表中最后一个li标签
$("ul li").last().css("background","yellowgreen");

// 通过索引值选择元素
// 0,1,2,3,4,....
$("ul li").eq(1).css("background","green");
$("ul li").eq(2).css("background","blue");

// 选择倒数第2个li标签
// console.log($("ul li"));
var len = $("ul li").length;
$("ul li").eq(len - 2).css("background","lightblue");
$("ul li").eq(len - 3).css("background","pink");
$("ul li").eq(len - 4).css("background","purple");

//：even 下标为偶数
//：odd 下标为奇数
$("li:oven")

.hide()  .show()   //显示与隐藏
```

## **jquery 控制元素的类名**

```js
// 1.0 设置元素的类名 addClass
// 选择第1个div
$("div").eq(0).addClass("bg-red");
// 选择第2个div
$("div").eq(1).addClass("bg-green");
// 选择第3个div
$("div").eq(2).addClass("bg-blue");
// 2.0 移除元素的类名 removeClass
$("div").eq(0).removeClass("bg-red");
// 3.0 切换类名 toggleClass
// 如果存在该类名,就移除该类名
// 如果不存在该类名,就添加该类名
$("div").eq(0).toggleClass("bg-red");// 1
$("div").eq(0).toggleClass("bg-red");// 0
// 4.0 判断是否包含该类名 hasClass
var flag = $("div").eq(0).hasClass("bg-red");
console.log(flag);// true 表示存在该类名; false表示不存在该类名
```

## **jquery 控制元素的文本**

```js
// dom.innerHTML
// 获取元素的超文本
var v1 = $(".text-1").html();
console.log(v1);
// dom.innerText
// 获取元素的纯文本
var v2 = $(".text-1").text();
console.log(v2);
// 设置元素的超文本
// $(".text-1").html("<b>天空突然下了点雨</b>");
// 设置元素的纯文本
$(".text-1").text("<b>天空突然下了点雨</b>");
// input.value
// 获取输入框的文本
var v3 = $(".form-1 input").val();
console.log(v3);
// 设置输入框的文本
$(".form-1 input").val("输入...");
```

## **jquery 控制元素的标签属性**

```js
// dom.setAttribute()
// 设置标签的属性
$("div").eq(0).attr("class","box");
$("div").eq(1).attr("id","demo");
var _src = "https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png"
$("img").attr("src",_src);
$("a").attr("href","https://taobao.com");
$("div").css({}'backgroundColor':'#foo','fontSize':'40px'})
// dom.getAttribute()
// 获取标签属性
var v1 =  $("div").eq(0).attr("class");
var v2 =  $("div").eq(1).attr("id");
console.log(v1);
console.log(v2);
// dom.removeAttribute()
// 删除标签属性
$("img").removeAttr("src");
```

## **jquery 控制表单元素的属性**

```js
// 选择按钮标签 获取点击状态
var v1 = $("input[type='button']").eq(0).prop("disabled");
var v2 = $("input[type='button']").eq(1).prop("disabled");
console.log(v1);// true
console.log(v2);// false
// 选择复选框标签 获取勾选状态
var v3 = $("input[type='checkbox']").eq(0).prop("checked");
var v4 = $("input[type='checkbox']").eq(1).prop("checked");
console.log(v3);// true
console.log(v4);// false
// 选择复选框标签 设置勾选状态
// $("input[type='checkbox']").eq(0).prop("checked",false);
// 选择按钮标签 设置点击状态
// $("input[type='button']").eq(0).prop("disabled",false);
```

## **添加元素**

```js
// append()
    // 调用者： jquery对象
    // 参数： html字符串
    // 返回值： jquery对象
    // 功能： 往容器标签尾端（索引值为length-1）添加元素
// 场景： 滚动加载
// 添加元素
// var o1 = $("#container").append("<div class='box'>1</div>");
// console.log(o1);
头部
$("#container").append("<div class='box'>1</div>");
$("#container").append("<div class='box'>2</div>");
$("#container").append("<div class='box'>3</div>");
// prepend()
    // 调用者： jquery对象
    // 参数： html字符串
    // 返回值： jquery对象
    // 功能： 往容器标签首位（索引值为0）添加元素
// 场景： 下拉刷新
底部
$("#container").prepend("<div class='box'>4</div>");
$("#container").prepend("<div class='box'>5</div>");
$("#container").prepend("<div class='box'>6</div>");
```

## **移动元素**

```js
$(function(){
    // .box-2 jquery对象
    var $el =  $(".box-2");
    // 移动元素
    // appendTo()
        // 调用者： 目标元素的jquery对象
        // 参数：容器标签的jquery对象或选择器
        // 返回值：忽略
        // 功能： 把目标元素移动至指定的容器标签
    // $(".box-1 > div").appendTo($el);
    $(".box-1 > div").appendTo(".box-2");
})
```

## 事件类型

```js
click    点击行为
mousedown 鼠标按下行为
mouseup  鼠标松开行为
mousemove 鼠标移动行为
mouseenter 鼠标移入行为
mouseleave 鼠标离开行为
mouseover 鼠标悬停行为
mouseout 鼠标移出行为
keydown 按下键盘按键行为
keypress 长按键盘按键行为
keyup   松开键盘按键行为

focus  获取焦点的行为
blur   失去焦点的行为
change  值被改变了触发的行为（1次）
oninput  值被改变了触发的行为（多次） （jquery不能直接使用）

resize  窗口尺寸发生变化的行为
scroll   窗口发生滚动的行为  scrollTop 滚动距顶部
```

## jquery 绑定事件方法

```js
// bind常规写法：
bind（，，） 可绑定多个事件    event.handleObj.origType; 获得事件类型
unbind（要解绑的事件） 解绑事件
var count = 0;
$(".btn").bind("click mouseenter mouseleave",function(event){
    // 事件类型(行为)
    var origType = event.handleObj.origType;
    // 判断事件类型
    if(origType == "click"){
        count ++;
        console.log("click",count);
        if(count == 5){
            // $(".btn").unbind("click");//解绑点击事件
            $(".btn").unbind();//解绑所有的事件
        }
    }else if(origType == "mouseleave"){
        console.log("mouseleave");
    }
})
// on 常规写法：
function clickHandler1() {
        console.log('点击事件1的处理程序');
    }

    function clickHandler2() {
        console.log('点击事件2的处理程序');
    }


    $('#btn').on('click', clickHandler1);
    $('#btn').on('click', clickHandler2);

    $("#cancelBtn").click(function () {
        console.log('cancelBtn');
        // $('#btn').off('click'); // 把所有的click事件取消
        $('#btn').off('click', clickHandler1); // 取消某个事件的处理程序

        // $('#btn').off('事件类型', 事件处理程序); // 取消某个事件的处理程序
    });
//一次性事件
$('#btn').one('click', clickHandler1);
//事件的自动触发
function clickHandler1() {
        console.log('点击事件1的处理程序');
    }
    $('#btn').on('click', clickHandler1);


    setTimeout(function () {
        //trigger 翻译 扳机（手枪的扳机）
        $('#btn').trigger('click');
    }, 3000);

```

## jq动画效果

```js
.fadeIn		//淡入
.fadeOur	//淡出
.fadeToggle		//切换
.animate		//动画
$("div").eq(0).animate({ opacity:1 , height:height*2 }, 2000 ,function(){
    console.log(ok)
})
```

## pc端事件

```js
touchstart 触摸开始  touchmove 触摸移动 touchend 触摸接触 touchcancel触摸结束 
```

# Git

```
设置指定库
	1.git init(仓库初始化操作)
	2.git remote add origin git@github.com:architectMymine/test.git（仓库地址）创建上传地址
	3.git remote -v 查看是否连接成功
	git fetch(取回所有更新分支信息)
	git branch -a(此时可以查看到dev分支)	
	4.git add . 添加项目
	5.git commit -m “提交说明”    提交项目
	6.git pull --rebase origin master , 使用pull将线上、线下代码进行合并
	7.git push origin master 提交代码到仓库
```

```tex
创建仓库
  配置git用户信息
    git config --global user.name "你的gitee账号"
    git config --global user.email "1161437421@qq.com"
  查看git用户配置信息
    git config user.name
    git config user.email
    
  git常用命令
  
    拉取远程仓库的项目
      git clone
      
    查看git仓库文件状态
    git status
	git stash 保留工作区gi
	
	git rebase --continue
    ===========================
    将本地文件推送到远程仓库
      1、将本地文件添加到暂存区(只会将修改的、删除的、新增的文件添加到暂存区)
      git add .

      2、将暂存区的文件添加到本地临时仓库
      git commit -m "你的本次提交的注释内容"

      3、拉取远程仓库的项目代码, 更新本地项目代码, 主要用于验证是否存在文件冲突
      git pull origin dev
		(未关联)--allow-unrelated-histories
      4、将本地临时仓库的代码推送到远程仓库
      git push -u origin master
      
      强制推送
      git push --force origin <branch-name>
    ===========================
 git分支(类似备份概念)
    主分支(master): 可看作生产环境的代码
    开发分支(dev): 可看作生产环境的代码
    
    查看分支
   git branch -a

    切换分支
        git checkout 分支名

    合并分支的代码
    git merge 被合并的分支

    比如：目前处于master分支, 需要将dev分支合并到master
    git merge dev

    删除本地分支
    git branch -d 分支名
    比如: 删除本地dev分支
    git branch -d dev

    删除远程仓库的分支
    git push orgin :分支名
    比如: 删除远程仓库dev分支
    git push origin :dev
    
协助团队开发
  svn: 集中式控制系统
  git: 分布版本控制系统


下载gitbash命令工具
https://gitforwindows.org/

gitbash基础命令
  查看文件、文件夹
  ls

  进入盘符
  cd /d

  进入文件夹
  cd ./文件夹路径

  创建文件
  touch 文件名

  查看文件内容
  cat 文件名

  创建文件夹
  mkdir 文件夹名称

  返回上一级文件夹
  cd ..

  返回上两级文件夹
  cd ../..

  修改文件夹
  mv 旧文件名 新文件名

  移动文件
  mv 旧文件路径 新文件路径

  删除文件
  rm 文件路径

  删除文件夹(删库跑路命令)
  rm -rf 文件夹
  
  编辑文件内容
  vim 文件路径
  按下i，进入编辑模式。按下esc退出 输入:wq进行保存退出  :q!不保存退出
  
```

## gitignore

```
注释（注释使用 # 开头，后面跟注释内容）

# 以下是忽略的文件

忽略文件
```

# webpack

```html
webpack: 静态资源打包工具

创建webpack项目
 mkdir wp

在根目录创建package.json
npm init
或者 npm init -y

本地安装webpack、webpack-cli
安装webpack
npm i webpack --save-dev

安装webpack-cli
npm i webpack-cli --save-dev

全局安装webpack、webpack-cli
npm i webpack -g
npm i webpack-cli -g

在项目的根目录创建webpack的配置文件, 文件名为 webpack.config.js
touch webpack.config.js

创建入口文件
在根目录下创建 src/index.js

执行打包命令
webpack --config webpack.config.js

  css-loader处理css
  安装环境
  npm i css-loader style-loader --save-dev

  less-loader
  安装环境
  npm i css-loader style-loader less less-loader --save-dev


  sass-loader
  安装环境
  使用npm安装
  npm i css-loader style-loader sass sass-loader node-sass --save-dev

 使用cnpm安装
  cnpm i css-loader style-loader sass sass-loader node-sass --save-dev

  分离css
  安装mini-css-extract-plugin插件
  npm i mini-css-extract-plugin --save-dev

  处理图片
  安装环境
  npm i file-loader url-loader --save-dev

server
  webpack-dev-server: 搭建本地服务器的插件
  npm i webpack-dev-server --save-dev
```

# Ajax

```javascript
$("#email").blur(function () {
        // 获取用户输入的信息
        let email = $(this).val().trim();
        // 2. 后台接受请求，然后接受传递过来的 用户名
        let xhr = new XMLHttpRequest(); // XML + Http + Request
        // 在地址栏的后面加上?key=value通过这种方式可以给服务器传递数据。这种请求方式我们叫做get传参
        // 如果有多个参数要传递，可以使用 ?key=value&key1=value1&key2=value2;
        let url = 'http://localhost/03/02.php?email=' + email; // 地址接受请求，去校验用户名是否可以使用
        
        xhr.open('get', url);
        // console.log(xhr.readyState==1);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                console.log('服务器返回的数据：===>', xhr.responseText);
                if (xhr.responseText == 1) {
                    // 记录在数据库存在，不可以注册
                    $(".error").show();
                    $(".success").hide();

                } else if (xhr.responseText == 0) {
                    // 记录在数据不存在，可以注册
                    $(".error").hide();
                    $(".success").show();
                }
            }
        }
        xhr.send();
    });

笔记：
let xhr = new XMLHttpRequest()
XMLHttpRequest() 对象是 AJAX 的关键。

ajax.open(1 :get post,2 :地址值,3 :boolear 异步/同步)

onreadystatechange Ajax-服务器响应 (xhr对象的状态在做一些改变时，这个事件会一直监视着它)
.readyState 属性存留 XMLHttpRequest 的状态。
0: 请求未初始化
1: 服务器连接已建立
2: 请求已接收
3: 正在处理请求
4: 请求已完成且响应已就绪
当status的值是200的时候，表示服务器已经正确的处理请求以及给出响应

Ajax.send()
作用：发送请求
语法：xhr.send(body)
body:请求主体
如果没有请求主体，body位置处为null(get)
如果有请求主体，则放请求主体数据到body位置(post)

.responseText  后台返回值
```

```php
<?php
    // 接受请求，然后校验用户名是否可以使用
    // 想办法接受到前端传递的参数
    // php里面存在一个特殊的变量 魔术变量
    $get = $_GET;// 里面包含了get请求传递的参数
    // echo $get
    // array(1) {
    //     ["email"]=>
    //     string(14) "gogery@163.com"
    //     }

    // var_dump($get['email']); 
    $email = $_GET['email'];
    // 这里应该根据邮箱去查询数据库，检测数据库里面是否 存在 gogery@163.com 这个邮箱的记录，如果存在，则不能注册 不存在才可以注册
    // 伪代码
    // 1. 链接数据库
    // mysql_connect();
    // 2. 发送查询语句
    // $sql = 'select * from users where email = ' . $email;
    // mysql_query($sql);
    // 3. 数据库返回查询的结果
    
    // 4. 根据结构做逻辑判断
    // echo '请求达到了，传递的参数是：' . $get['email'];
    echo 1; // 代表是存在，存在就不可以注册；    
    // echo 0; // 代表是不存在，不存在可以注册；
?>
```

## post 方法

```js
$(function () {
        $("#subBtn").click(function () {
            var username = $("#username").val().trim();
            var pwd = $("#pwd").val().trim();

            if (username == '' || pwd == '') {
                alert('信息不合法');
                return;
            }

            // 合法 完成ajax的提交
            var url = 'http://localhost/07/03-login.php';
            var xhr = new XMLHttpRequest();							创建对象
            xhr.open('post', url);									open post方法，url是php地址值
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {							判断交互结束
                    var obj = JSON.parse(xhr.responseText);			通过json方法转换获取到的数据//JSON.parse方法
                    // console.log(xhr.responseText);
                    if (obj.code == 0) {
                        // 合法注册
                        alert('登录成功！');
                        // 前往登录页面
                        location.href = 'http://localhost/07/04-profile.php';

                        return;
                    } else if (obj.code == 1001 || obj.code == 1002) {
                        alert('系统繁忙中！');
                        return;
                    } else if (obj.code == 1006 || obj.code == 1007) {
                        alert('用户名不存在或者是密码不正确');
                        return;
                    }

                }
            }

            // post提交，需要设置请求头信息
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');			设置请求头
            var postData = 'username=' + username + '&pwd=' + pwd;
            xhr.send(postData);										send传递值给后端
            return false;
        });
```

## json

```php
// json_encode($userInfo) --- 把对象序列化为 字符串，这种格式的字符串和js语境下的对象格式一致，我们叫做 json。
// 下面在整体：我们拿json去填充一个函数。这种称之为 jsonp技术。
echo $fn . '(' . json_encode($userInfo) . ')';

var obj = JSON.parse(xhr.responseText);
```

# SQL语句

## 增删改查

```sql
1.c （create）增加，代表给数据库里面的数据表增加记录
        语法：insert into tableName values(字段值1, 字段2值2,......);
        // 字段值如果是字符串，则需要使用引号进行包裹
        INSERT INTO goods VALUES(4, "iPhoneX", 3400, "https://api.cn/imgs/1.jpg", "4500", "手机还不错！");
        // 注意：如果我们有id字段，并且id字段设置为自增，主键后，id字段可以写为null，让系统自动维护。
        INSERT INTO goods VALUES(null, "iPhone34", 2400, "https://api.cn/imgs/1.jpg", "4500", "手机还不错！");
2. d(delete)删除语句
        delete from tableName [where 字段条件];
        // 代表删除表中所有的记录
        DELETE FROM goods;
        // 根据id删除记录
        DELETE FROM goods WHERE id=5;
        // 还可以根据其他字段 goodsName 进行删除，满足条件都会删除的。
        DELETE FROM goods WHERE goodsName = '小米';
        DELETE FROM goods WHERE goodsName = 'iphone';
        DELETE FROM goods WHERE goodsNumber > 100;
3. u(update)改操作
        update tableName set 字段=新的值,字段1=新的值 [where 条件];
        // 在公司千万不能做，代表把表中记录的goodsName全部更新为 新手机
        UPDATE goods set goodsName = '新手机';
        // 修改的时候，一般要增加条件
        UPDATE goods set goodsName = 'iPhoneX' WHERE id=8;
        // 一次性修改多个字段的值
        UPDATE goods set price="900",goodsNumber=1000 WHERE id=8;
        // 可以使用其他的字段作为条件
        UPDATE goods set price="12900",goodsNumber=1000 WHERE goodsName="新手机";
4. r（read）查操作
        select * from tableName [where 条件];
        // 查看所有的记录信息
        SELECT * FROM goods;
        // 查看满足条件的记录 id
        SELECT * FROM goods where id = 8;
        // 查询的时候，* 代表的是把所有的字段全部取出来，我们也可以写上要显示的字段信息
        SELECT id,goodsName,price FROM goods where id = 8;
        // 根据goodsName把指定的字段记录取出来
        SELECT id,goodsName,price FROM goods where goodsName="iPhoneX";
        // 按照指定的字段进行排序
        // ORDER BY [字段名称] [asc升序，从小到大|desc降序，从大到小]
        SELECT * FROM goods ORDER BY id asc;
        // 获取总记录数 count(*) 代表是求和，获取总记录数量
        SELECT count(*) FROM goods;
```



# PHP

## 案例1 	登录与注册 链接数据库操作

```php
// 1. 开启 session post方法
session_start();

//设置获取的参数 isset方法 检查参数是否有值 配合三目运算
$username = isset($_POST['username']) ? $_POST['username'] : '';
$pwd = isset($_POST['pwd']) ? $_POST['pwd'] : '';

// 链接数据库，插入数据库
$hostName = '127.0.0.1';	//地址
$userName = 'root';			//数据库名
$password = 'root';			//密码

@$status = mysql_connect($hostName, $userName, $password);

if (!$status) {
    $returnData = [
        'code' => '1001',
        'reason' => 'system error',		//返回的报错
        'status' => false, 		// 代表错误
        'data' => null,
    ];
    echo json_encode($returnData); // 字符串
    die(); // 代表程序终止;
}

// 2. 选择数据库
$status1 = mysql_select_db('shop');
if (!$status1) {
    $returnData = [
        'code' => '1002',	// 1002 代表数据库选择失败
        'reason' => 'select db error', // 英文的错误描述信息
        'status' => false, // 代表错误
        'data' => null,
    ];
    echo json_encode($returnData); // 字符串
    die();
}
//-------------------------------------------------------------------------------------------------
//	登录注册逻辑
$sql = 'select * from members where username ="' . $username . '" limit 1';

$result = mysql_query($sql);			//数据库查询操作
$row = mysql_fetch_assoc($result);		//配合mysql_query方法使用 输出查询到的值 一次只有一条！！！

if (!$row) {
    // 用户名不存在
    $returnData = [
        'code' => '1006',
        'reason' => 'user no exist',
        'status' => false,
        'data' => null,
    ];
    echo json_encode($returnData);
    die();
} else {
    // 用户名存在，判定密码是否一致
    $pwd = md5($pwd);
    // $row['password'] 存的是密文密码，则我们需要先把用户提交的明文密码转换为密文之后，和数据库的做比较

    if ($pwd != $row['password']) {
        // 输入的密码错误
        $returnData = [
            'code' => '1007',
            'reason' => 'user password error',
            'status' => false,
            'data' => null,
        ];
        echo json_encode($returnData);
        die();
    } else {
        //  密码正确，登录成功
        // 2. 需要使用 session 缓存共享的数据信息 
        // session 是我们常做的登录方案之一
        // cookie
        // token
        $_SESSION['isLogin'] = true;
        $_SESSION['username'] = $username;

        $returnData = [
            'code' => 0,
            'reason' => 'user login success',
            'status' => true,
            'data' => null,
        ];
        echo json_encode($returnData);
        die();
    }
}
```

## 上传文件

```php
//3. 表单的编码必须设置为 enctype="multipart/form-data"
	<form action="http://localhost/07-cook/07-03/07-upload.php" method="post" enctype="multipart/form-data">
//1. input 的type类型必须是 file类型，同时设置一个 name属性
		<input type="text" name="username" /> <br>
		头像：<input type="file" name="pic"> <br>
		<input type="submit" value="提交">
    </form>
        
        
// 在该PHP文件里面，接受传递过来的文件，然后把文件保存到服务器的某个位置
// 1. 一般上传的文件都是有些大的，默认情况下，PHP能处理的上传文件的大小都是很小的，我们需要修改一下php.ini配置文件，将允许上传的文件的大小设置为自己想要的大小。
//a.  upload_max_filesize = 400M 单个上传文件的大小
//b.  post_max_size = 800M 整个post表单提交的大小
// 接受post本身的数据和文件数据
echo '<pre>';
// post数据
var_dump($_POST);

// 文件数据 $__FILES php提供的一个魔术变量，不需要定义，直接使用
var_dump($_FILES);
// $_FILES['pic']['tmp_name']里面暂时存储了图片的路径，我们需要使用PHP里面的其他的函数把临时的图片保存在服务器的某个位置下。
// 1. 需要手工的创建一个 uploads 目录，存储上传的文件信息
$file = isset($_FILES['pic']) ? $_FILES['pic'] : ''; // 图片
if (!$file) {
    die('no access!');
}
// 2. 文件处理
$tmpName = $file['tmp_name'];

$fileNamePath = './uploads/';
// 由于上传的时候，如果出现文件同名，使用原始的文件的名称会造成覆盖，所以我们一般生成文件的时候，都要重命名，生成一个唯一性的名字。
// 文件名称 = 文件名 + 扩展名
// 1.jpg avatar.png
$extName = explode('.', $file['name'])[1]; // explode 类似 js里面的 split();
// https://1024tools.com/uuid
// uuid 
// $id = time() . uniqid();
// var_dump($id);

$fileName = time() . uniqid() . '.' . $extName;
$fullPath = $fileNamePath . $fileName; // 图片在服务器上面的路径
// echo $fullPath;

// php提供的一个上传函数 参数1：临时文件的路径 参数2：目标地
$status = move_uploaded_file($tmpName, $fullPath);						move_uploaded_file 方法

if ($status) {
    echo 'success';
} else {
    echo 'failure';
}

//upload.onprogress   获取上传进度的方法。
xhr.upload.onprogress = function (e) {
            var percent = parseInt(e.loaded / e.total * 100) + '%';
            $('.wrap').show().find('.son').css('width', percent).html(percent);

        }
```

## Session与cookie

Session与cookie功能效果相同。Session 与 Cookie 的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。

```php
session_start();      //使用要先开启
// $_SESSION 也是PHP里面的一个魔术变量 数组可以直接使用，不需要定义
// 需要注意：session是跨脚本共享数据的，最大的生命周期是当前的浏览器，浏览器关闭，则session丢失，但是Chrome测试的时候，关闭浏览器还是存在，可以使用火狐测试。
        $_SESSION['isLogin'] = true;
        $_SESSION['username'] = $username;
        // 使用 cookie 技术进行登录方案 cookie 翻译过来叫做 小面包
        // cookie 在使用的时候，我们只需要调用PHP的 setcookie函数进行设置，
        // 参数1：key
        // 参数2：value 存储的value

        // 这个是以http响应头的形式进行响应
        // cookie 默认最大的生命周期，也是基于当前浏览器，如果浏览器关闭，则cookie丢失，但是我们可以给setcookie 设置第三个参数，设置cookie的有效期，即使关闭浏览器后，cookie也可以存在、
        // time() 函数返回当前的时间戳，time() + 3600代表一个小时的有效期
        setcookie('isLogin', true, time() + 3600);
        setcookie('username', $username, time() + 3600);



//使用
$isLogin = isset($_COOKIE['isLogin']) ? $_COOKIE['isLogin'] : '';
$username = isset($_COOKIE['username']) ? $_COOKIE['username'] : '';	
```

# Animate动画

```js
https://animate.style/

安装wow
npm install wowjs --save
安装animate
npm install animate.css –save

import animated from 'animate.css'
import wow from 'wowjs'
Vue.prototype.$wow = wow

rules下加入"no-unused-vars": "off"

mounted(){
    new  this.$wow.WOW().init({
      boxClass: 'wow',
      animateClass: 'animate__animated',
      offset: 0,
      mobile: true,
      live: true
    })
  },
      
data-wow-duration：更改动画持续时间
data-wow-delay：动画开始前的延迟
data-wow-offset：开始动画的距离（与浏览器底部相关）
data-wow-iteration：动画的次数重复（无限次：infinite）
```

# Vue

## 新建vue项目

```
vue create 项目名
按空格选择取消
(*)Choose Vue version
(*)Babel
(*)Router
(*)CSS Pre-processors

2.x

Y

scss

In dedicated config files

N

$ winpty vue.cmd create test
```

### 使用vant

```js
自动按需引入组件 (推荐)
babel-plugin-import 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。
npm i babel-plugin-import -D    或者   cnpm i babel-plugin-import -D

在 babel.config.js 中配置
module.exports = {
    plugins: [
        ['import', {
        libraryName: 'vant',
        libraryDirectory: 'es',
        style: true
        }, 'vant']
    ]
};
//浏览器rem适配
按需引入
    在 main.js 导入vant的组件
    
    lib-flexible 用于设置 rem 基准值
    npm i lib-flexible -D   或者   cnpm i lib-flexible -D

在根目录下创建 postcss.config.js 文件
module.exports = {
    plugins: {
        'postcss-pxtorem': {
        rootValue: 37.5,
        propList: ['*'],
        },
    },
};
在main.js 导入 
import 'lib-flexible/flexible'

运行之后 报错 
Syntax Error: Error: PostCSS plugin postcss-pxtorem requires PostCSS 8.
需要降低版本
cnpm i postcss-pxtorem@5.1.1 -D
```

```
Vue 
el 挂载点
data 数据
methods 添加方法
computed 属性计算（值的计算）
watch 属性侦听（观察值的变化）
filters 过滤器（针对数据做匹配/过滤）
Vue.fiter("名称",函数)
```

## vue的生命周期

```js
1、beforeCreate: 在实例的data数据生成之前执行, 此时还没有获取vue编译范围的元素, 只在初始化执行一次
2、created: 在实例的data数据生成之后执行, 此时还没有获取vue编译范围的元素, 只在初始化执行一次, 可在这个钩子发起ajax请求
3、beforeMount: 在实例的data数据生成之后, 此时获取vue编译范围的元素, 但是视图没有绑定vue的data的数据, 只在初始化执行一次
4、mounted: 在实例的data数据生成之后, 此时获取vue编译范围的元素, 视图已经绑定vue的data的数据, 只在初始化执行一次
5、beforeUpdate: data的数据同步到视图之前执行
6、updated: data的数据同步到视图之后执行
7、beforeDestroy销毁之前, 侦听器, 事件监听都销毁了
8、destroyed, 销毁之后

vue的设计模式MVVM
      M: Model(模型) ==> 定义数据,
      V: View(视图) ==> 页面 ==> 显示数据
      VM: View Model(视图模型) ==> 将Model同步到View, 将View的输入数据同步到Model

```

## 自定义组件

```js
//全局自定义指令 
Vue.directive('focus', {
	// el：指令所绑定的元素，可以用来直接操作 DOM。
	//binding：一个对象，包含以下 property：
    inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用
       el.focus();
    }
});

//局部自定义指令
directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        },
        color: { // 为元素设置指定的字体颜色
          bind(el, binding) {
            el.style.color = binding.value;
          }
        }
	}

1、 输入框自动聚焦
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
<input v-focus>
```

## 指令

```vue
// vue  v-xxx  以 v- 这种命名的标记 就是vue指令

<!-- v-model 主要用于操作表单元素的值-->
<input type="text" v-model="message">

  v-bind:属性 简写为 :属性
  v-on:事件类型 简写为 @事件类型
  v-slot:插槽名称 简写为 #插槽名称
  v-for
  v-if
  v-else-if
  v-else
  v-show
  v-pre: 无需编译  <div v-pre>{{变量}}</div>
  v-cloak
  v-text <div v-text="变量"></div> 等价于 插值表达式 <div>{{变量}}</div>
  v-html <div v-html="变量"></div>
  v-once
  v-model
```

### v-cloak

```vue
<!-- 闪烁 -->
```

### v-bind控制元素属性：

```vue
<!-- v-bind 指令-->
<div id="app">
    <!-- v-bind="JS表达式" -->
    <!-- JS表达式：一行代码，甚至一个变量。 -->
    <!-- 绑定属性 -->
    <div v-bind:class="cName">3</div>
    <!-- 简写 -->
    <div :class="cName">4</div>
    <!-- 在标签属性中记录多个变量 -->
    <div v-bind:class="[cName,aaa]">5</div>
    <div v-bind:class="[cName,num==1?aaa:'']">6</div>
    <div v-bind:class="[cName,num==1?'active':'']">7</div>
</div>
```

### **v-on **控制事件：

```vue
<div id="app">
    <button v-on:click="myClick">按钮（点击）</button>
    <!-- 简写 -->
    <!-- @ 修饰符号取代 v-on:   -->
    <button @click="myClick('参数')">按钮（点击）</button>
    <button v-on:mouseenter="myEnter">按钮（移入）</button>
</div>

<script>
    new Vue({
        el: "#app", // 挂载点(容器)
        methods: { // 添加方法（当前对象用于添加程序的方法）
            foo() {console.log("test")},
            myClick(){console.log("click")},
            myEnter(){console.log("mouseenter")}
        }
    })
</script>
```

### v-for   列表渲染（循环）:

```vue
<!-- v-for="JS代码" -->
<!-- item 代表数组的每一项数据 -->
<!-- index 代表数组的索引值 -->
<ul>
    <li v-for="item,index in arr" v-bind:key="item">{{index}}-{{item}}</li>
</ul>
```

### v-if 添加

```vue
<!-- v-if:true ==> 添加节点，false ==> 移除节点-->
<div v-if='code==="a"'>a</div>
<div v-else-if='code===b'>b</div>
```

### v-show	隐藏

```vue
<!-- v-show:true ==> 显示节点，false ==> 隐藏节点-->
```

### v-model表单 双向数据绑定

```vue
<input v-model=''>
```

### v-html

```vue
<!--v-text  ==  {{}}
v-html-->
```

### v-once

```vue
<!--v-once:只会编译一次
```

### v-pre:

```vue
<!--无需编译
```

## 属性

### **属性计算 computed**

```vue
<div id="container">
    <h1>{{message}}</h1>
    <h1>{{mytitle}}</h1>
    <p>{{mycontent}}</p>
    <div>
        <input type="text" v-model="a">
        <span>+</span>
        <input type="text" v-model="b">
        <span>=</span>
        <input type="text" v-model="c">
    </div>
</div>

<script>
new Vue({
    el: "#container",
    data: {a: 100,b: 200},
    // prop 属性计算
    // 计算某个属性的结果时，会有函数作用域
    // 在函数作用域中，计算，处理逻辑....
    // 编写时，作用域需要有返回值，返回值就是需要渲染的结果
    
    computed: {
        message(){return 123},
        mytitle(){return "我的标题"},
        mycontent(){return "我的内容"},
        c() {// 此处是个函数（意味着可以编写很多实现功能的代码）
            this.a = this.a - 0 ;
            this.b = this.b - 0 ;
            return this.a + this.b;
        }
    }
})
</script>




```

### **属性侦听 watch** 

```vue
<div id="container">
    <h1>{{message}}</h1>
    <button 
        v-on:click="sub">点击按钮减掉一个字符</button>
    <h2>长度: <span> {{len}}</span>个</h2>
    <h1 style="color:red;">{{v1}}</h1>
    <p>{{res}}</p>
</div>
<script>
// 创建Vue实例
new Vue({
    el: "#container",
    data: {message:"这是一个坏消息",len: 7,v1:"",res:""},
    // 侦听器
    // 观察数据的变化
    // 此处的函数需要数据发生变化才会执行（可以说数据不变化函数不执行）
    watch: {
        message(){
            console.log("test");
            this.len = this.message.length;
        },
        // 属性侦听时 执行的这个函数，可以接收传递的参数
        v1(newV,oldV){
            // newV  这是新的值（赋值时）
            // oldV  这是旧的值 (原来的)
            console.log({newV,oldV});
            // 额外添加的属性 记录当前V1的变化
            // this.res = oldV + newV;
        }
    },
    // 添加方法
    methods: {
        sub(){
            if(this.message.length == 0){return false}   
            // 记录被减掉的字符
            this.v1 += this.message.slice(0,1);
            // 每次点击按钮 就会减掉一个字符
            this.message = this.message.slice(1);
        }
    }
})
</script>
```

### 过滤器（filters）

```vue
<div >
    <h1>{{ cloths | getSex }}</h1>
</div>

<script>
    new Vue({
    	el: "#container",
        data:{
            
        }
        filters:{
        	getSex(str){
        		let res ="";
        		if(str.includes("红色")){
                    res = "她可能是女生"
                }
                return res;
    		}
    	}
    })
</script>
```

### **事件修饰符号**

```vue
<!-- v-on:keydown.enter -->
<!-- @keydown.enter = "myKeyDown"  按回车按键-->
<!-- @keydown.a = "myKeyDown" -->
<!-- @keydown.alt = "myKeyDown" -->
<!-- @keydown.space = "myKeyDown"  空格按键-->
组合按键
   .ctrl.y
   .shift.y
   .alt.y
   .ctrl.shift.y
   .ctrl.alt.y
   .ctrl.shift.alt.y

事件处理
  修饰符
  .stop ==> 阻止事件冒泡
  .prevent ==> 阻止浏览器默认行为
  .capture ==> 捕获阶段触发事件
  .self ==> 触发自身事件
  .once ==> 一次性事件(事件只会触发一次)
  .passive ==> 不会等待onscroll停下再触发, 提高移动端的onscroll的流畅度
```

```vue
<!-- 嵌套关系的标签-->
<!-- 
    event.stopPropagation() JS原生
    @click.stop="myClick"  阻止事件冒泡  VUE
 -->
<!-- <div @click="myClick('div')"class="div">
        <ul @click.stop="myClick('ul')"class="ul"> 
               <li @click.stop="myClick('li')" class="li"></li>
        </ul>
</div> -->
```

```vue
<!-- @click.self="myClick('ul')"  点击触发事件源自身的事件（不影响其他元素的事件）-->
<!-- <div  @click.self="myClick('div')" class="div">
            <ul @click.self="myClick('ul')" class="ul"> 
                    <li @click.self="myClick('li')" class="li"></li>
            </ul>
 </div> -->
```

```vue
<!-- 
    监听事件捕获
    从外 div --- ul --- li 到内
    @click.capture="myClick('div')"
    监听事件捕获 仅仅在div标签上触发事件
    @click.capture.self="myClick('div')"
  -->
<div @click.capture="myClick('div')" class="div">
      <ul @click.capture="myClick('ul')" class="ul"> 
            <li @click.capture="myClick('li')" class="li"></li>
      </ul>
</div>
```

## 插槽

```js
父子组件通讯
data数据只能从父组件流向子组件
子组件触发自定义事件通知父组件更改数据

组件的props的对象写法
props: ['属性1', '属性2']
props: {
     属性1: {
     //String, Number, Boolean, Array, Object
     //type: String
     type: 属性的类型,
     default: 默认值
},
          
    <my-box>
      <template #c="mydata">
        <child :myuser="mydata.user"><child>
        <div>{{mydata.animal}}</div>
      </template>
      
      <template #default> 无名插槽, #default可写可不写
        <div></div>
      </template>
      
    </my-box>

    my-box的内部结构
    <div>
      <slot name="c" :user="数据" :animal="数据"><slot>
      <h1></h1>
      <slot></slot>
    </div>
```

## vue脚手架

```js
安装Node.js
安装vue脚手架
npm i @vue/cli -g
cnpm i @vue/cli -g

  创建vue项目
  vue create 项目名称

  分析vue脚手架创建的项目
  vr
  |- node_modules 保存第三方依赖包目录
  |- public 公共文件目录
    |- favicon.ico 浏览器的标签显示的图标
    |- index.html vue项目根页面(宿主页面)
  |- src 开发目录
    |- assets 静态文件目录(存在图片、视频、音频....)
    |- components 公共组件目录
    |- router 路由配置目录
    |- views 视图目录(配置路由的组件)
    |- App.vue 根组件
    |- main.js vue项目的入口文件
  |- .browserslistrc 浏览器配置
  |- .gitigonre git仓库的忽略文件配置
  |- babel.config.js 将es6转es5
  |- jsconfig.json vue配置, src路径的别名@, 输出目标js为es5...
  |- package.json 项目描述文件
  |- README.md 项目说明
  |- vue.config.js vue打包配置
  
   声明式导航
    <router-link to="路径"></router-link>

    编程式导航
      this.$router.push('路径')
      this.$router.push({path: '路径'})
      this.$router.push({name: '路由名称'})

    携带参数
      路由参数 定义路由参数 /home/:参数名1/:参数名2
        this.$router.push({name: '路由名称', params: {参数名1: 值, 参数名2: 值}})

      查询参数
        this.$router.push({name: '路由名称', query: {参数名1: 值, 参数名2: 值}})

返回上一级
this.$router.go(-1);
```

### axios: 基于promise封装的ajax

```js
安装axios
npm i axios --save

安装vue-axios
npm i vue-axios --save
  
this.axios({
      method: 'get',
      url: '',
      //get请求的参数
      params: {

      }
}).then().catch()

this.axios({
      method: 'post',
      url: '',
      //post请求的参数
      data: {

      }
}).then().catch()
```

### 路由守卫

```js
路由守卫
    两个全局守卫
      全局前置守卫 beforeEach
      全局后置守卫 afterEach

    路由独享守卫
      进入路由之前：beforeEnter

    组件内守卫
      进入组件之前: beforeRouteEnter
      组件离开之前: beforeRouteLeave
      组件路由参数发生改变之前: beforeRouteUpdate
      
    路由的元信息
    meta

完整的地址
    http:// ==> 协议
    www.kangliuyong.com ==> 域名
    10000 ==> 端口
    index ==> 文件夹
    home.html ===> 文件
    ?key=1&value=2&a=100 ==> 查询参数
    #abc ==> 哈希(散列, 信息片段)

vue的路由模式
    浏览器的历史模式
    hash(哈希)模式
    路由模式
    mode: 'history | hash'
```

### 缓存组件

```js
    keep-live: 缓存组件, 如果组件被访问过, 再次访问组件时, 不会重新实例化组件
    include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
    exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
    max - 数字。最多可以缓存多少组件实例。

    <keep-live include="a"></keep-live>
    <keep-live include="a,b"></keep-live>
    <keep-live :include="[a,b]"></keep-live>
    <keep-live :include="/a|b/"></keep-live>

    <keep-live exclude="a"></keep-live>
    <keep-live exclude="a,b"></keep-live>
    <keep-live :exclude="[a,b]"></keep-live>
    <keep-live :exclude="/a|b/"></keep-live>

    <keep-live :include="[a,b,c]" max="2"></keep-live>
```

### 动画

```js
动画
<transition name="slide"></transition>

.slide-enter-active, .slide-leave-active {
        transition: left .5s;
}
.slide-enter, .slide-leave-to {
      left: 100px;
}

<transition></transition>配合animate.css

安装animate.css
npm i animate.css --save
```

# Vuex

```css
五大核心理念：
	state：数据	——data
	mutations：修改state	——methods（没有异步操作）
	actions：用于提交mutations，修改state		——methods（有异步操作）
	getters：过滤state数据	——computed
	modules
	
辅助函数, 简化引用vuex的state、mutations、actions、getters的写法, 可用可不用
    mapState()
    mapMutations()
    mapActions()
    mapGtters()

import {名字} from 'vuex'; 导包

addAnimal(value) {
      // this.$store.commit('addAnimal', value);

      //提交actions
      this.$store.dispatch('addOneAnimal', value).then(result => {
        console.log('result ==> ', result);
        console.log('修改state数据之后做一些事情');
      }).catch(err => {
        console.log('err ==> ', err);
      })
    },
 	...mapActions(['testAction', 'changeTitle']),
    ...mapActions({
      changeT: 'changeTitle',
      changeTi(dispatch, payload) {
        //dispatch: 提交actions的方法
        //payload: 参数
        //前面做一些事情
        dispatch('changeTitle', payload);
      }
    })


//过滤state数据, 类似组件的computed, 需要返回一个结果
//只读的, 如果使得getters变化, 修改更改其依赖的state数据
  getters: {
    filterCount(state) {
      return state.counts.filter(v => v >= 90);
    },

    product500(state) {
      return state.products.filter(item => item.price >= 500);
    }，
    ...mapGetters({
      pro500: 'product500'
    })
  }

export default new Vuex.Store({
  state: {		//vuex数据
    all_information: [],
    all_durati:[],
    body:123,
  },
  getters: {

  },
  mutations: {
    saveall_information(state, pathName) {
      state.all_information = pathName;			//改
    },

  },
  actions: {
  },
  modules: {
  }
})

普通组件之中直接获取数据  _this.$store.state.all_information
修改数据  _this.$store.commit('saveall_information', res.data)
```

# vue3

```vue
import {
		ref, //一般处理基本类型
		reactive //处理复杂的数据类型
} from 'vue'
```

## 全局方法

```vue
const app = createSSRApp(App)
app.config.globalProperties.$getImgSrc = function(img) {
		return "https://welfare.juguzi.com/images/" + img;
};

import {getCurrentInstance} from 'vue'
const { proxy } = getCurrentInstance()
```

## 父子组件通讯

```vue
子组件
<template>
  <div>
    {{msg}}
    {{info}}
  </div>
</template>
 
<script>
export default {
  props:['msg'],
  setup(props) {
    console.log(props.msg)
 
    return {
      info:props.msg
    }
  }
}
</script>

父组件
<template>
  <div>
    <Article :msg="name"></Article>
  </div>
</template>
 
<script>
import Article from '@/components/Article.vue' 
export default {
  components: {
    Article
  },
  setup() {
    return {
      name: '渐行渐远渐无书，水阔鱼沉何处问'
    }
  }
}
</script>
```

# 微信小程序

## 生命周期

### 应用生命周期

```
一、应用生命周期（写在app.vue中）

onLaunch：当整个项目启动，渲染完成时触发（全局只触发一次）
onShow：小程序显示出来（从后台进入前台显示，可以触发多次）
onHide：小程序隐藏起来时触发（从前台进入后台，可以触发多次）
onError: 出现异常时触发
```

### 页面生命周期

```
二、页面生命周期
onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参）
onShow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面
onReady 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发
onHide 监听页面隐藏,通过tabbar切换页面，也是隐藏而不是卸载
onUnload 监听页面卸载
onPullDownRefresh 监听用户下拉动作，一般用于下拉刷新。前提开启下拉刷新。

下拉刷新开启：pages.json中全局配置，或者页面的style中配置或通过 uni.startPullDownRefresh()方法
下拉刷新关闭：uni.stopPullDownRefresh()

onReachBottom：上拉加载，页面滚动到底部的事件，在事件中可以加载下一页数据
在pages.json中的页面style中，通过onReachBottomDistance可以
配置页面上拉触底事件触发距页面底部的距离，默认50px
```

### 组件生命周期

```
三、组件生命周期
beforeCreate(): 在实例初始化之后被调用,此时data中的数据还是undefined
created(): 在实例创建完成后被立即调用。此时data中的数据和基本方法都可以访问了
beforeMount(): 在挂载开始之前被调用.
mounted(): 挂载到实例上去之后调用,注意：此处并不能确定子组件被全部挂载，如果需要子组件
完全挂载之后在执行操作可以使用$nextTick
beforeUpdate(): 数据更新时调用，发生在虚拟 DOM 打补丁之前
updated(): 由于数据更改导致的虚拟 DOM 重新渲染和打补丁
beforeDestroy: 实例销毁之前调用
destroyed(): Vue 实例销毁后调用。
```

## 云函数

### 增

```js
let db = wx.cloud.database()
      let userCollection = db.collection(' ')
      userCollection.add({
        data: {
          
        }
      }).then(res => {
        console.log('添加成功');
      }).catch(err => {
        console.log('添加失败', err)
      })
```

### 查

```js
let db = wx.cloud.database()
    let userCollection = db.collection('address')
    userCollection.where({
      _openid: "oXeb25Aoq4Z68uDw6um7wFO0bfXQ"
    }).get().then(res => {
      console.log(res.data);
    }).catch(err => {
      console.log('查询失败', err)
    })
```

### 删

```js
let db = wx.cloud.database() //设置数据库
let userCollection = db.collection('test_user') //单引号里为刚刚新建的集合名
userCollection.where({
	//先查询
	_id: this.data.dataId 
}).remove().then(res => {
	console.log('删除成功')
	this.setData({
		//数据库删除了，那也得将data里的值也删了，不然数据容易出错
		number: ‘ ’
	})
}).catch(err => {
	console.log('删除失败',err)//失败提示错误信息
})
```

### 改

```js
let db = wx.cloud.database()
let userCollection = db.collection('test_user')
userCollection.where({
	//先查询
	_id: this.data.dataId 
}).update({
	data: {
    	number: 2,
    	num: 2,
    }
}).then(res => {
	console.log('更新成功')
	this.setData({
		number: 2,
		num: 2,
	})
}).catch(err => {
	console.log('更新失败',err)//失败提示错误信息
})
```

## 存储本地

```js
 

let _this = this
wx.getStorage({
      key: '名称',
      success(res){
        console.log(res);
        if (res.data == '[]') {
          res.data = ''
        }
        _this.setData({
          history_list: res.data
        })
        console.log(_this.data.history_list);
      }
    }) 
    
wx.removeStorage({key: '名称'})

wx.clearStorage()
```

## 对象赋值

```js
//对象中的属性赋值
this.setData({
'对象.属性':赋值内容
})
//数组对象赋值
'main[2].count': res.data.length
[`list[${i}].pnum`]: event.detail
```

## 小程序事件

```
WXML的冒泡事件列表：
touchstart 手指触摸动作开始
touchmove 手指触摸后移动
touchcancel 手指触摸动作被打断，如来电提醒，弹窗
touchend 手指触摸动作结束
tap 手指触摸后马上离开
longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 1.5.0
longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替）
transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发
animationstart 会在一个 WXSS animation 动画开始时触发
animationiteration 会在一个 WXSS animation 一次迭代结束时触发
animationend 会在一个 WXSS animation 动画完成时触发
touchforcechange 在支持 3D Touch 的 iPhone 设备，重按时会触发

普通事件绑定： bindtap
绑定并阻止事件冒泡：catchtap
与 bind 不同， catch 会阻止事件向上冒泡。

data-index 获取自定义属性
这里传递参数的时候，可以改成在组件是绑定 data-xxx,绑定的值在event事件中通过
event.target.dataset.xxx来获取
event.currentTarget.dataset.index
```

## 跳转 / 传值

```js
跳转tab
wx: wx.switchTab({
      url: `/pages/recommend/recommend`
    })

wx.navigateTo({
      url: '/pages/calculator/calculator',
    })
wx.redirectTo
wx.reLaunch.（关闭所有）

单个数据传递
goDetail(e){
      let id=e.currentTarget.dataset.item._id
      console.log("单个参数的传递",id)
      wx.navigateTo({
        url: '/pages/shop_detail/shop_detail?id='+id,
      })
    },
    
接收数据
onLoad (e) {
      console.log('接受到传送的单个参数',e)
    }
    
多个数据传递
getpass: function(e) {
        let id = e.currentTarget.dataset.id;
        let number=this.data.list[id]
        let strr = JSON.stringify(number);
        console.log("多个参数的传递",number)
        wx.navigateTo({
          url: '/pages/payfor/payfor?jsonStr=' + strr ,
        })
      },
  
接收数据
 onLoad: function(options) {
        let that = this
        // console.log(options)
        //  console.log(options.jsonStr)
        //  console.log(options.strr)
        let item = JSON.parse(options.jsonStr)
        console.log('上个页面跳转的参数', item)
        wx.setStorageSync('address', item)
        let address=wx.getStorageSync('address')
        console.log(address.name)
        that.setData({
          address:item
        })
      },
```

# uniapp（多端）

## app

```vue
获取dom
const query = uni.createSelectorQuery().in(this)
	query.select('.tabbar').boundingClientRect(data => {
		console.log('.tabbar', data.height);
}).exec()

获取可视区域
const res = uni.getSystemInfoSync();  res.windowHeight 
```

## 网络

```vue
uni.getNetworkType({
	success: function(res) {
					if (res.networkType == 'none') {
						uni.showModal({
							title: '网络链接失败',
							content: '检测到网络权限可能设置为关闭，您可以在“设置”中检查无线数据及蜂窝移动网络',
							success: function (res) {
								if (res.confirm) {
									console.log('用户点击确定');
									 plus.runtime.quit();
									 plus.ios.import('UIApplication').sharedApplication().performSelector('exit');
								} else if (res.cancel) {
									console.log('用户点击取消');
									 plus.runtime.quit();
									 plus.ios.import('UIApplication').sharedApplication().performSelector('exit');
								}
							}
						});
					}
	}
});
```

## 订阅消息

```
wx.requestSubscribeMessage({
	tmplIds: ['FgXOn86wn1UUgoWSPo0Nxk8LU4jVnz1g7oMZv7vxm-0'],
	 success (res) { 
		console.log(res);
	}
})
```

## video

```vue
object-fit：是否铺满 fit / cover 
muted：是否静音
```

### 滚动

```
 <scroll-view class="scroll-view" scroll-y="true" :scroll-top="scrollTop" @scroll="scroll" @scrolltoupper="upper"
                     @scrolltolower="lower">
 
scroll(event) {//距离每个边界距离
     console.log(event.detail)
},
        
scrolltolower() {//滚动到底部/右边触发
     console.log(123213213213);
},
       
 scrolltoupper() { // 滚动到顶部/左边触发
     console.log(2232332);
}
```

### 视频下载

```
uploadVideo(e) {
				// 提醒用户下载中
				uni.showToast({
					title: "下载中",
					icon: "loading"
				})
				// 1 将远程文件下载到小程序的内存中
				console.log(e);
				uni.downloadFile({
					url: e.playUrl,
					success: (res) => {
						// 2 成功下载后而且状态码为200时将视频保存到本地系统
						if (res.statusCode === 200) {
							uni.saveVideoToPhotosAlbum({
								filePath: res.tempFilePath
							})
							uni.hideLoading();
							// 提示用户下载成功
							uni.showToast({
								title: "下载成功",
								icon: "success"
							});
						}
						// 如果该资源不可下载或文件格式出错则提示用户
						else {
							uni.showToast({
								title: "资源格式错误，请联系管理员"
							});
						}
					},
					fail: (err) => {
						// 下载失败提醒
						uni.hideLoading();
						uni.showToast({
							title: "下载失败"
						})
					}
				})
			},
```

## 路由控制

```
"navigationStyle": "custom",
去除顶部自带title
"navigationBarBackgroundColor": "white"
修改背景颜色
```



## 控制

```
padding-bottom: env(safe-area-inset-bottom);

/强制更新 动态修改数组数据
that.$forceUpdate();
_this.$set(_this.msg.MediaList[index], 'currentTime', '00:00');

:style="{backgroundImage:'url('+e+')'}"
background-repeat: no-repeat;
background-position: 50% 50%;
background-size: cover;

"app-plus":{	
		"bounce":"none"// 将回弹属性关掉
	}
}
:src="'https://picsum.photos/seed/'+index+'a'+'/355/250'"

富文本
<rich-text :nodes="data.goods_desc.replace(/\<img/gi, '<img style=\'max-width: 100%;height:auto;display:block;\'')"></rich-text>

:class="[{'a':c==i},'b']"

@click.native.stop

.replace(/\<img/gi, '<img style=\'max-width: 100%;height:auto;display:block;\'')

background-image: -webkit-linear-gradient(bottom, #FEF1A0 0%, #FFFFFF 100%);
			-webkit-text-fill-color: transparent;
			-webkit-background-clip: text;

//常亮
onLaunch() { 
	uni.setKeepScreenOn({ 
		keepScreenOn: true
	})
},

<button  class="m2_item" type="submit" open-type='contact'>

uni.previewImage({
	urls:[i],
	current:0
})
```

## 安全距离

```
// 顶部安全距离
let {
	statusBarHeight,
	windowWidth
} = uni.getSystemInfoSync()
this.BarHeight = statusBarHeight

let {
	top,
	bottom,
	left
} = uni.getMenuButtonBoundingClientRect()
this.navBareight = (bottom - statusBarHeight) + (top - statusBarHeight)

this._this = getCurrentInstance();
			
<view class="navbar" :style="{height:IndexStore.BarHeight+IndexStore.navBareight +'px'}">
	<view class="narbar-content" :style="{height:IndexStore.navBareight+'px'}">
		<uv-icon name="search" size="28" color="#444548"></uv-icon>
	</view>
</view>
	
.navbar {
	width: 100vw;
	position: relative;
	position: sticky;
	z-index: 5;
	top: 0;
	left: 0;
	background-color: white;
	.narbar-content {
		position: absolute;
		left: 0;
		bottom: 0;
		box-sizing: border-box;
		padding: 0 10rpx;
		// background-color: skyblue;
		display: flex;
		align-items: center;
	}
}
```

## **滑动选择器 slider**

```vue
min: 最小值
max: 最大值
step: 步长, 取值必须大于0, 并且可被(max - min)整除
disabled: 是否禁用
value: 当前取值
activeColor: 滑块左侧已选择部分的线条颜色
backgroundColor: 滑块右侧背景条的颜色
block-size: 滑块的大小, 取值范围为12 - 28
block-color: 滑块的颜色
show-value: 是否显示当前value
@change: 完成一次拖动后触发的事件
@changeing: 拖动过程中触发的事件
<view>
    <slider @change="slider" value="10" show-value="true"/>
</view>
```

## 跳转

```js
1、uni.navigateTo保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。
uni.navigateTo({
	url:'./index/index'
});

2、uni.redirectTo关闭当前页面，跳转到应用内的某个页面。
uni.redirectTo({
	url: './index/index'
});

3、uni.reLaunch关闭所有页面，打开到应用内的某个页面。
uni.reLaunch({
	url: './index/index'
});

4、uni.switchTab跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。
uni.switchTab({
	url: '/pages/index/index'
});

5、uni.navigateBack关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。
uni.navigateBack({
	delta: 2  //返回两层页面
});

const pages = getCurrentPages()
const curPage = pages[pages.length - 1]
curPage.onLoad(curPage.options) 
curPage.onShow()
curPage.onReady()

显示动画	关闭动画	显示动画描述（关闭动画与之相反）
slide-in-right	slide-out-right	新窗体从右侧进入
slide-in-left	slide-out-left	新窗体从左侧进入
slide-in-top	slide-out-top	新窗体从顶部进入
slide-in-bottom	slide-out-bottom	新窗体从底部进入
pop-in	pop-out	新窗体从左侧进入，且老窗体被挤压而出
fade-in	fade-out	新窗体从透明到不透明逐渐显示
zoom-out	zoom-in	新窗体从小到大缩放显示
zoom-fade-out	zoom-fade-in	新窗体从小到大逐渐放大并且从透明到不透明逐渐显示
none	none	无动画

"animationType": "fade-in",
"animationDuration": 50

传参对象
 this.textObj = options.textObj.replace(/""/g, "");
  this.textObj=JSON.parse(this.textObj)
```

## 获取手机数据

```vue
uni.getSystemInfo({
	success: (res) => {
		const screenWidth = res.windowWidth; // 屏幕宽度，单位为px
		const screenHeight = res.windowHeight; // 屏幕高度，单位为px
		console.log('屏幕宽度：', screenWidth);
		console.log('屏幕高度：', screenHeight);
	},
});
```



## 储存

```js
var regionss = uni.getStorageSync("region")
uni.setStorageSync('latitude', res.latitude);

uni.setStorage({
	key:"id",
	data:100,
	success(){
		console.log("存储成功");
	}
})	

uni.getStorage({
	key: "id",
	success(res){
		console.log("获取成功",res);
	}
})

uni.removeStorage({
	key:"id",
	success(){
		console.log("移除数据");
	}
})
```



## 提示

```js
//成功提示框
uni.showToast({
	title: '提交成功',
	duration: 2000
});

//加载框
uni.showLoading({
	title: '加载中'
});

setTimeout(function () {
	uni.hideLoading();
}, 2000);

//去掉图标，只显示文字提示框
uni.showToast({
	title: '请填写员工工号',
	icon:'none',
	duration: 2000
});

//模态弹窗
uni.showModal({
	title: '提示',
	content: '这是一个模态弹窗',
	success: function (res) {
		if (res.confirm) {
			console.log('用户点击确定');
		} else if (res.cancel) {
			console.log('用户点击取消');
		}
	}
});
```



## 微信小程序端

### 登录

```js
return new Promise((resolve, reject) => {
					uni.login({
						success: res => {
							console.log(res);
						}
					})
					uni.getUserProfile({ //获取微信信息
						desc: '用于获取您的个人信息',
						success: res => {
							console.log(res)
						}

					})
				})
```

## 时间戳转换

```js
sjc(value) {
				if (value == undefined) {
					return;
				}
				// let date = new Date(value * 1000);
				let date = new Date(value);
				//时间戳为10位需*1000，时间戳为13位的话不需乘1000
				let y = date.getFullYear();
				let MM = date.getMonth() + 1;
				MM = MM < 10 ? ('0' + MM) : MM; //月补0
				let d = date.getDate();
				d = d < 10 ? ('0' + d) : d; //天补0
				let h = date.getHours();
				h = h < 10 ? ('0' + h) : h; //小时补0
				let m = date.getMinutes();
				m = m < 10 ? ('0' + m) : m; //分钟补0
				let s = date.getSeconds();
				s = s < 10 ? ('0' + s) : s; //秒补0
				// return y + '-' + MM + '-' + d; //年月日
				return y + '-' + MM + '-' + d + ' ' + h + ':' + m + ':' + s; //年月日时分秒
			}
```

## 去掉标题

```js
"style": {
	"navigationBarTitleText": "商城",
	"navigationStyle":"custom",  //可以去掉小程序端的顶部导航
	"app-plus":{
		"titleNView":false   // 去掉APP、H5的顶部导航
	}
}
```

# ts

声明变量+基础数据类型：

```tsx
let isDone: boolean = false;
let decLiteral: number = 6;
let name: string = "bob";
let list: number[] = [1, 2, 3]; or let list: Array<number> = [1, 2, 3];

元组 Tuple
let x: [string, number];
```

# node

```js
安装node.js第三方模块
npm i 模块名 --save
npm i 模块名 --save-dev

express: 搭建web服务器模块(第三方模块)
npm i express --save

使用node命令启动服务器
node index.js

commonJS规范
导入: require()
导出: exports, module.exports
exports相当于给module.exports对象添加属性

express中间件: 在访问接口之前做一些事情
  app.use((req, res, next) => {

  })


借助nodemon模块辅助开发, 当后台服务器文件发改变时, 后台自动重启
npm i nodemon -g

使用nodemon启动node.js服务器
nodemon index.js
//自动编译 

视图引擎ejs
  app.set('views', 视图路径)
  app.set('view engine', 视图引擎类型)

  //如果是html后缀, 则需要以下配置
  app.engine(引擎解析视图文件后缀, ejs.__express)

__dirname: 当前文件的绝对路径, 属于node.js全局变量

module.exports 和 exports 

get、post、跨域请求


借助body-parser模块解析请求体
npm i body-parser --save
```

```js
const express = require('express');

//创建express实例
const app = express();

app.get('/user', (req, res) => {
  console.log('访问/user接口');
  res.send({msg: '获取用户数据成功', code: 2000, result: [{uid: 'u001', phone: 15219233321, nickname: 'Kevin'}]});
})
```

## 跨域问题

```js
CORS配置
app.all('*', (req, res, next) => {

  //允许跨域地址
  res.header("Access-Control-Allow-Origin", "http://www.kangliuyong.com:10000");

  //*表示允许所有域请求，在实际开发中，一般指定允许某个域请求，如上面设置
  //res.header("Access-Control-Allow-Origin", "*");

  //如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
  res.header("Access-Control-Allow-Headers", "X-Requested-With");

  //该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

  //该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可
  //res.header('Access-Control-Allow-Credentials', true);

  next();

});
```

## 操作数据库

### 连接数据库

```js
npm i sequelize
npm i mysql2 --save

//导入sequelize
const {Sequelize,Model,DataTypes} = require('sequelize')
//创建sql连接实例
const sequelize = new Sequelize('textdb', 'root', '123456', {
    host: 'localhost',
    dialect: 'mysql',

    //定义字段规则
    define:{
        underscored:true//当定义模型字段时，有大写字母自动转换为下划线
    }
});
//测试连接mysql
// async function a() {
//     try {
//         await sequelize.authenticate();
//         console.log('连接成功');
//     } catch (error) {
//         console.error('连接失败', error);
//     }
// }
// a()
```

### 添加表

```js
//定义用户（user）模型
class user extends Model{}
user.init({
    id:{
        type:DataTypes.INTEGER.UNSIGNED,//字段类型，INTEGER:整形，UNSIGNED:无符号
        allowNull:false,//是否允许为null
        primaryKey:true,//主键
        autoIncrement:true,//自动递增
        comment:'表id'//备注
    },
    phone:{
        type:DataTypes.STRING(11),
        allowNull:false,
        defaultValue:'',//默认值
        unique:true,//是否唯一
        comment:'手机号'
    },
    password:{
        type:DataTypes.STRING(32),
        allowNull:false,
        defaultValue:'',
        comment:'密码'
    },
    nickName:{
        type:DataTypes.STRING(30),
        allowNull:false,
        defaultValue:'',
        comment:'昵称'
    }
},{
    sequelize,
    modelName:'User',
    freezeTableName:true,//强制停止复数化
    //指定表名
    // tableName:'t-user'
    //不创建时间戳字段
    // createdAt:false,
    // updatedAt:false
})
//同步到mysql
//force:删除原有的表，创建新表，false ==> 如果表存在则不执行，不存在则创建
user.sync({
    force:false
})
```



# react

## 上手

```js
	<!-- react文件 -->	
	<script src="./react.development.js"></script>
    <!-- react-dom文件,渲染视图,生成ReactDOM对象 -->
    <script src="./react-dom.development.js"></script>
    <!-- babel文件,处理JSX语法,ES6 转 ES5 -->
    <script src="./babel.min.js"></script>


	<script type="text/babel">
        // 渲染视图,将视图渲染到div #root中
        const root = ReactDOM.createRoot(document.getElementById('root'))
        // 渲染组件
        let title = '我要赚米米'
        let id = 'html'

        let html = <div id={id} name="react">
            <h1>{title}</h1>  
            <h2>React开发</h2>  
        </div>
        root.render(html)
    </script>
```

## 脚手架

```react
 npm i create-react-app -g	//安装脚手架
 create-react-app -V	//查看版本
 create-react-app app	//创建
 npm start	//运行
```

## 安装less

```react
1.npm install less-loader less --save-dev //下载
2.查找 node_modules 下面的react-scripts/config/webpack.config.js
3.import "lib-flexible"; index.js里面
//我自己添加
const lessRegex = /\.less$/;
const lessModuleRegex = /\.module\.less$/;
//搜索sass-loader下面
{
  test: lessRegex,
  exclude: lessModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 2,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
      modules: {
        mode: 'icss',
      },
    },
    'less-loader'
  ),
  sideEffects: true,
},

 //我自己添加
{
  test: lessModuleRegex,
  use: getStyleLoaders(
    {
      importLoaders: 2,
      sourceMap: isEnvProduction
        ? shouldUseSourceMap
        : isEnvDevelopment,
      modules: {
        mode: 'local',
        getLocalIdent: getCSSModuleLocalIdent,
      },
    },
    'less-loader'
  ),
},
```

## px转rem

```react
1.//安装postcss-pxtorem
npm i lib-flexible postcss-pxtorem -s

2.在src目录下index.js里引入lib-flexible
import "lib-flexible";

3.修改webpack.config.js（这个文件在node_modules文件夹下的react-scripts文件夹下的config文件夹中）
const pxtorem = require('postcss-pxtorem');

//搜索postcss-normalize（因为这里是三元运算符，所以要加两次）
// 基于iphone6 适配
pxtorem({ rootValue: 37.5, unitPrecision: 1, propList: ['*'] })
```



## 组件

```react
const {Component} = React

const com = ReactDOM.createRoot(document.getElementById('component'))
        class Box extends Component {
            // 类数据定义
            constructor() {
                super()
                this.a = 'a'
                this.state = {
                    title: 'react组件',
                    arr: [1, 2, 3],
                    n: 0,
                    show:false
                }
            }

            update() {
                this.a = 'b'
                // this.state.title='改变啦'
                this.setState({
                    title: '改变啦',
                    n: 1,
                    show:!this.state.show
                })
            }

            render() {
                console.log('render执行');
                return (
                    <div>
                        <h1>{this.state.title}</h1>
                        <h2>{this.a}</h2>
                        <button onClick={() => (this.update())}>改变</button>
                        {/*<div>{this.state.arr}</div>*/}
                        { this.state.show && <h1>我出来啦!</h1>}
                        
                        <div>
                            {
                                this.state.arr.map((item, index) => 
                                    <h1 key={index}>{item}</h1>
                                )
                            }
                        </div>

                    </div>
                )
            }
        }

        com.render(<Box />)
```

## 页面跳转

```react
// ********不携带参数跳转********
	navigate('/detail');

// ********跳转到详情页面, 并且携带state参数, 该参数不会在浏览器地址栏中显示********
    navigate('/detail?a=10&b=20', {state: {x: 1, y: 2}});
    
{/*目标页面*/}
import {
  //截取state参数的hook
  useLocation
} from 'react-router-dom';

    let location = useLocation();
    console.log('location ==> ', location);

// ********跳转到详情页面, 并且携带路由参数(url可见)********
	navigate('/detail/008/9');
{/*路由页面*/}
    path: '/detail/:pid/:count',
{/*目标页面*/}
import {
  //截取路由参数的hook
  useParams
} from 'react-router-dom';
	//截取路由参数
      let data = useParams();
      console.log('data ==> ', data)

// ********跳转到详情页面, 并且携带查询参数(url可见)********
	navigate('/detail?a=100&b=200');
{/*目标页面*/}
import {
  //截取查询参数的hook
  useSearchParams
} from 'react-router-dom';
	// 截取查询参数
      let [search] = useSearchParams();
      let s = {};
	  search.forEach((v,k) => {
          s[k] = v
      })
```

## 返回上一个页面

```react
// 不带参数 
window.history.back(-1)
// 带参数
this.props.history.push('/admin/user/info/' + userId) // 不确定
```



## 事件

```react
阻止事件冒泡
	e.stopPropagation()
表单
	input 输入框 value 必须与 onChange 使用 ，实现v-mode。
	
	

```

## ref

```react

    class Box extends React.Component {
      constructor() {
        super();

        this.h3Ref = React.createRef();
        this.divRef = null;
        this.A1Ref = null;
        this.A1Btn = null;

        this.state = {
          title: 'Ref',
          fruit: '荔枝'
        }
      }

      getBtn(el) {
        console.log('el ==> ', el);
        this.A1Btn = el;
      }

      componentDidMount() {
        console.log('this.h3Ref.current ==> ', this.h3Ref.current);
        console.log('this.divRef ==> ', this.divRef);
        console.log('this.A1Ref ==> ', this.A1Ref);
        //调用A1组件的getBook方法
        this.A1Ref.getBook();
      }

      //修改A1组件的book
      updateBook() {
        this.A1Ref.setState({
          book: 'React-App开发'
        })
      }

      render() {
        return (
          <div>
            <h3 className="title" ref={this.h3Ref}>{this.state.title}</h3>
            <div className="box" ref={el => this.divRef = el}></div>
            {/*在Box组件中直接引用A1组件的Button*/}
            <A1 ref={el => this.A1Ref = el} f={this.state.fruit} btn={el => {this.getBtn(el)}}></A1>
            <button onClick={() => {this.updateBook()}}>修改A1组件的book</button>
          </div>
        );
      }
    }
```



## 生命周期

```react
 class A2 extends React.Component {
      constructor() {
        super();
        this.state = {
          title: '生命周期'
        }
        console.log('01-A2-constructor');
      }

      //更新title
      updateTitle() {
        this.setState({
          title: 'React生命周期'
        })
      }

      //生命周期
      //组件挂载之前执行, 首次渲染组件执行一次
      UNSAFE_componentWillMount() {
        // console.log('02-this.state.title ==> ', this.state.title);
        console.log('02-A2-UNSAFE_componentWillMount');
      }

      //组件挂载之后执行, 推荐在这个钩子发起ajax请求，首次渲染组件执行一次
      componentDidMount() {
        // console.log('03-this.state.title ==> ', this.state.title);
        console.log('03-A2-componentDidMount');
      }

      //当组件接收的props发生改变时触发, 首次渲染组件不会执行
      UNSAFE_componentWillReceiveProps(newProps) {
        //newProps: 最新的props
        console.log('newProps ==> ', newProps);
        console.log('04-A2-UNSAFE_componentWillReceiveProps');
      }

      //更新state和props的拦截器, 首次渲染组件不会执行
      shouldComponentUpdate(newProps, newState) {
        //newProps: 最新的props数据
        //newState: 最新的state数据
        // console.log('newProps ==> ', newProps);
        // console.log('newState ==> ', newState);

        console.log('05-A2-shouldComponentUpdate');
        //必须返回一个布尔值
        //阻止更新, 不会引起render方法执行
        // return false;

        //更新, 会引起render方法执行
        return true;
      }

      //更新数据之前(数据同步到视图之前), 首次渲染组件不会执行
      UNSAFE_componentWillUpdate() {
        console.log('06-A2-UNSAFE_componentWillUpdate');
      }

      //更新数据之后(数据同步到视图之后), 首次渲染组件不会执行
      componentDidUpdate() {
        console.log('07-A2-componentDidUpdate');
      }

      //组件被卸载之前, 首次渲染组件不会执行
      componentWillUnmount() {
        console.log('08-A2-componentWillUnmount');
      }


      render() {
        console.log('A2-render');
        return (
          <div name="A2">
            <h1>{this.state.title}</h1>
            <h2>{this.props.book}</h2>
            <button onClick={() => {this.updateTitle()}}>修改title</button>
          </div>
        );
      }
    }

    //渲染组件
    root.render(
      <div>
        <A1 />
      </div>
    );
```

## 跨组件传值

```react
let {useState, createContext, useContext, useEffect} = React;
//createContext 创建 useContext 查询 useEffect 类组件钩子

//创建context, 并初始化值, 当不使用ProductContext.Provider组件提供数据时, 默认使用初始化数据
let ProductContext = createContext({name: '葡萄', price: 6});

let [product, setProduct] = useState({
        name: '苹果',
        price: 4.5
      })

<ProductContext.Provider value={product}></ProductContext.Provider>

//获取ProductContext
let data = useContext(ProductContext);

```



# Dart

## 变量声明

```dart
void main(){
    //void 没有返回值
}
//dart 变量会自动校验
//声明区分大小写
const //常量
final //可以开始不赋值，只能赋值一次；惰性
```

## 定义类型

```dart
String 类型 
    ''' a
    b
    c'''  //多行字符串 
print("$text1 $text2"); //拼接 

double 类型 int 类型
bool 类型
List 类型
    var list = <String>["选择类型"]
    list.add("数组添加")
    var list<> = List.filled(10,'')  //固定长度，参数一：长度 参数二：内容
```

## List常用属性

```dart
~/ //取整
??= //默认赋值
    
//常用属性：
    length 长度
    reversed 翻转 //反转之后不是数组  list.reversed.toList(); 设置为数组
    isEmpty 是否为空
    isNotEmpty 是否不为空
//常用方法：
    add 增加
    addAll 拼接数组
    indexOf 查找 //返回索引 没有返回-1
    remove 删除 //直接删除对应
    removeAt 删除 //删除下标
    fillRange(0,1,'') 修改 //下标修改
    insert(index,value) //指定位置插入
    insertAll(index,value) //指定位置插入数组
    toList() //转换成数组
    join(',') //转换为字符
    split() //字符串转换为数组
//Set 去重
    var s = new Set();

var newlist = list.where((value){reture value>5}) //循环遍历，满足条件reture
    			  any //返回bool 有一个满足条件返回true
    			  every //每一个都要
```

## 方法

```dart
返回数据类型 方法名(){}
int log(String username,[int age,String sex='男']){ //[可选参数]
    reture 123;
}

//命名参数
	int log2(String username,{int age,String sex='男'}){ //[可选参数]
    	reture 123;
	}
	log2(2,age:18,sex='男')

//匿名方法
     var a = (){}
  	 a ()
//自执行方法
     ((int n){
         print('自执行');
     })(12);
```

## 类

```dart
//定义首字母必须大写
class Person{
    String name;
    //默认匿名构造函数
    Person(this.name) ==>
    Person(String name,int age){
        this.name = name; //初始化 
        print('构造函数 实例化的时候被触发->a')
    }
    //命名构造函数
    Person.now(){
        print('命名构造函数-> b')
    }
    
    void printInfo(){
        print('构造方法')
    }
}

void main(){
    var a = new Person();
    var b = new Person().now;
}
```

## 泛型

```dart
T getData<T>(T value){reture value}//泛型 传入数值为什么类型就返回什么类型
```

## 异步

```dart
async 和 await
    //只有async方法才可以使用await，如果调用别的async方法必须使用await字符
    void main() async{
    var result = await test()
}
```

## 导入

```dart
//自定义库
import 'lib/my/myMath.dart' show getAge; //只导入某个方法
import 'lib/my/myMath.dart' hide getAge; //隐藏某个方法

//系统内置库
import 'dart:math';'dart:io'_'dart:convert';

//Pub包管理系统中的库
	1.项目根目录新建一个pubspec.yaml;
	2.配置名称描述，依赖信息;
	3.运行 pub get;
	4.项目中引入 import 看文档使用；
```

# Flutter

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget { //自定义组件 StatelessWidget
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(  //MaterialApp是一个widget 一般作为顶层widget ，
      // title: 'Flutter Demo',  
      theme: ThemeData(
        primarySwatch: Colors.red, //主题颜色
      ),
      // home: const MyHomePage(title: '测试'),
      home:Scaffold(
        appBar: AppBar(
          title: Text('测试'),
        ),
        body: Center(
          child: Text('xxx'),
        ),
      )
    );
  }
```

## 组件关键词

### Container盒子

```dart
alignment //对齐方式
    topCenter：顶部居中对齐
    topLeft：顶部左对齐
    topRight：顶部右对齐
    center：水平垂直居中对齐
    centerLeft：垂直居中水平居左对齐
    enterRight：垂直居中水平居右对齐
	bottomCenter 底部居中对齐
	bottomLeft：底部居左对齐
	bottomRight：底部居右对齐;
decoration //
    decoration: BoxDecoration(
		color: Colors.blue,
		border: Border.all(
		color: Colors.red,
		width: 2.0,
	),
	borderRadius:BorderRadius.all(
		Radius.circular(8.0)
	);
margin //外边距
    margin 属性是表示 Container 与外部其他组件的距离。
	EdgeInsets.all(20.0);
padding //内边距
     padding 就 是 Container 的内边距，指Container 边缘与 Child 之间的距离
	padding: EdgeInsets.all(10.0);
transform //旋转
     让 Container 容易进行一些旋转之类的
child //容器子元素
```

### Text文本

```dart
textAlign
    文本对齐方式（center 居中，left 左对齐，right 右对齐，justfy 两端对齐）;
textDirection
    文本方向（ltr 从左至右，rtl 从右至左）;
overflow
    文字超出屏幕之后的处理方式（clip裁剪，fade 渐隐，ellipsis 省略号）;
textScaleFactor
    字体显示倍率;
maxLines
    文字显示最大行数
style
    字体的样式设置
    
//TextStyle
TextStyle{
    decoration
        文字装饰线（none 没有线，lineThrough 删除线，overline 上划线，underline 下划线）;
    decorationColor
        文字装饰线颜色;
    decorationStyle
        文字装饰线风格（[dashed,dotted]虚线，double 两根线，solid 一根实线，wavy 波浪线）;
    wordSpacing
        单词间隙（如果是负值，会让单词变得更紧凑);
    letterSpacing
        字母间隙（如果是负值，会让字母变得更紧凑）;
    fontStyle
        文字样式（italic 斜体，normal 正常体）
	fontSize
        文字大小;
    color
        文字颜色;
    fontWeight
        字体粗细（bold 粗体，normal 正常体）
}
```

### Image图片

```dart
Image.asset，本地图片
Image.network远程图片
    
alignment Alignment 
    图片的对齐方式；
color和colorBlendMode 
    设置图片的背景颜色，通常和colorBlendMode配合一起使用，这样可以是图片颜色和背景色混合。上面的图片就是进行了颜色的混合，绿色背景和图片红色的混合
fit
    BoxFitfit
    	属性用来控制图片的拉伸和挤压，这都是根据父容器来的;
	BoxFit.fill:
		全图显示，图片会被拉伸，并充满父容器。
	BoxFit.contain:
		全图显示，显示原比例，可能会有空隙。
	BoxFit.cover：
    	显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。
	BoxFit.fitWidth：
        宽度充满（横向充满），显示可能拉伸，可能裁切。
	BoxFit.fitHeight：
        高度充满（竖向充满）,显示可能拉伸，可能裁切。
	BoxFit.scaleDown：
        效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。
repeat
    ImageRepeat.repeat:
		横向和纵向都进行重复，直到铺满整个画布。
	ImageRepeat.repeatX:
		横向重复，纵向不重复。
	ImageRepeat.repeatY：
         纵向重复，横向不重复。
width
        宽度一般结合ClipOval才能看到效果
height
        高度一般结合ClipOval才能看到效果
            
child:Image.network(
    "http://pic.baike.soso.com/p/20130828/201308281611371346445960.jpg",
    alignment:Alignment.topLeft,
    color:Colors.red,
    colorBlendMode:BlendMode.colorDodge,
    //repeat:ImageRepeat.repeatX,fit:BoxFit.cover,
),

//圆角图片child:ClipOval()

//引入本地图片
//1.新建images目录 2.0x 3.0x 4.0x
//2.修改pubspec.yaml 关键词：assets： -images/2.0x
```

### ListView 列表

```dart
scrollDirection
    Axis.horizontal水平列表 Axis.vertical垂直列表;
padding
    EdgeInsetsGeometry 内边距;
resolve
    bool 组件反向排序;
children
    List<Widget> 列表元素;

1、垂直列表
    ListTile(title:Text("thisislist"),subtitle:Text('thisislistthisislist'),)
2、垂直图文列表
3、水平列表
    Container(width:180.0,color:Colors.lightBlue,),
4、动态列表
    return ListView.builder(
    	itemCount:this.list.length,
    	itemBuilder:(context,index){
            //print(context);
            return ListTile(
                leading:Icon(Icons.phone),
                title:Text("${list[index]}"),
            );
        },
	);
5、矩阵式列表
	1、可以通过GridView.count实现网格布局
	2、通过GridView.builder实现网格布局
    scrollDirection
    	Axis 滚动方法
    padding
    	EdgeInsetsGeometry 内边距
    resolve
    	bool 组件反向排序
    crossAxisSpacing
    	double 水平子Widget之间间距
    mainAxisSpacing
    	double 垂直子Widget之间间距
    crossAxisCount
    	int 一行的Widget数量
    childAspectRatio
    	double 子Widget宽高比例
    children
    	<Widget>[]
    gridDelegate
    	SliverGridDelegateWithFixedCrossAxisCount（常用）SliverGridDelegateWithMaxCrossAxisExtent 控制布局主要用在GridView.builder里面
    
    Widget_getListData(context,index){
    	return Container(
            child:Column(
                children:<Widget>[
                    image.network(listData[index]["imageUrl"]),
                    SizedBox(height:12),
                    Text(listData[index]["title"],textAlign:TextAlign.center,style:TextStyle(fontSize:20)),
                ],
            )
    
   @overrideWidgetbuild(BuildContextcontext){//TODO:implementbuild
       return GridView.builder(
           itemCount:listData.length,
           gridDelegate:SliverGridDelegateWithFixedCrossAxisCount(//横轴元素个数
               crossAxisCount:2,//纵轴间距
               mainAxisSpacing:20.0,//横轴间距
               crossAxisSpacing:10.0,//子组件宽高长度比例
               childAspectRatio:1.0
               ),
           itemBuilder:this._getListData
      )
```

### Paddiing组件

```dart
padding
    padding值,EdgeInsetss设置填充的值;
child
    子组件
    
padding:EdgeInsets.fromLTRB(0,0,10,0),
```

### Row水平布局组件

```dart
mainAxisAlignment
	主轴的排序方式;
crossAxisAlignment
	次轴的排序方式;
children
    组件子元素
    
child:Row(
	crossAxisAlignment:CrossAxisAlignment.center,
	mainAxisAlignment:MainAxisAlignment.spaceEvenly,
    //crossAxisAlignment:CrossAxisAlignment.center,
    children:<Widget>[
        IconContainer(Icons.home,color:Colors.red),
    	IconContainer(Icons.search,color:Colors.blue),
        IconContainer(Icons.send,color:Colors.orange),
    ],),
```

### Column垂直布局组件

```dart
child:Column(
  crossAxisAlignment:CrossAxisAlignment.center,
    mainAxisAlignment:MainAxisAlignment.spaceEvenly,
    //crossAxisAlignment:CrossAxisAlignment.center,
    children:<Widget>[
        IconContainer(Icons.home,color:Colors.red),
        IconContainer(Icons.search,color:Colors.blue),
        IconContainer(Icons.send,color:Colors.orange),
    ],
```

### Expanded Flex布局

```dart
flex
	元素站整个父Row/Column的比例;
child
    
    child:Row(
        //crossAxisAlignment:CrossAxisAlignment.start,
        mainAxisAlignment:MainAxisAlignment.center,
        //crossAxisAlignment:CrossAxisAlignment.center,
        children:<Widget>[
            Expanded(
                flex:2,child:IconContainer(Icons.home)),
            SizedBox(width:10),
            Expanded(
                flex:3,child:IconContainer(Icons.search)),
            //SizedBox(width:10),
            //Expanded(child:IconContainer(Icons.send))
        ],
```

### Stack定位布局组件

```dart
Stack表示堆的意思，我们可以用Stack或者Stack结合Align或者Stack结合Positiond来实现页面的定位布局
alignment
    配置所有子元素的显示位置;
children
    
//StackAlign
    alignment
    	配置所有子元素的显示位置;
//StackPositioned
	top bottom left right
```

### AspectRatio调整比例组件

```dart
//AspectRatio的作用是根据设置调整子元素child的宽高比。
//AspectRatio首先会在布局限制条件允许的范围内尽可能的扩展，widget的高度是由宽度和比率决定的，类似于BoxFit中的contain，按照固定比率去尽量占满区域。如果在满足所有限制条件过后无法找到一个可行的尺寸，AspectRatio最终将会去优先适应布局限制条件，而忽略所设置的比率。
 
aspectRatio
    宽高比，最终可能不会根据这个值去布局，具体则要看综合因素，外层是否允许按照这种比率进行布局，这只是一个参考值;
child
    

```

### Card卡片组件

```dart
//Card是卡片组件块，内容可以由大多数类型的Widget构成，Card具有圆角和阴影，这让它看起来有立体感。
margin 外边距;
child 子组件;
Shape Card的阴影效果，默认的阴影效果为圆角的长方形边;
Card(
    margin:EdgeInsets.all(10),
    child:Column(
        children:<Widget>[
            ListTile(
                title:Text("李四",style:TextStyle(fontSize:28)),
                subtitle:Text("高级软件工程师"),
            ),
            Divider(),
            ListTile(
                title:Text("电话：1213214142"),),
            ListTile(
                title:Text("地址：北京市海淀区"))
        ],
    ),
```

### Card图文组件

```dart
return ListView(
children:listData.map((value){
return Card(
	margin:EdgeInsets.all(10),
	child:Column(
    	children:<Widget>[
        	AspectRatio(
            	aspectRatio:16/9,
            	child:Image.network(value["imageUrl"],fit:BoxFit.cover)
        	),
        	ListTile(
                title:Text(value["title"]),
            	subtitle:Text(value["description"],overflow:TextOverflow.ellipsis),
            	leading:CircleAvatar(
                	backgroundImage:NetworkImage(value["imageUrl"]))
        	)
    	],
	),
```

### 按钮组件

```dart
//RaisedButton：凸起的按钮，其实就是MaterialDesign风格的Button
//FlatButton：扁平化的按钮
//OutlineButton：线框按钮
//IconButton：图标按钮
//ButtonBar:按钮组
//FloatingActionButton:浮动按钮
```

```dart
onPressed
    VoidCallback，一般接收一个方法 必填参数，按下按钮时触发的回调，接收一个方法，传null表示按钮禁用，会显示禁用相关样式;
textColor
    Color 文本颜色;
color
    按钮的颜色;
disabledColor
    按钮禁用时的颜色;
disabledTextColor
    按钮禁用时的文本颜色;
splashColor
    点击按钮时水波纹的颜色;
highlightColor
    点击（长按）按钮后按钮的颜色;
elevation
    double 阴影的范围，值越大阴影范围越大;
padding
    内边距;
shape
    设置按钮的形状
    shape:RoundedRectangleBorder(
        borderRadius:
        BorderRadius.circular(10),
    );
	shape:CircleBorder(
        side:BorderSide(
            color:Colors.white,
        )
    )
```

#### RaisedButton定义一个按钮

```dart
return RaisedButton(
    child:Text('女装'),
    textColor:Theme.of(context).accentColor,
    onPressed:(){},
);

Flutter2.x以后新增了一些按钮组件 ElevatedButton替代RaisedButton;

Widgetbuild(BuildContextcontext){
    return ElevatedButton(
        child:Text(this.text),
        onPressed:(){});}
```



### Wrap流组件

```dart
Wrap可以实现流布局，单行的Wrap跟Row表现几乎一致，单列的Wrap则跟Row表现几乎一致。但Row与Column都是单行单列的，Wrap则突破了这个限制，mainAxis上空间不足时，则向crossAxis上去扩展显示。
    
direction
    主轴的方向，默认水平;
alignment
    主轴的对其方式;
spacing
    主轴方向上的间距;
textDirection
    文本方向;
verticalDirection
    定义了children摆放顺序，默认是down，见Flex相关属性介绍。
runAlignment
    run的对齐方式。run可以理解为新的行或者列，如果是水平方向布局的话，run可以理解为新的一行;
runSpacing
    run的间距;

return Wrap(
    spacing:10,
    runSpacing:10,
    alignment:WrapAlignment.spaceEvenly,
    children:<Widget>[
        MyButton("第1集"),
        MyButton("第2集"),
        MyButton("第3集"),
    ],
);
```

### 自定义有状态组件

```dart
//在Flutter中自定义组件其实就是一个类，这个类需要继承StatelessWidget/StatefulWidget

//StatelessWidget是无状态组件，状态不可变的widget
//StatefulWidget是有状态组件，持有的状态可能在widget生命周期改变。通俗的讲：如果我们想改变页面中的数据的话这个时候就需要用到StatefulWidget

class HomePage extends StatefulWidget{
    //Flutter2.2.0之后需要注意把Key改为可空类型{Key?key}表示key为可空类型
	HomePage({Key?key}):super(key:key);
    _HomePageStatecreateState()=>_HomePageState();
}
```

### BottomNavigationBar底部导航组件

```dart
items
    List<BottomNavigationBarItem>底部导航条按钮集合;
iconSize
    icon;
currentIndex
    默认选中第几个;
onTap
    选中变化回调函数;
fixedColor
    选中的颜色;
type
    BottomNavigationBarType.fixed
    BottomNavigationBarType.shifting;

Scaffold(
    appBar:AppBar(
        title:Text('FlutterDemo')
    ),
    body:this._pagesList[this._curentIndex],
    bottomNavigationBar:BottomNavigationBar(
        currentIndex:_curentIndex,
        onTap:_changePage,
        fixedColor:Colors.black,
        type:BottomNavigationBarType.fixed,
        items:[
            BottomNavigationBarItem(
                title:Text("首页"),
                icon:Icon(Icons.home)
            ),
            BottomNavigationBarItem(
                title:Text("分类"),
                icon:Icon(Icons.category)
            ),
            BottomNavigationBarItem(
                title:Text("设置"),
                icon:Icon(Icons.settings)
            ),
        ],
    ),
)
```

### 常用表单

```dart
//Flutter中常见的表单有TextField单行文本框，TextField多行文本框、CheckBox、Radio、SwitchCheckboxListTile、RadioListTile、SwitchListTile、Slide.
```

#### TextField文本框组件

```dart
maxLines
    设置此参数可以把文本框改为多行文本框;
onChanged
    文本框改变的时候触发的事件;
decoration
    hintText 类似html中的placeholder
    border配置文本框边框 OutlineInputBorder配合使用
    labelText  lable的名称
    labelStyle配置lable的样式;
obscureText
    把文本框框改为密码框;
controller
    controller结合TextEditingController()可以配置表单默认显示的内容
    
```

#### Checkbox**、**CheckboxListTile多选框组件

```dart
1.Checkbox常见属性：
	value
		true或者false;
	onChanged
	    改变的时候触发的事件;
	activeColor
	    选中的颜色、背景颜色;
	checkColor
	    选中的颜色、Checkbox里面对号的颜色;
2.CheckboxListTile常见属性：
    value
    	true或者false
    onChanged
    	改变的时候触发的事件;
	activeColor
        选中的颜色、背景颜色
    title
        标题
    subtitle
        二级标题
    secondary
        配置图标或者图片
    selected
        选中的时候文字颜色是否跟着改变
    
```

## Radio**、**RadioListTile单选按钮组件

```dart
1.Radio常用属性：
    value 
    	单选的值;
	onChanged
        改变时触发;
	activeColor
        选中的颜色、背景颜色
    groupValue
        选择组的值;

2.RadioListTile常用属性：
    title
    	标题
    subtitle
    	二级标题
    secondary
    	配置图标或者图片
```



## Flutter 路由

Flutter中的路由通俗的讲就是页面跳转。在Flutter中通过Navigator组件管理路由导航。并提供了管理堆栈的方法。如：Navigator.push和Navigator.pop

Flutter中给我们提供了两种配置路由跳转的方式：1、基本路由2、命名路由

### 基本路由使用

```dart
1、需要在HomPage中引入SearchPage.dart
    import'../SearchPage.dart';
2、在HomePage中通过下面方法跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
        	Navigator.of(context).push(
            	MaterialPageRoute(
                	builder:(BuildContextcontext){
                    	return SearchPage();
                	}
            	)
        	);
    	},
    color:Theme.of(context).accentColor,
    textTheme:ButtonTextTheme.primary
)
```

### 路由跳转传值

```dart
1、需要在HomPage中引入SearchPage.dart
    import'../SearchPage.dart';
2、在HomePage中通过下面方法跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
            Navigator.of(context).push(
                MaterialPageRoute(
                    builder:(BuildContextcontext){
                        return SearchPage(title:"表单");//传值
					}
                )
            );
        },
    	color:Theme.of(context).accentColor,
    	textTheme:ButtonTextTheme.primary
    )
```

### 命名路由

```dart
1、配置路由
	import'package:flutter/material.dart';
	import'pages/Tabs.dart';

	import'pages/Search.dart';
	import'pages/Form.dart';

	voidmain()=>runApp(MyApp());
classMyAppextendsStatelessWidget{
    @override
    Widgetbuild(BuildContextcontext){
        return MaterialApp(
            //home:Tabs(),
            initialRoute:'/',
            routes:{
                '/':(contxt)=>Tabs(),
                '/search':(contxt)=>SearchPage(),
                '/form':(context)=>FormPage(),
            },
        );
    }
}
2、路由跳转
    RaisedButton(
    	child:Text("跳转到搜索页面"),
    	onPressed:(){
            Navigator.pushNamed(context,'/search');
        },
```

### 命名路由跳转传值

```dart
官方文档：https://flutter.dev/docs/cookbook/navigation/navigate-with-arguments
1、配置路由：
	import'package:flutter/material.dart';import'pages/Tabs.dart';import'pages/Search.dart';import'pages/Form.dart';
	voidmain()=>runApp(MyApp());
	class MyApp extends StatelessWidget{
        final routes={
            '/':(contxt)=>Tabs(),
            '/search':(contxt)=>SearchPage(),
            '/form':(context,{arguments})=>FormPage(arguments:arguments),
        };
        @override
        Widgetbuild(BuildContextcontext){
            return MaterialApp(
                home:Tabs(),
                onGenerateRoute:(RouteSettingssettings){
                    //统一处理
                    final Stringname=settings.name;
                    final Function pageContentBuilder=this.routes[name];
                    if(pageContentBuilder!=null){
                        if(settings.arguments!=null){
                            finalRouteroute=MaterialPageRoute(
                                builder:(context)=>pageContentBuilder(context,
                                	arguments:settings.arguments));
                            return route;
                        }else{
                            final Route route=MaterialPageRoute(
                            	builder:(context)=>pageContentBuilder(context));
                            return route;
                            )
                        }
                    }
                });
        }
    }
2、跳转传值:
	RaisedButton(
    	child:Text("跳转到表单演示页面"),
        onPressed:(){
            Navigator.pushNamed(
                context,'/form',
                arguments:{"id":20});
        },
        color:Theme.of(context).accentColor,textTheme:ButtonTextTheme.primary
    );
3、接收参数:
	import'package:flutter/material.dart';
	class FormPage extends StatelessWidget{
        finalMaparguments;
        FormPage({this.arguments});
        @override
        Widget build(BuildContext context){
            return Scaffold(
                appBar:AppBar(title:Text("搜索"),
                ),
                body:Text("我是一个表单页面${arguments!=null?arguments['id']:'0'}")
       	);
```

### 命名路单独抽离到一个文件

```dart
import'package:flutter/material.dart';import'../pages/Tabs.dart';import'../pages/Search.dart';import'../pages/Form.dart';

finalMap<String,Function>routes={
    '/':(contxt,{arguments})=>Tabs(),
    '/search':(contxt,{arguments})=>SearchPage(arguments:arguments),
    '/form':(context,{arguments})=>FormPage(arguments:arguments),
};
varonGenerateRoute=(RouteSettingssettings){
    //统一处理
    finalStringname=settings.name;
    finalFunctionpageContentBuilder=routes[name];
    if(pageContentBuilder!=null){
        finalRouteroute=MaterialPageRoute(
            builder:(context)=>
            	pageContentBuilder(context,arguments:settings.arguments));
        return route;
    }
}
```

```dart
import'package:flutter/material.dart';import'routes/Routes.dart';voidmain()=>runApp(MyApp());

class MyApp extends StatelessWidget{
    @override
    Widget build(BuildContext context){
        return MaterialApp(
            //home:Tabs(),
            initialRoute:'/',
            onGenerateRoute:onGenerateRoute
            );
    }
}
```

### 回到上一级页面

```dart
Navigator.of(context).pop();
```

### 替换路由

```dart
比如我们从用户中心页面跳转到了registerFirst页面，然后从registerFirst页面通过
pushReplacementNamed跳转到了registerSecond页面。这个时候当我们点击registerSecond
的返回按钮的时候它会直接返回到用户中心
    
Navigator.of(context).pushReplacementNamed('/registerSecond');
```

### 返回到根路由

```dart
Navigator.of(context).pushAndRemoveUntil(
	new MaterialPageRoute(builder:(context)=>newTabs(index:1)),
	(route)=>route==null
};
```

## 布局

### Drawer侧边栏

```dart
//在Scaffold组件里面传入drawer参数可以定义左侧边栏，传入endDrawer可以定义右侧边栏。侧边栏默认是隐藏的，我们可以通过手指滑动显示侧边栏，也可以通过点击按钮显示侧边栏

return Scaffold(
    appBar:AppBar(
        title:Text("FlutterApp"),
    ),
    drawer:Drawer(
        child:Text('左侧边栏'),
    ),
    endDrawer:Drawer(
        child:Text('右侧侧边栏'),
    ),
);
```

#### DrawerHeader

#### UserAccountsDrawerHeader

#### Flutter侧边栏路由跳转

```dart
onTap:(){
    Navigator.of(context).pop();
    Navigator.pushNamed(context,'/search');
}
```

## Flutter2.2.0之后的一些变化

```dart
官方sdk地址：
https://flutter.dev/docs/development/tools/sdk/releases?tab=windows#windows

一、创建组件的变化：
    以前创建的StatefulWidget格式如下：
    class PayPage extends StatefulWidget{
    	PayPage({Key key}):super(key:key);
    	_PayPageStatecreateState()=>_PayPageState();
	}
	现在创建StatefulWidget的时候需要注意把Key配置成可空参数格式如下：
    class PayPage extends StatefulWidget{
        PayPage({Key? key}):super(key:key);
        _PayPageStatecreateState()=>_PayPageState();
    }
二、配置路由的变化
    1、需要指定路由的类型finalMap<String,Function>routes
    	finalMap<String,Function>routes={
    '/':(context)=>Tabs(),
    '/buttonPage':(context)=>ButtonDemoPage(),
    '/buttonExtend':(context)=>ButtonExtendDemoPage(),
    '/textField':(context)=>TextFieldDemoPage(),
    '/checkBox':(context)=>CheckBoxDemo(),
    '/radio':(context)=>RadioDemo(),};

	2、配置onGenerateRoute的时候注意可空类型
        
```

## 日期组件

```dart
//日期转化成时间戳：
varnow=newDateTime.now();
print(now.millisecondsSinceEpoch);//单位毫秒，13位时间戳

//时间戳转化成日期：
varnow=newDateTime.now();
vara=now.millisecondsSinceEpoch;//时间戳
print(DateTime.fromMillisecondsSinceEpoch(a));
```

#### 第三方库date_format的使用

```dart
date_format可以格式化日期文档：https://pub.dev/packages/date_format


```



# NuxtJS

官网：https://www.nuxt.com.cn/docs/getting-started/seo-meta

https://www.nuxtjs.cn/guide/views

博客：

https://blog.csdn.net/qq_34701838/article/details/114575276

https://blog.csdn.net/weixin_48143996/article/details/121918654-

## 动态设置页面SEO

```
 每个页面 data 同级
 head() {
      return {
        title: "我是标题",
        meta: [
          { charset: "utf-8" },
          { name: "viewport", content: "width=device-width, initial-scale=1" },
          { hid: "description", name: "description", content: "我是首页内容，这是描述" },
          { name: "renderer", content: "webkit" },
          // 更多标签...
        ],
        // 该页图标
        // link: [{ rel: "icon", type: "image/x-icon", href: "/favicon1.ico" }],
      }
    },
```



## 伪静态

nuxt.config.js 

```
router: {
    extendRoutes(routes, resolve) {
      // 清空系统路由(nuxt默认自动生成的路由是否清空掉)
      // routes.splice(0)
      routes.push(
        ...[
          {
            // 名称
            name: 'Index',
            // 正常情况下是这样写: /index
            // 伪静态就这样写: /index.html
            // 再或者离谱一些: /index.hahaha
            path: '/index.html',
            // 这块"__dirname"是固定写法,无需理会
            // 第二个参数是页面路径,很好理解
            component: resolve(__dirname, 'pages/index')
          },
          {
            name: 'Products',
            path: '/Products.html',
            component: resolve(__dirname, 'pages/AllProducts')
          }
        ]
      )
    }
  },
```

## 动态传参

```
router: {
  extendRoutes(routes, resolve) {
  
    // 清空系统路由(nuxt默认自动生成的路由是否清空掉)
    // routes.splice(0)
    
    // 扩展更多路由
    routes.push(
      ...[
        {
          // 名称
          name: 'Index',
          // 使用 ? 号来让其参数不必填,否则不写会报错(根据您的需求来)
          // 官方文档: https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html
          // ——————————————————————————————————————
          // 我定义了name/age/sex/hobby这几个参数,并且都是非必填的(填一半,或一个都不填都行)
          path: '/index/:name?/:age?/:sex?/:hobby?',
          // 这块"__dirname"是固定写法,无需理会
          // 第二个参数是页面路径,很好理解
          component: resolve(__dirname, 'pages/index')
        }
        // ...
      ]
    )
    
  }
}


<nuxt-link :to="{ name: 'Index', params: { name: '蔡徐坤', age: 15, sex: '男', hobby: '打篮球' } }">
    进入
</nuxt-link>

```



## 路由

```
<nuxt-link> nuxt.js中切换路由
<Nuxt /> nuxt.js的路由视图
<router-link> vue默认切换路由
<router-view/> vue默认路由视图
```

## 动态路由

```
<NuxtLink :to="'/aaaaaaa/1001'+index" v-for="(item,index) in 10">
```



## nuxt部署到服务器

```vue
宝塔：
1.下载pm2管理器
2.配置文件
	upstream nodenuxt {
    	server 127.0.0.1:3003; #nuxt项目 监听端口
    	keepalive 64;
	}
3.设置反向代理
	例：127.0.0.1:3003
4.package.json
	"scripts": {
    	"dev": "nuxt",
    	"build": "nuxt build",
    	"start": "PORT=3003 nuxt start",
    	"generate": "nuxt generate"
  	},
5.npm run build 打包应用
	打包完成后将以下四个文件上传到服务器空间
	.nuxt     //打包生成的文件夹
	static    //默认静态文件
	nuxt.config.js   //nuxt项目配置文件
	package.json   //配置文件
	plugins  //plugins目录视情况而定
6.宝塔 npm install  npm start
7.pm2 start npm --name "项目名称" -- run start 

tips：pm2 stop all // 停止所有的应用程序
pm2 stop 0 // 停止 id为 0的指定应用程序
```



# 代码库

## 瀑布流

```vue
column-count: 2;
column-gap: 15rpx;


uni.getImageInfo({
src: item.coverUrl,
success: e => {
	if (this.leftHeight + 80 <= this.rightHeight + 80) {
		this.newList_left.push(item)
		this.leftHeight += e.height
		console.log('zuo', this.leftHeight);
	} else {
		this.newList_right.push(item)
		this.rightHeight += e.height
		console.log('you', this.rightHeight);
	}

	}
})

@load="considerPush"
if (this.auto_newList.length == 0) return;
	let leftH = 0,
		rightH = 0;
	var query = uni.createSelectorQuery().in(this);
	query.selectAll('.leftbox').boundingClientRect()
	query.selectAll('.rightbox').boundingClientRect()
	query.exec(res => {
		leftH = res[0].length != 0 ? res[0][0].height : 0;
		rightH = res[1].length != 0 ? res[1][0].height : 0;
		if (leftH == rightH || leftH < rightH) {
			his.newList_left.push(this.auto_newList.shift());
		} else {
			this.newList_right.push(this.auto_newList.shift());
		}
});
```

## 前端截取第一帧

```vue

<template>
	<view class="content">
		// 逻辑层调用视图层方法，采用监听data中变量改变的方法
		<view id="canvas" class="canvas" :prop="newVal" :change:prop="canvas.create"></view>
		<button @click="choose">chooseVideo</button>

		<view class="img" :style="{backgroundImage:'url('+imgurl+')'}">

		</view>
	</view>
</template>

<!-- 逻辑层script -->
<script>
	export default {
		data() {
			return {
				newVal: null,
				imgurl: ''
			};
		},
		methods: {
			choose() {
			uni.chooseVideo({
					sourceType: ['camera', 'album'],
					success:  (blod)=>{
						// 获取视频信息，拿到宽高信息
						uni.getVideoInfo({
							src: blod.tempFilePath,
							success: (info) => {
								// 上传视频到网络地址，当然也可以使用本地地址。App、H5平台本人都测试过，都没问题！！！
								uni.uploadFile({
									url: 'http://替换成自己个上传文件接口/api/common/upload', //仅为示例，非真实的接口地址
									filePath: blod.tempFilePath,
									name: 'file',
									formData: {
										'token': uni.getStorageSync('userInfo').token
									},
									success: src => {
										// fullurl也可以使用本地地址，上传选择文件获取到的 => blod.tempFilePath
										this.newVal = {fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height}
										// 这里当时想做个平台区分，但是后面发现H5平台这种调用方式，视图层create接受参数的时候，只能接收到newValue，但是不能接收到event, ownerInstance，所以还是统一使用上方操作
										// 下方方法仅展示，调用还是统一使用上方操作
										// // #ifdef APP-PLUS
										// this.newVal = {fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height}
										// // #endif
										// // #ifdef H5
										// this.create({fullurl: JSON.parse(src.data).data.fullurl, width: info.width, height: info.height})
										// // #endif
									},
									complete: all => {
										console.log(JSON.parse(all.data))
									}
								})
							}
						})
					}
				})
			},
			getBase64(options) {
				this.imgurl = options.base64
			},
		}
	}
</script>


<script module="canvas" lang="renderjs">
	export default {
		methods: {
			// 视图层创建base64图片
			create(newValue, oldValue, ownerInstance) {
				// 第一次进入为空不操作
				if (newValue == null) {
					return
				}
				// 在缓存中创建video标签
				var video = document.createElement("VIDEO")
				video.autoplay = true
				// 该设置方法无效
				// video.setAttribute('autoplay', true)
				// 再添加一个静音的属性，否则自动播放会有声音
				// 该设置方法无效
				// video.setAttribute('muted', true)
				video.muted = true
				// 如果报错Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.
				// 可以把下面两行代码加上，因为我用的线上video url，所以可能抛出了异常。大概意思就是跨域了toDataURL()使用了外域资源
				video.setAttribute('crossOrigin', 'anonymous')
				video.crossOrigin = '*'
				// 上面我们只是创建了video标签，视频播放需要内部的source的标签，scr为播放源
				video.innerHTML = '<source src=' + newValue.fullurl + ' type="audio/mp4">'
				// 再创建canvas画布标签
				var canvas = document.createElement('canvas');
				var ctx = canvas.getContext('2d');
				// video注册canplay自动播放事件
				// 防止video不播放，所以手动加个播放操作
				video.play()
				// video播放事件
				video.addEventListener('canplay', () => {
					// 创建画布的宽高属性节点，就是图片的大小，单位PX
					var anw = document.createAttribute("width");
					anw.nodeValue = newValue.width;
					var anh = document.createAttribute("height");
					anh.nodeValue = newValue.height;
					canvas.setAttributeNode(anw);
					canvas.setAttributeNode(anh);
					// 画布渲染
					ctx.drawImage(video, 0, 0, newValue.width, newValue.height);
					// 生成base64图片，指定type为jpeg格式生成的图片base64编码会小很多
					var base64 = canvas.toDataURL('image/jpeg') // 这就是封面图片的base64编码
					// 传递数据给逻辑层
					console.log('base64', base64);
					ownerInstance.callMethod('getBase64', {
						base64: base64
					})
					// 删除创建的video 、canvas dom，要不然重新选取视频生成图片不生效
					// ps：开始有这个问题，但是后面不知道为什么又没有了，如果发现生成第一次base64之后再选择不生效，可以尝试一下把下方注释打开
					// document.body.removeChild(video)
					// document.body.removeChild(canvas)
				})
			}
		}
	}
</script>

<style>
	.img {
		width: 200px;
		height: 200px;
		background-repeat: no-repeat;
		background-position: 50% 50%;
		background-size: cover;
	}
</style>

```



# Canvas

### Canvas - 路径

#### 线

```
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
//moveTo(x,y) 定义线条开始坐标
ctx.moveTo(0,0);
//lineTo(x,y) 定义线条结束坐标
ctx.lineTo(200,100);
//使用 stroke() 方法来绘制线条:
ctx.stroke();
```

圆

```
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
//beginPath() 方法开始一条路径，或重置当前的路径。
ctx.beginPath();
ctx.arc(95,50,40,0,2*Math.PI);
ctx.stroke();
```

#### 文本

```
fillText():实心文本 strokeText():空心文本
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
ctx.font="30px Arial";
ctx.fillText("Hello World",10,50);
```

####  图像

```
var c=document.getElementById("myCanvas");
var ctx=c.getContext("2d");
var img=document.getElementById("scream");
ctx.drawImage(img,10,10);
```



```

```

# vite+vue3+ts

创建项目 

```
npm create vite@latest 
npm install
npm run dev
```

## routes

```
name：路由规则的名字。可以用于编程式导航和组件内部的路由跳转。
path：路由的路径，可以包含动态参数和正则表达式。例如，/user/:id 表示用户页面，:id 是一个动态参数。
redirect：路由的重定向规则。例如，{ path: '/', redirect: '/home' } 表示路由根路径的重定向。
component：路由对应的组件。可以是一个普通的组件类或异步加载的组件。
children：当前路由的子路由。可以是一个路由规则数组，也可以是一个函数，动态生成路由规则。
meta：路由的元信息，用于描述路由的一些额外信息。例如，路由是否需要登录、权限鉴定等。
components：路由对应的多个命名视图组件
```

### 路由跳转

```
<router-link to="/list">List</router-link>

import { useRouter } from 'vue-router'
const router = useRouter()
const gotoAbout = () => {
  router.push('/about')
}

// 字符串路径
router.push('/users/eduardo')

// 带有路径的对象
router.push({ path: '/users/eduardo' })

// 命名的路由，并加上参数，让路由建立 url
router.push({ name: 'user', params: { username: 'eduardo' } })

// 带查询参数，结果是 /register?plan=private
router.push({ path: '/register', query: { plan: 'private' } })

// 带 hash，结果是 /about#team
router.push({ path: '/about', hash: '#team' })
```

### 路由传参

```
通过路由路径传递参数：在路由配置中使用动态路由匹配（Dynamic Route Matching），例如：
const routes= [
    {
      path: '/detail/:id',
      name: 'Detail',
      component: Detail
    }
  ]

动态路由
动态路由是指将一个路由的一部分作为参数来构建的路由。例如，如果我们要为每个用户创建一个单独的页面，我们可以使用动态路由，创建一个路径为/users/:userId的路由，其中:userId是一个参数。
{
  path: '/users/:userId',
  name: 'user',
  component: User
}
import { useRouter, useRoute } from 'vue-router'
const route = useRoute()
console.log(route.params.userId)

```

## pinia

```

ref() 就是 state 属性
computed() 就是 getters
function() 就是 actions

import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'
const store = useCounterStore()
const { name, doubleCount } = storeToRefs(store)
-------------------------------------------------------

import { useUsersStore } from "../src/store/user";
const store = useUsersStore();
const { name, age, sex } = store;

//响应式
import { storeToRefs } from 'pinia';
const { name, age, sex } = storeToRefs(store);

//重置state
store.$reset();

//批量更改state数据
const patchStore = () => {
  store.$patch({
    name: "张三",
    age: 100,
    sex: "女",
  });
};

store.$patch((state) => {
  state.items.push({ name: 'shoes', quantity: 1 })
  state.hasChanged = true
})

//getters计算属性
getters: {
   getAddAge: (state) => {
     return state.age + 100;
   },
   getNameAndAge(): string {
     return this.name + this.getAddAge; // 调用其它getter
   },
   getAddAges: (state) => {
     return (num: number) => state.age + num;
   },
},

{{ store.getAddAge }}
<p>新年龄：{{ store.getAddAge(1100) }}</p>


//actions属性
//this指向的是当前store
actions: {
  saveName(name: string) {
    this.name = name;
  },
},
store.saveName("我是小猪");
```

## i18

```
https://blog.csdn.net/weixin_44784401/article/details/126939224


<template>
  <div>
    <a-button @click="switchClick('zhCN')">中文</a-button>
    <a-button @click="switchClick('en')">英文</a-button>
    <p>姓名：{{ $t("messages.name") }}</p>
    <p>年龄：{{ $t("messages.age") }}</p>
    <p>性别：{{ $t("messages.sex") }}</p>
    <p>地址：{{ $t("messages.address") }}</p>
  </div>
</template>

<script setup>
import { useI18n } from "vue-i18n";
const { locale } = useI18n();
function switchClick(lang) {
  locale.value = lang;
  localStorage.setItem("lang", lang);
}
</script>

<style></style>

1.template中
<p>姓名：{{ $t("messages.name") }}</p>
2.template的引号中
<a-input type="text" :placeholder="$t('messages.name')" />
3.script中
import { useI18n } from "vue-i18n";
const { t } = useI18n();
console.log(t("messages.name"));
```



# Three.js

##  支持的三维文件格式列表：

```
1. OBJ (Wavefront)
2. STL (Stereolithography)
3. 3MF (3D Manufacturing Format)
4. AMF (Additive Manufacturing File Format)
5. FBX (Filmbox)
6. PLY (Polygon File Format)
7. GLTF/GLB (GL Transmission Format/Binary)
8. X3D (XML-based 3D model format)
9. Collada (Digital Asset Exchange)
10. DXF (AutoCAD Drawing Exchange Format)
11. JSON (JavaScript Object Notation)
此外，three.js 工具*Assimp2Json*可以将更多的三维文件格式转化为 JSON 格式，比如 3DS、OBJ、FBX、Collada、GLTF 等。
```

## 添加：渲染器(WebGLRenderer)

let renderer = new THREE.WebGLRenderer({ antialias: true });

```
.autoClear 定义渲染器是否在渲染每一帧之前自动清除其输出。
.autoClearColor 定义渲染器是否需要清除颜色缓存。默认为true。
.autoClearDepth 定义渲染器是否清除深度缓存。 默认是true。
.autoClearStencil 定义渲染器是否需要清除模板缓存。默认为true。
.domElement 返回画布节点。当配置参数没关联canvas，会自动创建一个新的画布节点，需要手动放入html中。
.shadowMap 是一个对象。当我们需要阴影时就需要开启它。
.shadowMap.enabled 是否允许在场景中使用阴影贴图，默认false。
.shadowMap.autoUpdate 是否启动场景中的阴影自动更新，默认是true。
.shadowMap.type 值是Integer类型，定义阴影贴图类型。可选值有THREE.BasicShadowMap, THREE.PCFShadowMap (默认), THREE.PCFSoftShadowMap 和 THREE.VSMShadowMap THREE全局常量值，代表不同的数字。

有了参数和属性的控制就还有方法的控制。常用方法：
.clear(color:Boolean, depth:Boolean, stencil:Boolean ) 渲染器清除颜色、深度或模板缓存。
.getContext() 返回WebGL上下。
.render()(scene,camera) 传入场景和相机，在画布上渲染图片。
.setClearColor(color,alpha) 设置背景颜色和透明度。
.setSize()( width,height) 修改canvas节点的宽高。

总结
渲染器(WebGLRenderer) 简单理解就是，把我们绘制的场景图，通过相机视椎体的范围来截取，转化为一张图片。然后去绑定页面上canvas元素把这张图片绘制到元素上。动画效果就是不断的生成新的图片替换原来的图片来实现的。渲染器上有很多属性和方法，都是配合其他内容一起使用的，比如阴影就需要灯光和几何体来配合才能展示。
```

### OrbitControls 轨道控制器

## 添加

### 添加坐标系

```
const ases = new AxesHelper(40);
scene.add(ases);
```

### OrbitControls 轨道控制器/相机

通过`OrbitControls`可以对三维场景进行缩放、平移、旋转，本质上改变的不是场景，而是相机的参数，相机的位置角度不同，同一个场景的渲染效果是不一样，比如相机围绕着一个场景旋转，就像场景旋转一样
调用`OrbitControls`时需要引入`OrbitControls.js`文件

import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

#### 旋转缩放平移

```
controls = new OrbitControls(camera, renderer.domElement)
controls.enablePan =false;  // 禁止右键拖拽
controls.enableZoom =false; // 禁止缩放 默认true
controls.enableRotate =false; // 禁止旋转
```

#### **设置缩放范围**

在实际应用中，想控制一个产品缩放范围, 可以通过相机空间OrbitControls的.minZoom和.maxZoom属性实现

```
controls.minZoom = 0.5;
controls.maxZoom = 2;
```

#### **设置旋转范围**

展示一个三维场景，控制360度旋转范围，比如一辆轿车，不希望用户看到轿车的底盘，你可以通过设置相机的旋转范围属性来实现。
通过.minPolarAngle和.maxPolarAngle属性控制上下360度的旋转范围
通过.minAzimuthAngle和.maxAzimuthAngle属性控制左右360度的旋转范围
上下左右两个360度旋转也就是常说的720旋转展示。

// 上下旋转范围

```
controls.minPolarAngle =0;
controls.maxPolarAngle =Math.PI;
```

// 左右旋转范围

```
controls.minAzimuthAngle = -Math.PI * (100/180);
controls.maxAzimuthAngle =Math.PI * (100/180);
```

#### **属性介绍**

|      属性       |  类型   |                    默认值                     |                             描述                             |
| :-------------: | :-----: | :-------------------------------------------: | :----------------------------------------------------------: |
|   autoRotate    | Boolean |                     false                     | 设定为true时， 相机自动围绕目标旋转但必须在animation中循环调用update() |
|  enableDamping  | Boolean |                     false                     | 设置为true则启用阻尼(惯性),用来给控制相机一个重量，必须调用update()在你的animation循环中 |
|  dampingFactor  |  Float  |                                               | enableDamping为true时使用阻尼惯性(可理解为阻止向一个方向移动) |
|     enabled     | Boolean |                     true                      |                         是否启用控件                         |
|   enableKeys    | Boolean |                     true                      |          能否用键盘控制，←-↑-→↓四个键控制物体的移动          |
|      keys       |         | 四个箭头键{LEFT: 37,UP: 38,RIGHT: 39,DOWM:40} |                  Object控制相机平移的四个键                  |
|    enablePan    | Boolean |                     true                      |                           相机平移                           |
|    panSpeed     |  Float  |                       1                       |                          移动的速度                          |
|   keyPanSpeed   |  Float  |        每按一次控制方向键移动7 .0像素         |                        相机平移的速度                        |
| maxAzimuthAngle |  Float  |                   Infinity                    |         水平旋转，范围-Math.PI~Math.PI 或者Infinity          |
| minAzimuthAngle |  Float  |                    Math.Pl                    |                    垂直旋转,范围0~Math.PI                    |
|  maxPolarAngle  |  Float  |                   -Infinity                   |         水平旋转，范围-Math.PI~Math.PI 或者-Infinity         |
|  minPolarAngle  |  Float  |                       0                       |                   垂直旋转，范围0~Math.PI                    |
|   maxDistance   |  Float  |                   Infinity                    |             拉远镜头(只能用在PerspectiveCamera)              |
|   minDistance   |  Float  |                       0                       |                           拉近镜头                           |
|     maxZoom     |  Float  |                   Infinity                    |            拉远镜头(只能用在Othorg[ aphicCamera)             |
|     minZoom     |  Float  |                       Q                       |                           拉近镜头                           |
|    zoomSpeed    |  Float  |                       1                       |                       zoom(变焦)的速度                       |

#### **方法介绍**

|      **方法**       |                           **描述**                           |
| :-----------------: | :----------------------------------------------------------: |
|      dispose()      |                    null移除所有的事件监听                    |
| getAzimuthalAngle() |           radians获得用弧度表示的当前水平旋转角度            |
|   getPolarAngle()   |           radians获得用弧度表示的当前垂直旋转角度            |
|       reset()       | null通过最近1次调用saveState()或者 初始状态来重置为当前的状态 |
|     saveState()     |       null保存当前控制的状态,可以稍后通过reset()来恢复       |
|      update()       | false更新控件,在手动改变了摄像机的钻换后必须调用。在设置了autoRotate或enableDamping时也要在循环中调用 |

```
//重置webGL的颜色
const renderer = new WebGLRenderer();
renderer.setClearColor(new Color(0xeeeeee));
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new OrbitControls(camera, renderer.domElement);
const sphereGeometry = new SphereGeometry(4);
const sphereMaterial = new MeshBasicMaterial({
  color: 0x7777ff,
  wireframe: true,
});
```

### 光

#### DirectionalLight-方向光

方向光发出的所有光线都是平行的，可以认为是距离很远的光源，例如遥远的太阳光就是方向光，方向光不像聚焦光那样距离目标越远越暗淡，被方向光照射的整个区域收到的光照强度都一样

##### 创建方向光

创建一个简单的方向光，通过`new THREE.DirectionalLight(color)`语句就可以创建一个指定颜色的方向光，然后将它添加到场景中就可以了

```
var directionalLight = new THREE.DirectionalLight(0x0c0c0c) // 创建方向光
scene.add(directionalLight ) // 将方向光添加到场景
```

##### 属性介绍

|                     属性                      |                             描述                             |
| :-------------------------------------------: | :----------------------------------------------------------: |
|                  颜色-color                   | color属性继承自基类Light，color属性的类型是Color，所以color属性的值需要通过颜色对象THREE.Color()来创建 |
|               是否可见-visible                | visible属性继承自基类Object3D，使用很简单，该属性时布尔类型，取值true或false |
|                强度-intensity                 | intensity属性是用来设置聚光灯的强度，默认值是1，如果设置成0那什么也看不到，该值越大，点光源看起来越亮 |
|                  目标-target                  |       target属性用来决定光照的方向，一般会指向一个对象       |
|                 位置-position                 | position属性表示光源的发光位置，该属性继承自基类Object3D，positon属性的类是Vector3 |
|            是否产生阴影-castShadow            | castShadow属性是用来控制光源是否产生阴影，取值为true或false  |
|          投影远点-shadow.camera.far           |            表示到距离光源的哪一个位置可以生成阴影            |
|          投影近点-shadow.camera.near          |             表示距离光源的哪一个位置开始生成阴影             |
|         投影上边界-shadow.camera.top          |                                                              |
|        投影下边界-shadow.camera.bottom        |                                                              |
|         投影左边界-shadow.camera.left         |                                                              |
|        投影右边界-shadow.camera.right         |                                                              |
| shadow.mapSize.width 和 shadow.mapSize.height | 阴影映射宽度和阴影映射高度。决定了有多少像素用来生成阴影。当阴影具有锯齿状边缘或看起来不光滑时，可以增加这个值。在场景渲染之后无法更改，默认值都为512 |



------



#### AmbientLight-环境光

##### 环境光介绍

环境光在three.js中是一种基础光，它的颜色会影响到整个场景中的所有对象，就像太阳光会照射到地球上任何一个迎光的地方，一般情况下它不是场景中唯一的光源而是和其他光源配合使用

##### 创建环境光

创建环境光非常简单，由于环境光不需要指定位置，因此只需要使用
`new THREE.AmbientLight(color)` 就可以创建指定颜色的环境光，然后将它添加到场景中就可以了

```
var ambientLight = new THREE.AmbientLight(0x0c0c0c) // 创建环境光
 scene.add(ambientLight) // 将环境光添加到场景
```

##### 修改环境光颜色

修改环境光颜色实际上修改的是AmbientLight对象的color属性，该属性继承自基类Light，color属性的类型是Color，所以color属性的值需要通过颜色对象THREE.Color()来创建，具体操作如下示例

```
var ambientLight = new THREE.AmbientLight(0x0c0c0c) // 创建环境光
var color = new THREE.Color(0x26E250) //创建颜色对象color
ambientLight.color = color // 给环境光修改颜色
```

##### 控制是否显示环境光

```
this.ambientLight.visible = true //显示环境光
this.ambientLight.visible = false //不显示环境光
```



------



#### PointLight-点光源

点光源是一种单点发光，照射所有方向的光源，它的发光效果类似于夜空中发射的照明弹，在点光源的照射下，物体的迎光面会亮一些，背光面会暗一些
附：点光源的照射下物体没有产生阴影，是因为点光源会朝所有方向发射光线，这种情况下计算阴影对计算机GPU的负担太过沉重

##### 创建点光源

```
var pointLight = new THREE.PointLight(0x0c0c0c) // 创建点光源
scene.add(pointLight) // 将点光源添加到场景
```

##### 属性介绍

|       属性       |                             描述                             |
| :--------------: | :----------------------------------------------------------: |
|    颜色-color    |         pointLight.color = new THREE.Color(0x26E250)         |
| 是否可见-visible | visible属性继承自基类Object3D，使用很简单，该属性时布尔类型，取值true或false |
|  强度-intensity  |                   pointLight.intensity = 2                   |
|  距离-distance   |   pointLight.distance = 4 距离超过4将看不到点光源发出的光    |
|  位置-position   |   pointLight.position.x = x,pointLight.position.set(x,y,z)   |



------



### 监听窗口变化

```
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.render(scene, camera);
});
```

### 包围盒

```
   let Mesh = gltf.scene.getObjectByName("package_01")
  let geomtry = Mesh.geometry
 // 计算包围盒
  geomtry.computeBoundingBox();
  // 设置几何体居中
  geomtry.center()
  // 获取包围盒
  let box = geomtry.boundingBox;
  // 更新世界矩阵
  Mesh.updateMatrixWorld(true,true);
  // 更新包围盒
  box.applyMatrix4(Mesh.matrixWorld);
  // 获取包围盒中心点
  let center = box.getCenter(new THREE.Vector3());
  // box.scale.set(0.25, 0.25, 0.25);
  // box.position.set(-25, 0, -5);
  // 创建包围盒
  let boxMesh = new THREE.Box3Helper(box, 0xff0000);
  
  scene.add(boxMesh);
```



## 动画

### tween补间动画

```
 // 导入tween
import * as TWEEN  from "three/examples/jsm/libs/tween.module.js";
const tween = new TWEEN.Tween(gltf.scene.position)
      // 无限播放repeat(Infinity)
      // 往复动画yoyo(true)
      // 延迟运行delay(1000)
      // 设置缓动函数tween.easing(TWEEN.Easing.Quadratic.InOut)
      // onStart开始 onComplete结束 onStop停止 onUpdate更新 tween.stop(
tween.to({x: 10}, 2000)
      // tween.repeat(Infinity)
      // tween.yoyo(true)
      // tween.easing(TWEEN.Easing.Quadratic.InOut)


const tween2 = new TWEEN.Tween(gltf.scene.position)
tween2.to({y: -10}, 2000)
tween.chain(tween2)

tween.start()

animate(){
  //更新tween
  TWEEN.update();
}
```

## GUI：右上控制区

```
let eventObj = {
  Full: () => {
    document.body.requestFullscreen();
  },
  Color: "#1f1f1f",
};
const gui = new dat.GUI();
const folder = gui.addFolder("测试控制");
folder.add(eventObj, "Full").name("全屏");
folder
  .add(sphere.position, "x", -50, 50)
  .name("position_x")
  .onChange((val) => {
    console.log(val);
  })
  .onFinishChange((val) => {
    console.log(val);
  });
folder
  .addColor(eventObj, "Color")
  .name("颜色")
  .onChange((val) => {
    sphere.material.color.set(val);
  });
```



## 监听窗口变化 修改three视口

```
window.addEventListener("resize", () => {
 camera.aspect = window.innerWidth / window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth, window.innerHeight);
 renderer.render(scene, camera);
});
```

## 鼠标模型交互

```
// 创建射线
const raycaster = new Raycaster();
// 创建鼠标向量
const mouse = new Vector2()
// 监听点击事件
window.addEventListener("click", (event) => {
  console.log(event.clientX, event.clientY);
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // 通过摄像机和鼠标向量，获取射线
  raycaster.setFromCamera(mouse, camera);
  //计算物体和射线的焦点
  const intersects = raycaster.intersectObjects(scene.children);
  console.log(intersects);
  if (intersects.length > 0) {
    intersects[0].object.material.color.set(0xff0000);
  }
})
```

## uv坐标

```
const uv = new Float32Array([0,0,1,0,1,1,0,1]);
geometry.setAttribute("uv",new THREE.BufferAttribute(uv,2))
```

## 法向向量

```
//计算
geometry.computeVertexNormals()
```

## 添加模型

### gltf

```
import {GLTF, GLTFLoader} from "three/examples/jsm/loaders/GLTFLoader";
import Plane from "../assets/plane/plane.gltf?url";

// 添加模型
const loaderPlane = new GLTFLoader(undefined);
let Plane_mo: any = null

loaderPlane.load(
    Plane,
    // 加载完成后的回调函数
    function (gltf) {
      // 当模型加载完成后会调用该函数
      // 将模型添加到场景中、
      scene.add(gltf.scene);
      Plane_mo = gltf.scene
      gltf.scene.scale.set(3, 3, 3);
      gltf.scene.position.set(0, 0, 0)
    },

    // 正在加载模型时的回调函数
    function (xhr) {
      // 进度条代码，可以在此编写代码，传入 xhr.loaded 和 xhr.total，计算出加载进度
    },
    // 加载出错的回调函数
    function (err) {
      console.error('An error happened.');
    }
);
```

### gbl

```

import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';
const dracoLoader = new DRACOLoader();
const loader = new GLTFLoader()
dracoLoader.setDecoderPath( './draco/' )
loader.setDRACOLoader( dracoLoader );
loader.load( '/bolsa.glb', function ( gltf ) {
  gltf.scene.scale.set(0.1, 0.1, 0.1)
  gltf.scene.position.set(-20, 0, 0)
  scene.add( gltf.scene );  //添加到场景
});
```



## 环境贴图

```
// 导入hdr加载器
import {RGBELoader} from "three/examples/jsm/loaders/RGBELoader.js";

let rgbeLoader = new RGBELoader();
rgbeLoader.load("../src/assets/Alex_Hart-Nature_Lab_Bones_2k.hdr", (envMap) => {
  // 设置球形贴图
  envMap.mapping = EquirectangularReflectionMapping;
  // 设置环境贴图
  scene.background = envMap;
  // 设置环境贴图
  scene.environment = envMap;
});
```

## 灯光与阴影

```
1.材质满足能够对光照有反应
2.设置渲染器开启阴影计算 render.shadowMap.enabled = true
3.设置光照投射阴影 directionalLight.castShadow = true
4.设置物体投射阴影 sphere.castShadow = true
5.设置物体接收阴影 planereceiveShadow = true

//设置阴影贴图模糊度
directionalLight.shadow.radius = 20;
//设置阴影贴图的分辨率
directionalLight.shadow.mapSize.set(4096,4096)
```

## 案例

```
<template>
	<div class="box">
		<div ref="canvasContainer"></div>
	</div>
</template>

<script setup>
	import {
		ref,
		onMounted
	} from 'vue';
	import * as THREE from 'three';
	import {
		OrbitControls
	} from 'three/examples/jsm/controls/OrbitControls';

	// 创建场景、相机和渲染器
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera(75, 680 / 680, 0.1, 1000);
	const renderer = new THREE.WebGLRenderer({
		alpha: true
	});

	renderer.setSize(680, 680);

	// 添加光源
	const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
	scene.add(ambientLight);

	const pointLight = new THREE.PointLight(0xffffff, 1);
	pointLight.position.set(50, 50, 50);
	scene.add(pointLight);

	// 创建轨道控制器
	// const controls = new OrbitControls(camera, renderer.domElement);
	// controls.enableDamping = true;
	// controls.dampingFactor = 0.25;
	// controls.enablePan = false; // 禁用平移
	// controls.enableZoom = false; // 禁用缩放

	// 创建球体几何体
	const radius = 20;
	const widthSegments = 84; // 增加密度
	const heightSegments = 84; // 增加密度
	const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);

	// 创建着色器材料 0x47cbfc 0xf4c806
	const shaderMaterial = new THREE.ShaderMaterial({
		uniforms: {
			color1: {
				value: new THREE.Color(0x1b4d9e)
			},
			color2: {
				value: new THREE.Color(0xfbfbfb)
			},
			time: {
				value: 0
			},
			mode: {
				value: 1
			}, // 初始模式设置为随机模式
			transition: {
				value: 0
			}, // 过渡值
			direction: {
				value: 1
			} // 1 表示从 0 到 1，-1 表示从 1 到 0
		},
		vertexShader: `
    varying vec3 vPosition;
    uniform float time;
    uniform float transition;
    uniform int mode;
    uniform int direction;
    void main() {
      vPosition = position;
      vec3 transformed = position;
      float waveHeight = sin(position.y * 2.0 + time) * 3.0; // 随机波浪高度
      float waveWidth = sin(position.x * 2.0 + time) * 3.0; // 随机波浪宽度
      float scale = 1.0 + 0.3 * sin(time + position.x * 10.0) * sin(time + position.y * 10.0) * sin(time + position.z * 10.0);

      // 平滑过渡两种模式
      transformed.z += mix(waveHeight, (scale - 1.0) * position.z, transition);
      transformed.x *= mix(1.0, scale, transition);
      transformed.y *= mix(1.0, scale, transition);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1);
    }
  `,
		fragmentShader: `
    varying vec3 vPosition;
    uniform vec3 color1;
    uniform vec3 color2;
    void main() {
      float mixValue = (vPosition.x + 20.0) / 40.0; // 修改渐变比例，颜色从左往右渐变
      mixValue = clamp(mixValue, 0.0, 1.0); // 限制混合值范围
      gl_FragColor = vec4(mix(color1, color2, mixValue), 0.95);
    }
  `,
		wireframe: true,
	});

	// 创建球体网格
	const sphereMesh = new THREE.Mesh(sphereGeometry, shaderMaterial);
	sphereMesh.position.y = 5
	sphereMesh.rotation.y = 4.5
	scene.add(sphereMesh);

	// 设置相机位置
	camera.position.z = 55;

	// 创建射线投射器和鼠标向量
	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();
	let mouseOver = false;
	let modeSwitching = false;

	const onMouseMove = (event) => {
		const container = canvasContainer.value;
		const rect = container.getBoundingClientRect();
		mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
		mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
	};

	const switchMode = (targetMode) => {
		if (modeSwitching) return;
		modeSwitching = true;
		const duration = 2.0; // 过渡持续时间
		let startTime = Date.now();
		let initialTransition = shaderMaterial.uniforms.transition.value;
		let targetTransition = initialTransition === 0 ? 1 : 0;

		function transition() {
			let elapsed = (Date.now() - startTime) / 1000.0;
			if (elapsed >= duration) {
				shaderMaterial.uniforms.transition.value = targetTransition;
				if (targetTransition === 1) {
					shaderMaterial.uniforms.mode.value = targetMode;
				}
				modeSwitching = false;
			} else {
				shaderMaterial.uniforms.transition.value = initialTransition + (elapsed / duration) * (
					targetTransition - initialTransition);
				requestAnimationFrame(transition);
			}
		}

		transition();
	};

	// 将渲染器添加到页面中
	const canvasContainer = ref(null);

	onMounted(() => {
		const container = canvasContainer.value;
		container.appendChild(renderer.domElement);
		container.addEventListener('mousemove', onMouseMove);
	});

	// 渲染场景
	const animate = function() {
		requestAnimationFrame(animate);
		// controls.update();

		// 更新着色器的时间变量
		shaderMaterial.uniforms.time.value += 0.01; // 增加时间步长

		// 射线投射检测
		raycaster.setFromCamera(mouse, camera);
		const intersects = raycaster.intersectObject(sphereMesh);

		if (intersects.length > 0) {
			if (!mouseOver) {
				mouseOver = true;
				switchMode(0); // 切换到波浪模式
			}
		} else {
			if (mouseOver) {
				mouseOver = false;
				switchMode(1); // 切换到随机模式
			}
		}

		// 整体缓慢旋转
		sphereMesh.rotation.y += 0.001;
		sphereMesh.rotation.x += 0.001;

		renderer.render(scene, camera);
	};
	animate();
</script>

<style lang="scss" scoped>
	.box {
		width: 100%;
		height: 100%;
		position: relative;
		z-index: 50;
		overflow: hidden;
	}
</style>
```



# go

```

```

# python

运行命令 uvicorn main:app --reload

## sqlalchemy（数据库操作）

```
查询
query.filter() 过滤
query.filter_by() 根据关键字过滤
query.all() 返回列表
query.first() 返回第一个元素
query.one() 有且只有一个元素时才正确返回
query.one_or_none()，类似one，但如果没有找到结果，则不会引发错误
query.scalar()，调用one方法，并在成功时返回行的第一列
query.count() 计数
query.order_by() 排序
```



## 虚拟环境

```
1.创建虚拟环境
python -m venv venv
2. 激活虚拟环境
Windows:
	venv\Scripts\activate
macOS 和 Linux:
	source venv/bin/activate
```



## fastAPI

```python
from typing import Union

from fastapi import FastAPI, Response
from starlette.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

app = FastAPI()
origins = [
    "*"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}


@app.get("/loginVIEW", response_class=HTMLResponse)
async def read_item():
    return open('./login.html', 'r', encoding='utf-8').read()


class User(BaseModel):
    username: str
    password: str


@app.post("/login")
async def login(user: User):
    with open('User.json', 'r') as file:
        # 读取文件内容
        content = file.read()
        a = eval(content)
    type = 'true'
    for e in a["list"]:
        if e['username'] == user.username:
            type = 'false'
            if e['password'] == user.password:
                return {"code": '00000', "msg": '登录成功'}
            else:
                return {"code": '00000', "msg": '密码错误'}
    if type:
        return {"code": '00000', "msg": '用户不存在'}


class PasswordTool():
    # 密码工具类
    def __init__(self, password):
        self.password = password
        self.strength_level = 0
        self.msg = ''

    def check_number_exist(self):
        """
          判断是否含数字
        """
        has_number = False
        for c in self.password:
            if c.isnumeric():
                has_number = True
                break
        return has_number

    def check_letter_exist(self):
        """
          判断是否含字母
        """
        has_upper_letter = False
        has_lower_letter = False
        for c in self.password:
            if c.isupper():
                has_upper_letter = True
            elif c.islower():
                has_lower_letter = True
            has_both_letter = has_upper_letter and has_lower_letter
            if has_both_letter:
                break
        return has_both_letter

    def check_specialchar_exist(self):
        """
          判断是否包含特殊字符
        """
        has_specialchar = False
        specialchar_list = ['+', '-', '*', '/', '_', '&', '%', ',']
        for c in self.password:
            if c in specialchar_list:
                has_specialchar = True
                break
        return has_specialchar

    def process_password(self):
        """
          判断是否符合规则
        """
        # 规则1：长度至少8位
        if len(self.password) >= 8:
            self.strength_level += 1
        else:
            self.msg = '密码长度至少8位'
            return

        # 规则2：必须包含数字
        if self.check_number_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含数字'
            return

        # 规则3：必须包含大小写字母
        if self.check_letter_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含大小写字母'
            return

        # 规则4：需要包含特殊字符
        if self.check_specialchar_exist():
            self.strength_level += 1
        else:
            self.msg = '密码需要包含至少一个特殊字符("+,-,*,/,_")'
            return
        self.msg = '注册成功'


@app.post("/register")
async def register(user: User):
    mypwdtool = PasswordTool(user.password)
    mypwdtool.process_password()
    if mypwdtool.msg == "注册成功":
        with open('User.json', 'r') as file:
            # 读取文件内容
            content = file.read()
            a = eval(content)
        for e in a["list"]:
            if e['username'] == user.username:
                return {"code": '00000', "msg": '账号已存在'}
        a["list"].append({'username': user.username, 'password': user.password})
        with open('User.json', 'w') as file:
            b = str(a)
            file.write(b)
        return {"code": '00000', "msg": '注册成功'}
    else:
        return {"code": '00000', "msg": mypwdtool.msg}

```

### 状态码

```python
@app.post("/login", status_code=status.HTTP_201_CREATED)
async def login(user: schemas.Users, response: Response, db: Session = Depends(get_db)):
	# 设置状态码
    response.status_code = 202
```

### HTTPException(返回 HTTP 错误响应)

```python
from fastapi import FastAPI, HTTPException
@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=400, detail={"code": 401, "msg": "密码错误"}, headers={"X-Error": "error"})
    return {"item": items[item_id]}
```

# 服务器

## 上传

```
vscode SFTP插件
ctrl + shift + p呼出命令行,运行SFTP:config,创建文件.vscode/sftp.json
```

## nginx

```
启动nginx
systemctl start nginx
停止nginx
systemctl stop nginx
重启nginx
systemctl reload nginx
查看nginx的状态（正常启动，会看到绿色的running）
systemctl status nginx

lsof -i tcp:8088
查看端口
 kill -9 (PID)
清端口
nohup uvicorn main:app --port 8099
nohup 后台运行 fastapi

```

## fastapi部署

```
server {
      	listen 8088;
          server_name 47.96.28.91;# 这里的domain_name是域名地址。
          location / {
              proxy_pass http://127.0.0.1:8099; # 注意这里的端口跟配置脚本的端口一致。
              proxy_set_header Host $host;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          }
      }
      
gunicon_conf.py
from multiprocessing import cpu_count

    # 是否守护
    daemon = True

    # 绑定
    bind = '0.0.0.0:8099'

    # pid 文件地址
    pidfile = 'gunicorn.pid'

    # 项目地址
    chdir = './main.py'

    # Worker Options
    workers = cpu_count() + 1
    worker_class="uvicorn.workers.UvicornWorker"
    threads = 2

    # Logging Options
    loglevel="debug"
    accesslog = 'access_log.log'
    errorlog =  'error_log.log'

import uvicorn
from fastapi import FastAPI
 
app = FastAPI()
 
@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/test")
def test():
    return {"Hello": "World test"}

if __name__ == '__main__':
    uvicorn.run('main:app', port=8099, reload=True)
```

## vue部署

```
include /root/myvue/*.conf;
server {
        listen	8077;                          
        server_name  47.96.28.91;                          
        location / {
            root   /usr/local/nginx/html/dist;             
            index  index.html;                     
            try_files $uri $uri/ @router;
        }
 
        location @router {
			    rewrite ^.*$ /index.html last; 
		    }
        
        location /prod-api/ {
            proxy_pass http://47.96.28.91:8080/;  
        }
        error_page   500 502 503 504  /50x.html;  
	}
```

# 工作

## 字符集

```
qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM数聚算力市场共享创镜像应关于键式部署摆脱烦恼宵夜档免费通过平台上合整资源既能得缓芯解片短缺导荒又让置用法户忙时自收器模获益社区闲导致面国的内试一 可，、”“！。,-
```

## 配置

```
备注：需预留一个盘作为容错盘 计算使用内存时需减去


1.华为RH2288 E5-2680V4*2 主频2.2G 24核48线程 内存DDR4 32G 硬盘容量SSD240G*1 SAS 3TB*1 阵列卡3108 460W双电 12个3.5寸硬盘位
	（价格：1450） 评价：适用中型企业文件服务器，二手，注意：缺乏冗余
2.DELL 戴尔R730XD  CPU: E5-2630V4*2颗 20核40 程 内存16GB DDR4  硬盘3TB SAS*2个 阵列卡:H730 电源:单电源 495W 12个3.5寸硬盘位 单槽18T
	（价格：1200） 评价：中小型企业文件服务器，二手，注意：比上一个配置更低一些，列阵卡H730 更适配戴尔服务器
3.华为RH1288V2 E5-2660V2*2 主频2.2G 20核40线程 内存32G DDR3 3T*1SAS硬盘 2308阵列卡 460W 双电 12个3.5寸硬盘
	（价格：1090） 评价：方案1的丐版

（公司主机 加装硬盘---优点：成本低。缺点：大量并发请求时可能性能不足，长期连续运行可能需要维护，散热和电源，故障恢复较慢。）

郎显：
	价格：2,530 

富裕情况：
群晖 DS423：4个插槽 最高支持88t 4G内存 不含硬盘： 4800
群晖 DS1621 8个插槽 最高支持176T 4G内存 不含硬盘： 8000






服务器级处理器  核心数量和线程较少  变慢或卡顿  ECC 内存（能够检测和纠正内存数据中的单位位错误的计算机内存）


```

| 名称         | 华为RH2288                            |                |
| ------------ | ------------------------------------- | -------------- |
| **处理器**   | **E5-2650V4\*2个主频2.2G 24核48线程** |                |
| **内存**     | **DDR4 32G**                          |                |
| **硬盘容量** | **SSD 240G\*1块 **                    |                |
| **阵列卡**   | **3108**                              |                |
| **电源**     | **460W双电**                          | 裸机：1350     |
| **机械硬盘** | **20T * 3 全新**                      | 全新：2080 * 1 |
|              | 系统免费安装ext4 阵列raid5 机械保2年  | **总价：7590** |



## 市场

```
中小企业中使用AI 所遇瓶颈

1.即使AI技术能在理论上提高效率或优化流程，但如果无法将这些优势转化为直接的经济收益 缺乏明确的盈利模式 难以推进
2.AI模型的成功依赖于大量高质量的数据  
	例：
		自然语言模型：包含了来自互联网上的大量文本数据，包括书籍、文章、网站内容
	 	计算机视觉模型
3.缺乏专业人才 通常需要针对具体的业务场景进行定制化开发
```



















































